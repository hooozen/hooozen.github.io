[{"title":"堆(优先队列)的实现原理","url":"/archives/76/","content":"\n堆(优先队列)是数据结构与算法中非常经典的结构，被广泛应用到计算机科学当中. 例如在堆排和优先级调度中堆便是核心的数据结构. 本文介绍堆的基本实现原理，力求清晰易懂.\n\n<!--more-->\n\n## 1. 基础概念\n\n> In computer science, a heap is a specialized tree-based data structure that satisfies the heap property: In a max heap, for any given node C, if P is a parent node of C, then the key (the value) of P is greater than or equal to the key of C. In a min heap, the key of P is less than or equal to the key of C.\n\n堆(优先队列)的这种结构是为了在堆进行操作时能够尽可能降低算法的复杂度，从使用角度讲，堆(优先队列)支持**初始化**、**队头弹出**、**插入**等操作。并保证从队头取出的元素具有最高的优先级。例如以元素大小作为优先级则可构造大(小)根堆，保证每次从队头取出的都是最大(小)的元素。  \n\n堆的实现一般是由**数组**模拟**完全二叉树**的数据结构实现。用数组存储的完全二叉树中，下标为 `i` 的节点的孩子节点(如果存在)下标分别为 `2i + 1` 和 `2i + 2`. 同理，节点 `i` 的父节点(如果存在)为 `(i - 1) / 2`。\n\n定义优先队列 `Heap` 的 API，其中 `cmp` 用以比较两个元素的优先级：\n\n```ts\nclass Heap<T> {\n  q: T[];\n  cmp: (a: T, b: T) => boolean;\n\n  constructor(data: T[], cmp?: (a: T, b: T) => boolean) {}\n\n  get size() {\n    return this.q.length\n  }\n\n  pop(): T | undefined {}\n  push(x: T) {}\n}\n```\n\n## 2. 核心算法\n\n### 2.1 节点下沉 (sink)\n\n如果有一个二叉树，它的左子树和右子树都已经是大根堆，为了使该二叉树构成堆，需要把根节点“**下沉 (sink)**“ 到合适的位置：\n\n- 将该二叉树根节点的值与左右子树的根节点做对比，\n- 如果它的值大于左右子树根节点则此二叉树也构成一个大根堆. 算法结束.\n- 否则将它与比自身大的那个节点的位置进行交换\n- 此时继续考虑交换后节点所在的子树，**递归**执行上述操作\n\n通过以上算法，初始的根节点被“**下沉**”到合适的位置，最终形成一个大根堆。\n\n下沉算法的递归实现如下：\n\n```ts\nsink(i: number) {\n  let max = 2 * i + 1\n\n  if (max >= this.size) return\n\n  if (max + 1 < this.size && this.cmp(this.q[max + 1], this.q[max])) {\n    ++max\n  }\n\n  if (this.cmp(this.q[i], this.q[max])) return;\n\n  [this.q[i], this.q[max]] = [this.q[max], this.q[i]]\n  this.sink(max)\n}\n```\n\n实际上，下沉算法往往使用迭代实现：\n\n```ts\nsink(i: number) {\n  while (2 * i + 1 < this.size) {\n    let max = 2 * i + 1\n\n    if (max + 1 < this.size && this.cmp(this.q[max + 1], this.q[max])) {\n      ++max\n    }\n\n    if (this.cmp(this.q[i], this.q[max])) break;\n\n    [this.q[i], this.q[max]] = [this.q[max], this.q[i]]\n\n    i = max\n  }\n}\n```\n\n### 2.2 节点上浮 (swim)\n\n对于一个堆，如果在它的末尾插入一个元素，为了保证堆的性质需要把该节点“**上浮 (swim)**”到合适的位置：\n\n- 将该元素与它的父节点进行比较，如果满足堆的定义，则此时二叉树构成堆，算法结束\n- 否则将他与父元素交换\n- 递归执行上述操作\n\n当算法结束时，新插入的节点**上浮 (swim)** 到合适的位置使堆的性质得以保证.\n\n上浮算法的递归实现如下：\n\n```ts\nswim(i: number) {\n  const p = Math.floor((i - 1) / 2)\n\n  if (p < 0) return\n\n  if (this.cmp(this.q[p], this.q[i])) return;\n  [this.q[p], this.q[i]] = [this.q[i], this.q[p]]\n\n  this.swim(p)\n}\n```\n\n实际上，常用迭代实现上浮算法：\n\n```ts\nswim(i: number) {\n  while (Math.floor((i - 1) / 2) >= 0) {\n    const p = Math.floor((i - 1) / 2)\n    if (this.cmp(this.q[p], this.q[i])) break;\n\n    [this.q[p], this.q[i]] = [this.q[i], this.q[p]]\n    i = p\n  }\n}\n```\n\n## 3. API 实现\n\n有了上浮和下沉算法，堆的 API 实现起来就非常简单直观了.\n\n### 3.1 插入元素\n\n往一个堆里插入元素时，只需要把该元素放到堆的末尾，然后把该元素上浮到合适的位置即可：\n\n```ts\npush(x: T) {\n  this.q.push(x)\n  this.swim(this.size - 1)\n}\n```\n\n### 3.2 弹出元素\n\n由于堆的性质，队首的元素一定是优先级最高的元素. 因此直接把该元素弹出即可. 为了保证剩下数据仍然符合堆的性质，需要把末尾的元素放到队首，然后把它下沉到合适的位置即可.\n\n```ts\npop(): T | undefined {\n  const res = this.q[0]\n  this.q[0] = this.q[this.size - 1]\n  this.q.pop()\n  this.sink(0)\n\n  return res\n}\n```\n\n### 3.3 初始化建堆\n\n建堆是指对于一个空堆，给定一组元素把这些元素组织成一个堆. 一个简单的思路是一次把这些元素 `push` 到堆中.  但实际上往往使用一种更高效的方法, 这种方法在原有的数组上进行调整，最后使之成为堆.\n\n对于给定的数组直接把它看成一个完全二叉树，显然这棵树的所有叶子节点都是一个堆. 那么对于这些叶子节点的父节点满足下沉算法的初始条件，则对这些父节点执行下沉算法后，新的堆被建立. 递归的考虑以这些堆的父节点为根节点的二叉树，对他们执行下沉算法，逐级完成堆的构建，直至抵达根节点.\n\n简而言之，从数组中的最后一个非叶子节点倒序遍历该数组并执行下沉算法，即完成堆的建立:\n\n```ts\ninit() {\n  for (let i = Math.floor((this.size - 2) / 2); i >= 0; i--) {\n    this.sink(i)\n  }\n}\n```\n\n### 3.4 完整实现\n\n堆的实现主要依赖两个核心算法: **下沉**和**上浮**，具体 API 的实现都是基于这两个算法的简单使用.\n\n```ts\nexport default class Heap<T> {\n  q: T[];\n  cmp: (a: T, b: T) => boolean;\n\n  constructor(data: T[], cmp?: (a: T, b: T) => boolean) {\n    this.q = data\n    this.cmp = cmp || ((a: T, b: T) => (a as number) - (b as number) > 0);\n    this.init()\n  }\n\n  get size(): number {\n    return this.q.length\n  }\n\n  init() {\n    for (let i = Math.floor((this.size - 2) / 2); i >= 0; i--) {\n      this.sink(i)\n    }\n  }\n\n  sink(i: number) {\n    while (2 * i + 1 < this.size) {\n      let max = 2 * i + 1\n\n      if (max + 1 < this.size && this.cmp(this.q[max + 1], this.q[max])) {\n        ++max\n      }\n\n      if (this.cmp(this.q[i], this.q[max])) break;\n\n      [this.q[i], this.q[max]] = [this.q[max], this.q[i]]\n\n      i = max\n    }\n  }\n\n  pop(): T | undefined {\n    const res = this.q[0]\n    this.q[0] = this.q[this.size - 1]\n    this.q.pop()\n    this.sink(0)\n\n    return res\n  }\n\n  push(x: T) {\n    this.q.push(x)\n    this.swim(this.size - 1)\n  }\n\n  swim(i: number) {\n    while (Math.floor((i - 1) / 2) >= 0) {\n      const p = Math.floor((i - 1) / 2)\n      if (this.cmp(this.q[p], this.q[i])) break;\n\n      [this.q[p], this.q[i]] = [this.q[i], this.q[p]]\n      i = p\n    }\n  }\n}\n```\n","tags":["数据结构","堆"],"categories":["developer"]},{"title":"Vue3 响应式(4)-Wacth 的实现原理","url":"/archives/75/","content":"\n前几篇文章已经构建了较为完善的响应式系统，并且实现了计算属性 computed 以及调度器、懒执行等特性。这一篇文章就来实现另外一个重要的功能—— watch 监听。\n\n<!--more-->\n\n## watch 的基础原理\n\n### 简单实现\n\nwatch 无非是实现这样一个功能：对于指定的响应式变量，当该变量发生变化时能够执行指定的回调函数。这一个需求完全可以使用调度器 scheduler 来实现。例如下面的代码，通过给 `effect` 传入一个读取 `data.cnt` 的函数，来使 `data.cnt` 与副作用函数进行绑定。然后在 `scheduler` 上指定回调函数，每当 `data.cnt` 发生变化时就执行指定的回调函数。\n\n```js\nconst data = reactive({ cnt: 0 })\n\neffect(() => {\n  data.cnt  // 触发 track 函数\n}, {\n  scheduler: () => {\n    // to do something when data.cnt changes\n    console.log('data.cnt changed')\n  }\n})\n```\n\n### 递归监听所有属性\n\n上一节中实现监听的方式有一个明显的不足，那就是必须指定要监听响应式数据的哪个属性，否则其他属性的变化不会触发绑定的回调函数。但实际上我们希望所监听变量的任何属性发生变化都能触发回调。这就自然而然想到使用递归的方法来遍历变量的所有属性。我们如此封装 `watch` 函数，其中 `traverse(obj)` 用来递归的读取 `obj` 的所有属性：\n\n```js\nfunction watch(obj, handler) {\n  effect(\n    () => traverse(obj),\n    {\n      scheduler: hanlder\n    }\n  )\n}\n\nfunction traverse(obj, seen = new Set()) {\n  if (typeof obj !== 'object' || value === null || seen.has(obj)) return\n  seen.add(obj)\n\n  for (const k in obj) {\n    traverse(obj[k])\n  }\n\n  return obj  // 这里之所以返回 obj 是为了后面保存 watch 的值用\n}\n```\n\n有了以上的封装我们就可以直接调用 `watch` 来自动追踪响应式数据的所有变化了：\n\n```js\nwatch(obj, () => {\n  // to do something when data changes\n  console.log('obj changed')\n})\n```\n\n### `getter`\n\nVue 中对于 `watch` 方法还提供了 `getter` 的使用方式，它的调用方式如下。通过 `getter` 返回一个响应式数据，watch 仅仅监听 `getter` 返回的值，并且默认不会进行深层监听。\n\n```js\nwatch(\n  () => obj.cnt,\n  () => {\n    // to do something when data changes\n  }\n)\n```\n\n为 `watch` 添加 `getter` 的实现非常简单，即通过判断 `watch` 的第一个参数是不是函数 (`getter`)，如果是函数则直接将 `getter` 作为副作用函数传给 `effect`，否则使用上面的递归处理。代码如下：\n\n```js\nfunction watch(source, handler) {\n  let getter\n  if (typeof source === 'function') {\n    getter = source\n  } else {\n    getter = () => traverse(source)\n  }\n  effect(\n    getter,\n    {\n      scheduler: hanlder\n    }\n  )\n}\n```\n\n## watch 的功能优化\n\n### 获得“新旧值”\n\n这里实现 Vue.js 中回到函数中获取新旧值参数的功能。这里主要利用到 `lazy` 选项。\n\n```js\nfunction watch(source, handler) {\n  let getter\n  if (typeof source === 'function') {\n    getter = source\n  } else {\n    getter = () => traverse(source)\n  }\n\n  let oldVal, val\n\n  const effectFn = effect(\n    getter,\n    {\n      lazy: true,\n      scheduler() {\n        val = effectFn()\n        handler(oldVal, val)\n        oldVal = val\n      } \n    }\n  )\n\n  oldVal = effectFn()\n}\n```\n\n### `immediate` 立即执行\n\n通过以上的封装，`watch` 所监听的数据只有发生变化时才会执行回调函数。我们同样可以像 Vue.js 中为其设置 `immediate` 参数来使其立即执行。\n\n```js\nfunction watch(source, handler, options) {\n  let getter\n  if (typeof source === 'function') {\n    getter = source\n  } else {\n    getter = () => traverse(source)\n  }\n\n  let oldVal, val\n\n  const job = () => {\n    val = effectFn()\n    handler(oldVal, val)\n    oldVal = val\n  }\n\n  const effectFn = effect(\n    getter,\n    {\n      lazy: true,\n      scheduler: job\n    }\n  )\n\n  if (options.immediate) {\n    job()\n  } else {\n    oldVal = effectFn()\n  }\n}\n```\n\n## 小结\n\n本文实现了 Vue.js 数据侦听方法 `watch` 的基础原理，全部的代码如下。[点击这里](https://codepen.io/Hozen/pen/abPqVxK) 在线运行和调试。\n\n```js\nlet activeEffect;\nconst effectStack = [];\nconst bucket = new WeakMap();\n\nconst data = reactive({ foo: 1, bar: 2 });\n\nwatch(\n  () => data.bar,\n  (old, val) => {\n    console.log(`data change from ${old} to ${val}`);\n  },\n  { immediate: true }\n);\n\nsetTimeout(() => {\n  data.bar = 100;\n}, 2000);\n\nfunction watch(source, cb, options = {}) {\n  let getter;\n  if (typeof source === \"function\") {\n    getter = source;\n  } else {\n    getter = () => traverse(source);\n  }\n\n  let oldVal, val;\n  const job = () => {\n    val = effectFn();\n    cb(oldVal, val);\n    oldVal = val;\n  };\n\n  const effectFn = effect(getter, {\n    lazy: true,\n    scheduler: job\n  });\n\n  if (options.immediate) {\n    job();\n  } else {\n    oldVal = effectFn();\n  }\n}\n\nfunction traverse(obj, seen = new Set()) {\n  if (typeof obj !== \"object\" || obj === null || seen.has(obj)) return;\n  for (const k in obj) {\n    traverse(obj[k]);\n  }\n  return obj;\n}\n\nfunction computed(getter) {\n  let dirty = true;\n  let cache;\n  const effectFn = effect(getter, {\n    lazy: true,\n    scheduler: () => {\n      dirty = true;\n      trigger(obj, \"value\");\n    }\n  });\n  const obj = {\n    get value() {\n      if (dirty) {\n        cache = effectFn();\n        dirty = false;\n      }\n      track(obj, \"value\");\n      return cache;\n    }\n  };\n  return obj;\n}\n\nfunction reactive(obj) {\n  return new Proxy(obj, {\n    get(target, key) {\n      track(target, key);\n      return Reflect.get(target, key);\n    },\n    set(target, key, value) {\n      const res = Reflect.set(target, key, value);\n      trigger(target, key);\n      return res;\n    }\n  });\n}\n\nfunction track(target, key) {\n  if (!activeEffect) return;\n  let depsMap = bucket.get(target);\n  if (!depsMap) {\n    bucket.set(target, (depsMap = new Map()));\n  }\n  let deps = depsMap.get(key);\n  if (!deps) {\n    depsMap.set(key, (deps = new Set()));\n  }\n  deps.add(activeEffect);\n  activeEffect.depSets.push(deps);\n}\n\nfunction trigger(target, key) {\n  let depsMap = bucket.get(target);\n  if (!depsMap) return;\n  let deps = depsMap.get(key);\n  if (!deps) return;\n  const depsToRun = new Set(deps);\n  //  depsToRun.forEach(fn => fn())\n  depsToRun.forEach((fn) => {\n    if (fn === activeEffect) return;\n    if (fn.options.scheduler) {\n      // 如果设置了调度器，则将副作用函数的执行交给调度器\n      fn.options.scheduler(fn);\n    } else {\n      // 否则默认直接执行副作用函数\n      fn();\n    }\n  });\n}\n\nfunction effect(fn, options = {}) {\n  const effectFn = () => {\n    cleanup(effectFn);\n    activeEffect = effectFn;\n    effectStack.push(effectFn);\n\n    const res = fn(); // 获取副作用函数的结果\n\n    effectStack.pop();\n    activeEffect = effectStack[effectStack.length - 1];\n\n    return res; // 返回副作用函数结果\n  };\n  effectFn.depSets = [];\n  effectFn.options = options;\n  if (!options.lazy) {\n    effectFn(); // 立即执行一次 effectFn 建立绑定\n  }\n  return effectFn; // 返回 effectFn\n}\n\nfunction cleanup(effectFn) {\n  effectFn.depSets.forEach((deps) => {\n    deps.delete(effectFn);\n  });\n  effectFn.depSets.length = 0;\n}\n```\n\n## *参考资料*\n\n[1] vuejs/core: 🖖 Vue.js is a progressive, incrementally-adoptable JavaScript framework for building UI on the web.[EB/OL]. [2023-09-22]. <https://github.com/vuejs/core>.\n\n[2] Vue.js - 渐进式 JavaScript 框架 | Vue.js[EB/OL]. [2023-09-22]. <https://cn.vuejs.org/>.\n\n[3] 霍春阳. Vue.js设计与实现[M/OL]. 人民邮电出版社, 2022[2023-09-19]. <https://book.douban.com/subject/35768338/>.\n\n[4] JavaScript | MDN[EB/OL]. [2023-04-10](2023-09-22). <https://developer.mozilla.org/zh-CN/docs/Web/JavaScript>.\n","tags":["响应式","Vue"],"categories":["developer"]},{"title":"Vue3 响应式(3)-计算属性 computed","url":"/archives/74/","content":"\n上文[Vue3 响应式(2)-分支切换、嵌套、和无限递归](https://www.hozen.site/archives/73/)解决了原有响应式系统的一些问题，实现了较为完善的数据绑定。本文在此基础上实现简单的计算属性功能 `computed`。\n\n<!--more-->\n\n## 调度器 Scheduler\n\n在实现计算属性前，先介绍一下调度器 Scheduler，它将在实现计算属性和监听等特性时使用。\n\n在原有的实现中，每次响应式数据发生变化时都会自动的调用副作用函数。但有时候我们可能希望控制副作用函数的调用时机，或者在调用前后做一些其他的事情，而不是让副作用函数直接执行。\n\n通过之前的代码我们知道，副作用函数的执行是在 `trigger` 方法中的以下片段：\n\n```js\nfunction trigger(target, key) {\n  // ...\n  effectToRun.forEach(fn => {\n    if (fn !== activeEffect) fn()\n  })\n}\n```\n\n如果想要控制副作用函数的执行实际，则只需要传入一个回调函数，在上述代码片段中不直接执行 `fn`，而是把 `fn` 作为参数传给回调函数。具体如何执行副作用函数就可以通过传入不同的回调函数来决定了。这里可以通过给副作用函数绑定一个 `scheduler` 参数来实现，代码改动如下：\n\n```js\nfunction effect(fn, options={}) {\n  const effectFn = () => {\n    //...\n  }\n  effectFn.depSets = []\n  effectFn.options = options\n  effectFn()\n}\n\nfunction trigger(target, key) {\n  // ...\n  effectToRun.forEach(fn => {\n    if (fn === activeEffect) return\n    if (fn.options.scheduler) {\n      // 如果设置了调度器，则将副作用函数的执行交给调度器\n      fn.options.scheduler(fn)\n    } else {\n      // 否则默认直接执行副作用函数\n      fn()\n    }\n  })\n}\n```\n\n## 计算属性 computed\n\n### computed 的设计目标\n\n我们希望设计这样的一个函数 `computed`，该函数接受一个函数作为参数 (记为 `getter`)，并返回一个对象 (记作 `obj`)，该对象的值由 `getter` 计算获得。每当 `getter` 中所依赖的数据发生变化时，`obj.value` 都能被重新计算获得更新。\n\n```js\nfunction computed(getter) {\n  // ... \n  return {\n    value: // computed by getter\n  }\n}\n\nconst obj = computed(() => {\n  // ... depends on some value\n  return res\n})\n\nconsole.log(obj.value)\n```\n\n并且在使用 Vue 的过程中我们还会发现，当计算属性被定义后而没有被使用前，计算属性所依赖的变量变化是不会被触发计算的，即“懒”执行。因此我们总结设计的 `computed` 要达到以下目标：\n\n* 响应式，当所依赖的响应式数据变化时能够更新状态\n* 返回一个由 `getter` 计算获得的值\n* “懒”执行，只有 `obj.value` 被读取时才会触发计算\n* 缓存，当计算结果不变时，`computed` 能够使用缓存值以减少重复的计算\n\n### 返回值的实现\n\n首先对于响应式的要求，我们之前实现的 `effect` 函数完全可以达到目的，直接调用 `effect(getter)` 就可以把 `getter` 中的依赖与 `getter` 绑定起来，每当依赖发生变化，`getter` 就会被重新执行。但问题在于无法拿到 `getter` 返回的值，为了达到这一目的可以对原有的 `effect` 做如下改动:\n\n```js\nfunction effect(fn, options={}) {\n  const effectFn = () => {\n    cleanup(effectFn)\n    activeEffect = effectFn\n    effectStack.push(effectFn)\n\n    const res = fn()  // 获取副作用函数的结果\n\n    effectStack.pop()\n    activeEffect = effectStack[effectStack.length - 1]\n\n    return res  // 返回副作用函数结果\n  }\n  effectFn.depSets = []\n  effectFn.options = options\n  effectFn()  \n  return effectFn  // 返回 effectFn\n}\n```\n\n通过以上的改动，让 `effectFn` 函数从 `effect` 中返回，那么就可以从外部调用 `effectFn` 了，并且任何时候调用 `effectFn` 获得的返回值都是根据最新的依赖所计算的。\n\n### `lazy` 懒执行的实现\n\n增加 `options.lazy` 来控制是否在调用 `effect` 时立即执行 `effectFn`，非常简单:\n\n```js\nfunction effect(fn, options={}) {\n  const effectFn = () => {\n    cleanup(effectFn)\n    activeEffect = effectFn\n    effectStack.push(effectFn)\n\n    const res = fn()  // 获取副作用函数的结果\n\n    effectStack.pop()\n    activeEffect = effectStack[effectStack.length - 1]\n\n    return res  // 返回副作用函数结果\n  }\n  effectFn.depSets = []\n  effectFn.options = options\n  if (!options.lazy) {\n    effectFn()  // 立即执行一次 effectFn 建立绑定\n  }\n  return effectFn  // 返回 effectFn\n}\n```\n\n有了 `lazy: true` 选项，当我们不调用 `effect` 返回的 `effectFn` 时，`effectFn` 永远不会执行，并且也不会发生数据的绑定。这样无论计算属性所依赖的值发生多少次变化都不会触发计算属性。\n\n但是，这里的“懒执行”其实仍然有一个问题 (不够“懒”)，我将在下面介绍并解决它。\n\n### 包装 `computed`\n\n有了以上基础，包装计算属性就顺理成章了。我们只需要在每次读取 `obj.value` 时去执行一下 `effectFn` 并把其返回值作为 `obj.value` 返回给用户就可以了。这样自然而然想到使用对象的 `get` 方法。\n\n```js\nfunction computed(getter) {\n  const effectFn = effect(getter, { lazy: true });\n  return {\n    get value() {\n      return effectFn();\n    }\n  };\n}\n```\n\n### 缓存的实现\n\n当我们多次读取 `obj.value` 时，即使依赖没有发生变化，还是会反复调用 `effectFn` 中的副作用函数 `fn` 来重新计算获得相同的结果。这显然是对性能的浪费。因此需要对其实现缓存的功能。缓存的实现也非常简单，在 `computed` 中缓存计算结果并设置标记，而在依赖发生变化时重置标记。当有标记时重新计算更新缓存，否则直接返回缓存。\n\n```js\nfunction computed(getter) {\n  let dirty = true \n  let cache  // 缓存计算结果\n  const effectFn = effect(getter, { lazy: true });\n  return {\n    get value() {\n      if (dirty) {\n        // 需要重新计算\n        cache = effectFn()  // 更新缓存\n        dirty = false  // 设置标记\n      }\n      return cache;\n    }\n  };\n}\n```\n\n但以上的修改只完成了“设置标记”的工作，还应该在依赖发生变化即在 `trigger` 中调用 `effectFn` 时重置标记。此时调度器 Scheduler 就派上了用场：\n\n```js\nfunction computed(getter) {\n  let dirty = true  // 标记是否需要从新计算\n  let cache  // 缓存计算结果\n  const effectFn = effect(getter, { \n    lazy: true,\n    scheduler: () => {\n      dirty = true\n    }\n  });\n  return {\n    get value() {\n      if (dirty) {\n        cache = effectFn()\n        dirty = false\n      }\n      return cache;\n    }\n  };\n}\n```\n\n通过调度器就完成了“清除标记”的工作。同时它还解决了“懒执行”中的遗留问题：在原来的代码中，一旦计算属性的依赖发生，无论有没有读取计算属性的值，都会触发它所关联的副作用函数 (即 `getter`)，这并不“懒”。但通过调度器，跳过了 `trigger` 中 `fn` 的执行，仅仅设置了 `dirty` 标记。因此依赖发生变化时，并不会执行副作用函数，除非真正的读取计算属性的值，真正实现了“懒”执行。\n\n### 最后一个问题\n\n当我们使用 `effect` 包裹一个依赖于计算属性的副作用函数时，当然希望当计算属性发生变化时会触发副作用函数。这就像使用 Vue 时把计算属性渲染到模板中，当计算属性发生变化时更新模板中的值。例如：\n\n```js\nconst data = reactive({ foo: 1, bar: 2})\nconst sumRes = computed(() => data.foo + foo.bar)\n\neffect(() => {\n  document.body.innerText = sumRes.value\n})\n\ndata.foo = 100\n```\n\n当把 `data.foo` 的值更新为 `100` 时，我们希望更新页面文本的副作用函数会被调用，从而重新计算 `sumRes.value` 把最新的值 `202` 更新到页面。但实际上这并没有发生。这是因为在定义计算属性时只会将 `data.foo`, `foo.bar` 与包装 `getter` 的副作用函数关联，而不会与包裹计算属性的外层副作用函数产生关联。这和我们在上一篇文章中介绍的嵌套的 `effect` 是一样的，即内部的副作用函数里依赖的变量发生变化，只会触发内部副作用函数而不会触发外部副作用函数。但在计算属性的需求下，我们需要它来触发外部的副作用函数。\n\n为了修复上面的问题，需要在 `computed` 的实现中通过手动调用 `track` 和 `trigger` 添加关联：\n\n```js\nfunction computed(getter) {\n  let dirty = true  // 标记是否需要从新计算\n  let cache  // 缓存计算结果\n  const effectFn = effect(getter, { \n    lazy: true,\n    scheduler: () => {\n      dirty = false \n      trigger(obj, 'value')  // 2.发生变化时触发副作用函数\n    }\n  });\n  const obj = {\n    get value() {\n      if (dirty) {\n        cache = effectFn()\n        dirty = false\n      }\n      track(obj, 'value')  // 1.读取值时添加关联\n      return cache;\n    }\n  };\n  return obj\n}\n```\n\n当计算属性出现在 `effect` 内部时，此时 `activeEffect` 的值则为当前的副作用函数，因此读取计算属性的值时会调用 `track` 把计算属性的 `value` 与当前的副作用函数关联起来。自然地，当计算属性的值更新时，则会调用 `trigger` 把相关的副作用函数执行。\n\n## 小结\n\n本文主要介绍了调度器和计算属性的实现，其中计算属性涉及“懒”执行和缓存等问题。最终的代码实现如下。可以[点击这里](https://codepen.io/Hozen/pen/mdaXboj)在线运行测试。\n\n```js\nconsole.log(\"code: Vue3_reactive_3_computed\");\n\nlet activeEffect;\nconst effectStack = [];\nconst bucket = new WeakMap();\n\nconst data = reactive({ foo: 1, bar: 2 });\nconst sumRes = computed(() => data.foo + data.bar);\n\neffect(() => {\n  document.body.innerText = sumRes.value;\n});\n\nsetTimeout(() => {\n  data.foo = 100;\n}, 2000);\n\nfunction computed(getter) {\n  let dirty = true;\n  let cache;\n  const effectFn = effect(getter, {\n    lazy: true,\n    scheduler: () => {\n      dirty = true;\n      trigger(obj, \"value\");\n    }\n  });\n  const obj = {\n    get value() {\n      if (dirty) {\n        cache = effectFn();\n        dirty = false;\n      }\n      track(obj, \"value\");\n      return cache;\n    }\n  };\n  return obj;\n}\n\nfunction reactive(obj) {\n  return new Proxy(obj, {\n    get(target, key) {\n      track(target, key);\n      return Reflect.get(target, key);\n    },\n    set(target, key, value) {\n      const res = Reflect.set(target, key, value);\n      trigger(target, key);\n      return res;\n    }\n  });\n}\n\nfunction track(target, key) {\n  if (!activeEffect) return;\n  let depsMap = bucket.get(target);\n  if (!depsMap) {\n    bucket.set(target, (depsMap = new Map()));\n  }\n  let deps = depsMap.get(key);\n  if (!deps) {\n    depsMap.set(key, (deps = new Set()));\n  }\n  deps.add(activeEffect);\n  activeEffect.depSets.push(deps);\n}\n\nfunction trigger(target, key) {\n  let depsMap = bucket.get(target);\n  if (!depsMap) return;\n  let deps = depsMap.get(key);\n  if (!deps) return;\n  const depsToRun = new Set(deps);\n  //  depsToRun.forEach(fn => fn())\n  depsToRun.forEach((fn) => {\n    if (fn === activeEffect) return;\n    if (fn.options.scheduler) {\n      // 如果设置了调度器，则将副作用函数的执行交给调度器\n      fn.options.scheduler(fn);\n    } else {\n      // 否则默认直接执行副作用函数\n      fn();\n    }\n  });\n}\n\nfunction effect(fn, options = {}) {\n  const effectFn = () => {\n    cleanup(effectFn);\n    activeEffect = effectFn;\n    effectStack.push(effectFn);\n\n    const res = fn(); // 获取副作用函数的结果\n\n    effectStack.pop();\n    activeEffect = effectStack[effectStack.length - 1];\n\n    return res; // 返回副作用函数结果\n  };\n  effectFn.depSets = [];\n  effectFn.options = options;\n  if (!options.lazy) {\n    effectFn(); // 立即执行一次 effectFn 建立绑定\n  }\n  return effectFn; // 返回 effectFn\n}\n\nfunction cleanup(effectFn) {\n  effectFn.depSets.forEach((deps) => {\n    deps.delete(effectFn);\n  });\n  effectFn.depSets.length = 0;\n}\n```\n\n## *参考资料*\n\n[1] vuejs/core: 🖖 Vue.js is a progressive, incrementally-adoptable JavaScript framework for building UI on the web.[EB/OL]. [2023-09-22]. <https://github.com/vuejs/core>.\n\n[2] Vue.js - 渐进式 JavaScript 框架 | Vue.js[EB/OL]. [2023-09-22]. <https://cn.vuejs.org/>.\n\n[3] 霍春阳. Vue.js设计与实现[M/OL]. 人民邮电出版社, 2022[2023-09-19]. <https://book.douban.com/subject/35768338/>.\n\n[4] JavaScript | MDN[EB/OL]. [2023-04-10](2023-09-22). <https://developer.mozilla.org/zh-CN/docs/Web/JavaScript>.\n","tags":["响应式","Vue"],"categories":["developer"]},{"title":"Vue3 响应式(2)-分支切换、嵌套、和无限递归","url":"/archives/73/","content":"\n上文[Vue3 响应式(1)-基础原理](https://www.hozen.site/archives/72/)介绍了响应式系统的基本原理并利用 Proxy 进行了简单的实现，能够应对简单的响应式场景。但该系统仍然面临着一些问题，比如当副作用函数中既包含对响应式对象的读取操作也包含设置操作时会使系统进入无限递归的死循环、当代码分支切换时冗余的关联没有被及时清理等问题。本文就来一一介绍这些问题以及解决方法。\n\n<!--more-->\n\n## 分支切换\n\n### 分支切换问题的描述\n\n对于原有的响应式系统，我们考虑这样一个场景：\n\n``` js\nconst data = reactive({\n  isShow: true,\n  text: 'Hi!'\n})\n\nfunction fn() {\n  console.log('Debug: update text')\n  document.body.innerText = data.isShow ? data.text : ''\n}\n\neffect(fn)\n\ndata.isShow = false\ndata.text = 'Hello World!'\n\n```\n\n根据原有的实现，当执行 `effect` 时会立即调用 `fn`，由于 `data.isShow` 为 `true`，因此会读取 `data.text` 的值，此时代理的 `get` 拦截器会把 `fn` 分别与 `data.isShow` 和 `data.text` 关联。因此当执行 `data.isShow = false` 时，会重新执行 `fn`，将页面的文本置空。至此都没有任何问题，但是由于此时 `data.isShow` 为 `false`，副作用函数 `fn` 并不依赖于 `data.text` 了，也就是说无论 `data.text` 的值发生什么变化都不产生任何副作用，无需再次调用 `fn` 了。但由于开始时已经将 `fn` 与 `data.text` 相关联了，所以任何时候设置 `data.text` 时都会重新调用 `fn`，即使这样是没有意义的。\n\n对于这种副作用函数中包含分支切换的情况，每次分支切换时所依赖的响应式变量可能发生变化。由于每次调用副作用函数时都会触发 `get` 拦截器，所以并不担心由于分支切换带来的新增依赖。但对于已经无用的依赖代码中还没有任何清理的操作，这就会导致冗余的副作用函数依然被执行。这样虽然不会对系统产生额外的副作用，但当副作用函数执行开销较大时会对性能产生影响。\n\n### 分支切换问题的解决方法\n\n对于以上问题，解决方法非常简单，那就是在每次副作用函数执行前把该副作用函数从所有与之相关的依赖集合中移除。然后根据此时的分支情况重新收集副作用函数。例如对于上述例子，第一次收集依赖时，集合 `bucket[data].isShow` 和集合 `bucket[data].text` 中都有副作用函数 `fn`。当分支切换时，首先将 `fn` 从这两个集合中删除，然后根据 `data.isShow` 为 `false`，本次执行将只会把 `fn` 收集到集合 `bucket[data].isShow` 中。因此`data.text` 的变化将不会再调用 `fn`。\n\n为了方便的知道副作用函数 `fn` 都存在于哪些集合中，我们需要对副作用函数增加一个数组属性来保存与之关联的集合，并在 `track` 中把相关的集合放入副作用函数数组中。然后在每次副作用函数执行对依赖进行清理。具体的修改如下\n\n```js\nfunction effect(fn) {\n  const effectFn = () => {\n    cleanup(effectFn)  // 为了调用 cleanup 需要重新包装 fn\n    activeEffect = effectFn  // 设置为包装后的 effectFn\n    fn()\n  } \n  effectFn.depSets = []  // 保存相关的集合 \n  effectFn()\n}\n\nfunction track(target, key) {\n   if (!activeEffect) return\n  let depsMap = bucket.get(target)\n  if (!depsMap) {\n    bucket.set(target, (depsMap = new Map()))\n  }\n  let deps = depsMap.get(key)\n  if (!deps) {\n    depsMap.set(key, (deps = new Set()))\n  }\n  deps.add(activeEffect)\n  activeEffect.depSets.push(deps)  // 记录相关的集合\n}\n\nfunction cleanup (effectFn) {\n  effectFn.depSets.forEach(deps => {\n    deps.delete(effectFn)\n  })\n  effectFn.depSets.length = 0  // 清理完毕，数组置空\n}\n```\n\n**但请注意**，通过以上修改虽然完成了对冗余依赖的清理，但是运行时发现系统会进入死循环！这是由于在 `trigger` 中有这么一段代码：\n\n```js\nfunction trigger(target, key){\n  // ...\n  deps.forEach(fn => fn())\n}\n```\n\n在执行该代码时，每次执行 `fn` 时都会触发 `cleanup` 将 `fn` 从集合 `deps` 中清除，然后又触发 `track` 把 `fn` 又重新收集到集合 `deps` 中，就相当于执行以下代码造成死循环：\n\n```js\nconst s = new Set([1])\nfor (const x of s) {\n  s.delete(1)\n  s.add(1)\n}\n```\n\n因此，我们还要对 `trigger` 做一点修改。只需要把要运行的副作用函数集合做一个“快照”，使得接下来的 `cleanup` 不影响本次的运行即可：\n\n```js\nfunction trigger(target, key){\n  // ...\n  // deps.forEach(fn => fn())\n  const depsToRun = new Set(deps)\n  depsToRun.forEach(fn => fn())\n}\n```\n\n## 嵌套的副作用函数\n\n### 嵌套问题的描述\n\n如果副作用函数发生嵌套会发生什么呢？例如对于下面的代码，我们希望 `data.foo` 与外层的副作用函数发生绑定，而 `data.bar` 与内层的副作用函数绑定。但执行 `data.foo = false` 时发现，并没有触发外部的副作用函数而是仅仅触发了内部的副作用函数，这是怎么回事呢？\n\n```js\nconst data = reactive({\n  foo: true,\n  bar: false\n})\n\neffect(() => {\n  effect(() => {\n    console.log('inner effect', data.bar)\n  })\n  console.log('out effect', data.foo)\n})\n\ndata.foo = false\n```\n\n问题出在 `activeEffect` 变量的处理上，当开始执行外部的副作用函数时，先把 `activeEffect` 指向外部函数，然后进入内部的副作用函数，此时 `activeEffect` 指向内部的函数，当内部的函数执行完后。运行到 `console.log('out effect', data foo)` 时，`track` 开始收集依赖，但此时的 `activeEffect` 指向的是内部的副作用函数，因此将 `data.foo` 与内部的副作用函数发生了绑定。导致 `data.foo` 本应该与外部副作用函数进行关联的预期没有实现，也就导致了上面的运行结果。\n\n### 嵌套问题的解决\n\n对于嵌套的副作用函数导致外层函数丢失的问题，可以通过栈来解决。修改 `effect` 函数，每当开始执行副作用函数时，把当前的副作用函数入栈，并把 `activeEffect` 标记为当前函数。执行完毕后，把栈顶副作用函数出栈，并把 `activeEffect` 指回栈顶的副作用函数 (如果有的话)。\n\n```js\nconst effectStack = []\n\nfunction effect(fn) {\n  const effectFn = () => {\n    cleanup(effectFn)\n    activeEffect = effectFn\n    effectStack.push(effectFn)  // 入栈，防止执行 fn 时使 effectFn 丢失\n    fn()\n    effectStack.pop()  // 执行完毕，出栈\n    activeEffect = effectStack[effectStack.length - 1]  // 将 activeEffect 指回栈顶\n  } \n  effectFn.depSets = []  // 保存相关的集合 \n  effectFn()\n}\n```\n\n经过如此修改后，在执行外部副作用函数时会把当前副作用函数入栈，进入内部副作用函数时虽然会把 `activeEffect` 指向内部副作用函数，但当它执行完毕后，会将 `activeEffect` 指回栈顶的外部副作用函数。因此可以实现正确的关联。\n\n这里可能会有疑问，对栈的更符合直觉的使用应该是在 `effectFn` 中将其入栈，然后在消费它的地方 (`track` 方法处) 直接出栈使用即可。为什么全部放在 `effectFn` 里手动管理呢？这是因为，一个 `effectFn` 里可能涉及多个响应式变量及属性，会触发多次 `track`，在 `track` 里多次弹出使用会导致绑定错误的副作用函数，以及栈的下溢。\n\n## 无限递归问题\n\n### 无限递归问题的描述\n\n考虑这样一个场景，我们可能会在副作用函数中先读取某个响应式变量的值，然后又改变它的值。例如下面的代码，当执行 `data.cnt++` (即 `data.cnt = data.cnt + 1`) 时，首先读取 `data.cnt` 触发 `track` 将该函数与 `data.cnt` 进行关联。然后为 `data.cnt` 设置新值时，又会触发该副作用函数，继续执行 `data.cnt++`。导致以上过程无限递归执行。\n\n```js\nconst data = reactive({\n  cnt: 0\n})\n\neffect(() => {\n  console.log(data.cnt++)\n})\n```\n\n再考虑下面的场景同样是在副作用函数中既读值又赋值，为什么不会发生无限递归？\n\n```js\nconst data = reactive({\n  cnt: 0\n})\n\neffect(() => {\n  data.cnt = 0\n  console.log(data.cnt)\n})\n```\n\n这个例子不同的是先赋值后取值。由于副作用函数执行前会先调用 `cleanup` 清除所有关联，所以当赋值 `data.cnt` 还没有把副作用函数关联起来，因此不会无限递归。\n\n### 无限递归问题的解决\n\n对于上面无限递归的例子，其本质是当响应式数据发生变化时，我们希望能够通过某种方法通知所有与之相关的函数，让它们重新执行以达到更新状态的目的。但是我们**不需要通知使得数据发生变化的函数本身**，因为函数本身能够获得到此时数据的变化。因此解决方法就很明确了，那就是在 `trigger` 中不要去“通知” `activeEffect` 自身。\n\n```js\nfunction trigger(target, value) {\n  // ...\n  const depsToRun = new Set(deps)\n  //  depsToRun.forEach(fn => fn())\n  depsToRun.forEach(fn => {\n    if (fn !== activeEffect) fn()\n  })\n}\n```\n\n其实这里还有一个小问题，那就是如何保证全局变量 `activeEffect` 指向的是触发 `trigger` 的副作用函数本身？其实并不能保证，因为大多数情况下在 `trigger` 中 `activeEffect` 都是 `undefined`。但是只要能保证在可能发生无限递归的情况下，`activeEffect` 指向的是触发 `trigger` 的副作用本身即可。而这一点是显然可以保证的。\n\n## 代码和测试\n\n经过对以上三个问题的分析和解决，最终版本的代码如下：\n\n```js\nlet activeEffect;\nconst effectStack = [];\nconst bucket = new WeakMap();\n\nfunction reactive(obj) {\n  return new Proxy(obj, {\n    get(target, key) {\n      track(target, key); // 搜集依赖函数\n      return Reflect.get(target, key);\n    },\n    set(target, key, value) {\n      const res = Reflect.set(target, key, value);\n      trigger(target, key); // 触发关联的依赖函数\n      return res;\n    }\n  });\n}\n\nfunction track(target, key) {\n  if (!activeEffect) return;\n  let depsMap = bucket.get(target);\n  if (!depsMap) {\n    bucket.set(target, (depsMap = new Map()));\n  }\n  let deps = depsMap.get(key);\n  if (!deps) {\n    depsMap.set(key, (deps = new Set()));\n  }\n  deps.add(activeEffect);\n  activeEffect.depSets.push(deps); // 记录相关的集合\n}\n\nfunction trigger(target, key) {\n  let depsMap = bucket.get(target);\n  if (!depsMap) return;\n  let deps = depsMap.get(key);\n  if (!deps) return;\n  const depsToRun = new Set(deps);\n  //  depsToRun.forEach(fn => fn())\n  depsToRun.forEach((fn) => {\n    if (fn !== activeEffect) fn();\n  });\n}\n\nfunction effect(fn) {\n  const effectFn = () => {\n    cleanup(effectFn);\n    activeEffect = effectFn;\n    effectStack.push(effectFn); // 入栈，防止执行 fn 时使 effectFn 丢失\n    fn();\n    effectStack.pop(); // 执行完毕，出栈\n    activeEffect = effectStack[effectStack.length - 1]; // 将 activeEffect 指回栈顶\n  };\n  effectFn.depSets = []; // 保存相关的集合\n  effectFn();\n}\n\nfunction cleanup(effectFn) {\n  effectFn.depSets.forEach((deps) => {\n    deps.delete(effectFn);\n  });\n  effectFn.depSets.length = 0; // 清理完毕，数组置空\n}\n```\n\n点击[这里](https://codepen.io/Hozen/pen/rNoYLqZ)在线运行和测试。\n\n## 小结\n\n至此就基本上实现了一个比较完整的响应式系统，其实在使用 Vue 的过程中我们几乎不会去调用 `effect` 方法，我们只是声明响应式变量，并把它应用到模板中。Vue 会解析模板来通过 `effect` 绑定数据与渲染函数。\n\n下一章将介绍如何在已有的响应式系统上实现 `computed` 方法。\n\n另外，对于第二个问题[嵌套的副作用函数](#嵌套的副作用函数)，仍然有一个问题。那就是由于内部的副作用函数是由闭包创建的，在依赖集合中无法去重。这样导致每次执行一次外部函数都会创建一个新的内部副作用函数并将其与依赖的变量绑定。当该变量更新时，会把所有绑定的副作用函数都执行一遍，虽然它们的效果是一样的。\n\n## *参考资料*\n\n[1] vuejs/core: 🖖 Vue.js is a progressive, incrementally-adoptable JavaScript framework for building UI on the web.[EB/OL]. [2023-09-22]. <https://github.com/vuejs/core>.\n\n[2] Vue.js - 渐进式 JavaScript 框架 | Vue.js[EB/OL]. [2023-09-22]. <https://cn.vuejs.org/>.\n\n[3] 霍春阳. Vue.js设计与实现[M/OL]. 人民邮电出版社, 2022[2023-09-19]. <https://book.douban.com/subject/35768338/>.\n\n[4] JavaScript | MDN[EB/OL]. [2023-04-10](2023-09-22). <https://developer.mozilla.org/zh-CN/docs/Web/JavaScript>.\n","tags":["响应式","Vue"],"categories":["developer"]},{"title":"Vue3 响应式(1)-基础原理","url":"/archives/72/","content":"\nVue 之所以能够实现声明式的 UI，是因为 Vue 通过响应式将数据和 UI 进行了绑定，当数据发生变化时 Vue 会自动调用相应的函数来重新渲染受到影响的 UI。本系列文章就来简单分析下 Vue 响应式系统的实现。本文先从响应式的基础原理开始，实现一个简单的响应式系统。\n\n<!--more-->\n\n## 系统设计\n\n### 设计目标\n\n我们希望实现这样的系统：能够将某些变量包装成响应式的变量，当该变量的值发生变化时，依赖于该变量的函数能够重新执行以达到刷新状态的目的，例如重新渲染 UI。\n\n具体地，我们需要实现以下函数：\n\n* `reactive()`: 包装响应式变量\n* `effect()`: 包装能够响应数据变化的副作用函数，使其能够在所涉及的响应式变量发生变化时重新执行\n\n例如，对于以下代码，首先使用 `reactive()` 方法将 `obj` 包装成响应式对象，然后使用 `effect()` 方法包装渲染页面文字内容的函数 `fn`，使得当 `data.text` 发生变化时，能够自动调用 `fn` 来更新页面的文字内容。\n\n```js\nconst obj = {\n  text: 'Hi'\n}\nconst data = reactive(obj)\n\nfunction fn() {\n  document.body.innerText = data.text\n}\n\neffect(fn)\n\nsetTiemout(() => {\n  data.text = 'Hello World'\n}, 2000)\n```\n\n### 技术原理\n\n对于以上的设计目标，我们可以通过 `Proxy` 对象来实现。整体的思路是这样：\n\n* 当调用 `reactive(obj)` 时，返回一个对原始数据 `obj` 的代理 `data`。并拦截它的 `get` 和 `set` 操作。\n* 在拦截 `get` 时，记录读取该属性的函数，例如 `fn` 中读取了 `data.text`，则将 `fn` 函数收集起来\n* 在拦截 `set` 操作时，将上一步收集起来的函数重新执行\n* `effect` 方法则用来处理对副作用函数 `fn` 的标记管理\n\n简而言之，对于响应式数据，当读取某个属性时收集依赖于该属性的副作用函数，当修改该属性的值时把之前收集的副作用函数重新执行。\n\n## 编码实现\n\n### `reactive`\n\n首先实现 `reactive` 方法:\n\n```js\nfunction reactive(obj) {\n  return new Proxy(obj, {\n    get(target, key) {\n      track(target, key)  // 收集依赖函数\n      return Reflect.get(target, key)\n    },\n    set(target, key, value) {\n      const res = Reflect.set(target, key, value)\n      trigger(target, key)  // 触发关联的依赖函数\n      return res\n    }\n  })\n}\n```\n\n下面实现追踪和触发方法 `tarck` 和 `trigger`。注意这两个方法里使用到了全局变量 `activeEffect` 和 `bucket`，其中\n\n* `activeEffect` 是用来标记当前由哪个副作用函数读取了响应式变量，它在 `effect` 方法里被设置\n* `bucket` 是一个哈希结构，用来关联响应式变量和与之相关的副作用函数\n\n```js\nlet activeEffect\nconst bucket = new WeakMap()\n\nfunction track(target, key) {\n  if (!activeEffect) return\n  let depsMap = bucket.get(target)\n  if (!depsMap) {\n    bucket.set(target, (depsMap = new Map()))\n  }\n  let deps = depsMap.get(key)\n  if (!deps) {\n    depsMap.set(key, (deps = new Set()))\n  }\n  deps.add(activeEffect)  // 将读取该属性的副作用函数收集到对应的集合中\n}\n\nfunction trigger(target, key) {\n  let depsMap = bucket.get(target)\n  if (!depsMap) return \n  let deps = depsMap.get(key)\n  if (!deps) return \n  deps.forEach(fn => fn())  // 把与之关联的副作用函数依次执行\n}\n```\n\n### `effect`\n\n如上文所述 `effect()` 方法主要用来设置 `activeEffect`:\n\n```js\nfunction effect(fn) {\n  activeEffect = fn\n  fn()  // 立即调用副作用函数来设置初始值并收集依赖\n}\n```\n\n注意到这里 `bucket` 使用了 `WeakMap` 数据结构主要是从性能出发考虑的，参考[WeakMap](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap)。\n\n### 测试和小结\n\n使用[设计目标](#设计目标)一节中代码进行测试可以发现，2 秒后页面的文本会自动更新。\n\n<p class=\"codepen\" data-height=\"300\" data-default-tab=\"js,result\" data-slug-hash=\"KKbyddW\" data-user=\"Hozen\" style=\"height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;\">\n  <span>See the Pen <a href=\"https://codepen.io/Hozen/pen/KKbyddW\">\n  v1_basic</a> by Hozen (<a href=\"https://codepen.io/Hozen\">@Hozen</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.</span>\n</p>\n<script async src=\"https://cpwebassets.codepen.io/assets/embed/ei.js\"></script>\n\n由于 Proxy 的拦截是同步进行的，所以代码的执行过程很容易最终和分析，具体如下：\n\n1. 首先包装响应式对象，对数据的读取和设置进行拦截。\n2. 在 `effect` 函数包装的副作用函数中，由于读取了 `data.text`，并设置了 `activeEffect`。被代理对象 `data` 的 `get` 所拦截。将当前副作用函数收集到了集合 `bucket[data].text` 中。\n3. 当 2 秒后执行 `data.text = 'Hello World'` 时，被 `set` 拦截触发 `trigger`，将 `bucket[data].text` 集合中所有的副作用函数依次执行。页面的文本被更新。\n\n## *参考资料*\n\n[1] vuejs/core: 🖖 Vue.js is a progressive, incrementally-adoptable JavaScript framework for building UI on the web.[EB/OL]. [2023-09-22]. <https://github.com/vuejs/core>.\n\n[2] Vue.js - 渐进式 JavaScript 框架 | Vue.js[EB/OL]. [2023-09-22]. <https://cn.vuejs.org/>.\n\n[3] 霍春阳. Vue.js设计与实现[M/OL]. 人民邮电出版社, 2022[2023-09-19]. <https://book.douban.com/subject/35768338/>.\n\n[4] JavaScript | MDN[EB/OL]. [2023-04-10](2023-09-22). <https://developer.mozilla.org/zh-CN/docs/Web/JavaScript>.\n","tags":["响应式","Vue"],"categories":["developer"]},{"title":"平凡的世界","url":"/archives/71/","content":"\n我第一次读平凡的世界是在多年前的暑期兼职。当时在一个城中村做辅导班的数学老师，寄宿在舅舅家。每天六点钟从小城的一头骑到另一头，然后开始一整天忙碌的工作。一共六个班，每个班上一节数学课，一整天难得歇息。<!--more-->午休时间几位离家远的老师轮岗照看没回家的孩子，是难得的休息机会。“办公室”里有一张床，一般留给女老师歇息。破旧的床头桌抽屉梗塞得要命，好容易拉开后一本厚厚的已没有封面的书胡乱躺在里面。坐在木质的沙发上难以入睡，便翻看起来。纸张是发黄的半透明薄纸，文字被缩印的极小，显然这是一本是上了岁数的盗版书籍。扉页朴素但还完整，《平凡的世界》——路遥著。\n\n从那以后的午休时间，无论是执勤还是休息我都会把那本书拿出来读。厚厚的一本，直到暑期兼职结束也没有完全读完。小说的情节现在已记不太清楚，当时只是默默的读，百万字的鸿篇丝毫不觉得厌烦。那些文字像水一样脉脉流入我的身体。当时的我对人生、对爱情有太多的迷茫与无措，我不知道自己要成为什么样的人，甚至不知道自己是什么样的人，不知道如何面对那些让我辗转难眠的人和事。我看不到自己。书里主人公们的一生在我眼前一一展开、绽放、然后消逝，我仿佛终于拥有了可以看到自己的第三只眼睛。我的单纯、愚蠢、赤诚、幼稚、坚韧、固执都如小说里的人物一般在这只眼睛下一览无余。我觉得有些东西开始慢慢发生变化。\n\n暑假班的最后一天，每个孩子们脸上都洋溢着喜悦，仿佛补习班结束后他们就再也不用读书、不用上学，不用干任何他们不喜欢的事了。那本没看完的《平凡的世界》我又放回了旧书桌的抽屉里。我记起那个夏天下了很多雨，我淋湿在许多下班回家的路上。\n\n![多雨的夏季](/assets/images/71-1.jpg)\n","tags":["散文","随笔"],"categories":["life"]},{"title":"Vue3+Typescript 开发一个图片拼接 PWA","url":"/archives/69/","content":"\n一个简单的长图拼接工具，主要应用了 Vue3 技术栈和 HTML5 的 Canvas 技术。最后包装成 PWA，可以从手机桌面直接访问。本文做一个项目回顾和总结，源码和地址附下：\n\n线上地址: [picStitch](https://ps.hozen.site/)  \n源码: [hooozen/picStitch](https://github.com/hooozen/picStitch)  \n\n<!--more-->\n\n## 技术总结\n\n主要涉及的技术：\n\n* 面向对象技术\n* Vue3 + Typescript 组合式 API\n* Vue-router@4 和 pinia 状态管理\n* Vite 构建和 PWA 包装\n* HTML5 Canvas API 和 Drag API\n* 移动端触摸事件适配\n* Vue3 深层组件封装\n\n### 面向对象开发\n\n无论是主动还是被迫，随着业务逻辑变得复杂，开发者必然要引入面向对象技术。对于这个项目，采用面向对象技术主要有两个原因：\n\n从主观方面来讲，我想把这个项目做成 Web 和小程序多端应用，于是把一些图片裁剪、绘制的核心代码封装成公共基础类。这样可以方便地实现复用和维护，为后面多端的开发和维护节省大量精力。\n\n客观方面，这个项目涉及了图片预览和图片编辑两块画布。两块画布在图片绘制方面有共同的逻辑，同时又分别承担保存和编辑等不同的职责。最重要的是，在两块画布之间要做状态的复制和同步：当从预览画布到编辑画布时，需要把预览画布的图片状态复制到编辑画布。当编辑画布编辑成功时，要把编辑画布的状态同步回预览画布。为了避免性能问题，两块画布要共用图片对象，也就是两块画布仅保存图片的裁剪信息，这样可以极大地节约内存。示意图如下：\n\n![两块画布与图片之间的关联](/assets/images/69-1.jpg)\n\n在对业务逻辑反复梳理后，以及开发过程中的反复实验，最终封装了以下几个基础的类([源码](https://github.com/hooozen/picStitch/tree/main/src/class/base))：\n\n* `ImageClipView`: 图像的裁剪视图，用来保存图片的裁剪状态，并对外提供裁剪方法\n* `ImageCavnasView`: 图像的绘制视图，用来保存图片在画布上的绘制状态\n* `PicStitchCavnas`: 项目的 Canvas 基类，封装了 HTML5 Canvas 的绘制、刷新和保存等方法，以及一些抽像接口.\n* `FlexCanvas`: 弹性画布类. 因为预览图片时画布的高度以及图片的缩放比例要根据所有图片动态计算，因此封装成类.\n* `JointCanva`: “连接”画布类. 用于编辑图片的连接处，主要封装了对画布上图片进行裁剪的方法.\n* `ImageClipViewManager`: 图像管理类. 单例模式，通过管理图片对象来生成视图，以及实现视图的复制和状态同步.\n\n经过以上封装后，对于同一个 Image 对象，可以通过生成多个 `ImageClipView` 来保存对图片的不同裁剪状态。然后在画布和 `ImageClipView` 之间封装一层 `ImageCanvasView` 来提供对裁剪后图片的绘制缩放以及绘制坐标等方法和属性，便于图片的绘制。而 `ImageClipViewManager` 类使用单例模式，对所有的 `ImageClipView` 进行管理，可以复制指定的视图使其能将一个画布的图片转移到另一个画布上。这样 `FlexCanvas` 和 `JointCanvas` 只需要管绘制和编辑的责任，而不需要关系画布间的通信。\n\n以上类的封装主要遵循了单一职责原则，在我看来这是面向对象最重要的原则。单一原则使得类的扩展和使用变得十分简单清晰.\n\n最后，**写 JS 的面向对象一定要用 Typescript**，这将节约大量宝贵时间。\n\n### Vue3 技术栈\n\n我个人对各种技术栈的态度是很冷静的，我认为“Vue 和 React 以及其他个各种技术栈的区别不会大于警犬和猎狗之间的区别”。所以对于这些前端库我只是看作一种时兴的工具，用到的时候去翻阅文档或者源码即可。我觉得对于前端开发者来说原生 JavaScript 以及编程思想和经典模式才是最重要的。因此对此就不过多介绍了。\n\n尝试下来，Vite + Vue3 + pinia 确实是一套特别省力和轻量的生产力工具，尤其是引入 TypeScript 和组合式 API 后，可以抛弃之前 Vue2 时代很多复杂的概念。例如 pinia 实现的状态管理几乎可以不使用 `action` 和 `getter` 就可以实现绝大部分业务逻辑，对于小型项目来说要比 Vuex “人性化”得多。Vite 的构建速度和配置速度也要甩 webpack 好几道街。\n\n总的来说，Vite + Vue3 是一套离“开箱即用”又近了一大步的前端技术栈，非常推荐。\n\n### 利用 Vue 底层 API 封装组件\n\n大家一定用过 ElementUI 的 Message 组件和 Notify 等组件。这些组件和常见的 Vue 组件有个不同点是它们可以通过方法调用，而不用将组件写在模板了。并且像 Message 组件是直接插入到 `body` 上关闭后又会从 `body` 终移除的。同时可以多次调用一次产生多个 Message 弹出。如下图所示：\n\n![element 的 Message 组件可以通过方法调用产生多个实例](/assets/images/69-3.gif)\n\n![Message 用后即毁，不会造成性能问题](/assets/images/69-4.gif)\n\n由于项目中我也要用到类似的组件，于是我参照 Element-plush Message 的源码自己封装了两个类似的组件 ([源码](https://github.com/hooozen/picStitch/tree/main/src/components/Tip))。主要的有以下细节和技巧需要注意：\n\n* 通过 `index.ts` 导出的方法调用后生成一个 `Tip` 实例，在生产实例时创建 `VNode` 并渲染。同时返回实例的关闭方法。\n* 创建实例利用 Vue 的 `createVNode` 和 `render` 方法来生成和渲染\n\n  ```ts\n  import { createVNode, render } from 'vue'\n  import TipConstructor from 'Tip.vue'\n\n  const container = document.createElement(\"div\");\n  ...\n  const createTip = ({ ...options }, context?: AppContext | null) => {\n    ...\n    const vnode = createVNode(TipConstructor, props);\n    vnode.appContext = context || tip._context;\n    render(vnode, container);\n    document.body.appendChild(container.firstElementChild!);\n    ...\n  }\n  ```\n\n* `createVNode(TipConstructor, props)` 方法中的 `props` 参数包含了属性和事件，其中方法是以 `onMethodName` 方式命名的。例如，如果 `props` 中包含了 `onClose(){}` 方法，意味着在 Tip 组件中可以触发 `emit('close')` 事件。这一点官方文档中没有介绍，但对组件的销毁非常 重要。\n\n* 组件的销毁通过 `render(null, ...)` 来实现：\n\n  ```ts\n  render(null, container); // container 与渲染 vnode 时传入的相同\n  ```\n\n* 对 Message 实例的管理，来实现弹出的位置有正确的偏移，以及限制 Message 实例的最大数量\n\n以上仅作为一个简单笔记和提示，想要完整说明 Message 的实现思路恐怕需要一篇文章的篇幅或者阅读 element 的源码。\n\n### PWA\n\n虽然经过这么多年的发展，PWA 仍旧不温不火，尤其在国内已经被各种“小程序”掩没，但不妨碍我仍觉得 PWA 是一个非常优秀的构想和伟大的尝试。在 Vite 下只需要一个插件，就可以将 Web 应用包装成 PWA：[Vite PWA](https://vite-pwa-org.netlify.app/)\n\n### 图片拖动\n\n![在 Web 端实现图片的拖动以及自适应布局并不如想象中简单](/assets/images/69-2.gif)\n\n图片的拖动排序看似是一个简单的功能，其实里面有很多细节和难点。尤其是 Web 端需要对不同窗口大小做自适应，就显得更加复杂了。简单介绍下我踩的坑以及最终的解决方案：\n\n首先是 HTML5 的 Drag 事件❌。Drag 事件最大的问题就在于拖动时，元素本身是不移动的，而只是一个半透明的元素投影跟随鼠标移动。其实这有没有什么大问题，但是如果想实现流畅和优美的动画效果，就需要各种 track。因此反而不如使用鼠标事件更方便。(但本 App 还是利用了 Drag 事件实现了文件的拖拽上传)\n\n其次是使用 Flex 定位来布局元素的初始定位，当元素排序变化时使用 `Translate` 来移动元素的位置❌。这样做的最大问题是，当移除某个元素时，元素在文档流中的初始位置会发生变化。这就意味着还要实时跟踪元素的在文档流中的位置变化，然后使用不同的参数去计算各个元素的 `Translate`，非常复杂。但这个方法也有好处，那就是窗口 resize 时元素会自动确定合适的位置，但前提是得解决好前面提到的问题。\n\n直接改变 DOM 节点的真实位置❓。这个方案我根本没有尝试。因为在拖动过程中，划过元素时许多元素的位置都要更新，虽然有 Vue 的虚拟节点算法，但我仍然觉得这是对性能的浪费。更重要的是直接改变 DOM 节点的位置意味着将无法使用过渡动画！不能接受！\n\n我最后采用了【绝对定位+鼠标事件+Translate】位移的方案，大体的思路如下：\n\n首先通过外层元素的大小来划分格子。然后让所有的图片都 absolute 定位在外层元素的左上角，然后根据它们的顺序计算应该偏移的位置。这样做的好处是，所有的图片计算偏移量的算法都一样，也不会随着图片数量的变化而变化。同时能够兼顾使用各种过渡动画。\n\n当然如何计算拖动过程中的元素位置，以及所处的格子和各个元素的顺序变化也需要仔细的考虑，但归根结底是一个数学问题，就不介绍了。\n\n虽然最终比较好的解决了这个问题，但我觉得拖动元素作为一个很常用的需求，仍需要开发者花费这么大的精力和代码逻辑进行开发非常不合理，浏览器应该封装更加易用的 API。不知道大家在解决此类需求时采用了什么方案，我非常好奇。\n\n### 移动端触摸事件\n\n移动端的触摸事件并不兼容鼠标事件！并且有很多反常的行为，例如 `touchmove` 事件并不像 `mousemove` 事件可以获得所处的元素，因为其 `target` 永远指向初始点击的元素。并且像鼠标事件的 `offsetX` 等属性在触摸事件上也是**没有**的。另外移动端的触摸事件还容易触发浏览器的返回和刷新等手势，非常难受。\n\n总之，如果你之前没有进行过移动端触摸事件的适配，那么一定为它预留好足够的时间来查阅文档和 StackOverflow。\n\n### Canvas 和 SVG\n\n项目中用到的图片包括我自己设计的 LOGO 全都使用了 SVG 技术，这是一个很优雅的图片解决方案。并且 SVG 还可以通过 base64 编码嵌入到 CSS 作为 `background-url`。\n\nCanvas 用来处理图片非常方便，要注意保存图片的一些方法。例如 `canvas.toBlob` 和 `canvas.toDataURL` 方法的对比。\n\n## 其他\n\n一定要事先进行 UI 和交互设计，否则可能写着写着发现一些功能在当前的 UI 下很难实现，或者操作逻辑非常奇怪。而避免出现这种问题的最好的方法就是参考类似功能的 APP，很明显我这款 APP 的 UI 很大部分借鉴了微信，而交互逻辑借鉴了[App Store 上的“PicTailor” (apple.com)](https://apps.apple.com/cn/app/id1589654548)，如果这款软件有安卓版我也不会开发这个小工具了。\n","tags":["个人项目"],"categories":["developer"]},{"title":"Web性能优化——网络篇","url":"/archives/68/","content":"\nWeb 性能优化是一个复杂的问题，往往涉及从需求到维护的软件工程的各个方面。并且根据具体业务的不同也会采取不尽相同的针对性措施。本文主要针对 Web 网络性能，从问题产生的原因以及对应的一些优化措施，对 Web 的性能优化做一些简单的总结和思考。\n\n<!--more-->\n\n## 1. Web 网络性能分析\n\n随着计算机性能的提升和现代浏览器的不断进步，客户端的性能完全能够胜任普通的 Web 页面甚至是复杂的 Web 应用和具有炫酷特效的 Web 游戏。客户端性能对于绝大多数 Web 开发者来说不再是性能优化的瓶颈。Web 性能优化的焦点来到计算机网络的传输能力。但随着家庭用户的网络带宽和通信质量不断提升，入户带宽能达到数百兆甚至上千兆，这对于通常只有数兆大小的 Web 页面资源来说是完全足够的。似乎一切有关 Web 性能的软硬件环境看起来都很美好，那么 Web 性能的瓶颈出现在哪呢？\n\n答案是**网络延迟**。网络延迟之所以成为影响 Web 性能的重要因素，有很多方面的原因，下面结合我个人的知识和经验简单分析。\n\n### 1.1. 信号传输时延\n\n网络信号传输的延迟受很多因素影响，包括\n\n* 信号在链路中的传播速度\n* 消息长度和链路速率 (带宽)\n* 网络设备对网络信号的处理能力\n* 以及网络拥塞造成的排队时间等\n\n即使抛开其他因素，只考虑信号在链路中的传播速度也会发现这是一个不容忽视的数值 (见下表)。并且根据现有的物理学理论，信号传播速度无法突破光速上限，所以信号传播的时延已经很难得到像客户端性能和网络带宽那样大幅的提升了。\n\n| 路线 | 距离(km) | 时间: 光在真空中 | 时间: 光在光纤中 | RTT(Roud-Trip Time) |\n| - | - | - | - | - |\n|纽约到旧金山|4148|14ms|21ms|42ms|\n|纽约到伦敦|5585|19ms|28ms|56ms|\n|纽约到悉尼|15993|53ms|80ms|160ms|\n\n上表摘自《Web 性能权威指南》[<sup>[2]</sup>](#ref2)，列举了理想情况下光纤信号在全球一些城市之间的传播延迟，可以发现当距离较远时光纤的 RTT 会达到较高的数值。\n\n### 1.2. 传输协议的握手机制\n\n由于 HTTP 最初是基于 TCP 实现的，所以在建立 HTTP 连接前不可避免地要先进行 TCP 的三次握手。并且目前安全传输又成了很多 Web 应用的必要需求，HTTPS 几乎成为 Web 页面的“标配”。因此 TLS 等安全传输协议的握手机制也要在正式建立 HTTP 通信之前进行。这就导致了在数据正式开始传输之前至少要经历 2 至 3 个 RTT 才能开始。也就是说即使不考虑数据传输所需要的时间，单是准备工作就要消耗上百毫秒的时间。\n\n![TLS 1.0 握手流程，至少消耗 3 个 RTT](/assets/images/68-1.jpg)\n\n### 1.3. 网络资源请求的串行\n\n由于 Web 应用越来越复杂，一个页面往往伴随着十数个甚至数十上百个资源请求。如果这些请求串行执行，那么再大的网络带宽也得不到有效利用，网络延迟造成的资源加载时间被成倍扩大。等到几十个资源的依次加载完成时用户早已失去了耐心。\n\n不过好消息是，现代浏览器会对页面进行资源预扫描，然后并行地对网络资源进行请求和加载。但坏消息是，为了避免服务器因接接受过多的 TCP 请求而不堪重负，各浏览器都会对同一个域名发起的 TCP 请求数进行限制，一般是 6 个左右。这就意味当页面中需要的资源请求太多时，很多请求还是不可避免地要串行执行。\n\n### 1.4. 移动网络的不稳定性\n\n随着移动设备的大规模普及和应用，移动网络环境成为开发者不得不考虑的因素。移动网络相较有线网络，不仅网络延迟更高、带宽更低，更致命的是移动网络的不稳定性会导致 TCP 连接的丢包甚至中断。而 TCP 连接一旦出现问题就会触发拥塞避免机制降低网络传输的速率，甚至重新执行握手算法！这对于本就不快的移动网络来说更是雪上加霜。而移动设备用户因为有更丰富的 APP 可以使用，可能对 Web 应用的包容度更低，这就意味着缓慢的加载速度将极大地摧毁用户的好感。\n\n## 2. 网络性能的优化方法\n\n以上对影响网络性能的因素进行了分析。可以发现核心就在于网络信号传播的时延无法避免，而其他因素如多资源的串行请求、协议的握手算法、移动网络的不稳定等因素又加剧了网络的延迟。那么解决方自然也要从这些因素入手。\n\n### 2.1. 升级服务端的 HTTP 协议\n\n如果只能选一个优化 Web 网络性能的方法我一定会选择把服务端的 HTTP 协议升级至 HTTP/3。因为从 HTTP/2 开始就引入了数据分帧的技术，在建立一个连接的基础上能实现对数据进行并行请求。同时还进行了一系列的性能优化。而 HTTP/3 更是使用 UDP 重写了 HTTP，从根本上避免了很多由于 TCP 握手以及拥塞控制等机制导致的延迟。并且更重要的是从开发者的角度来看，这几乎是一个零成本的举措，由于 HTTP/3 的兼容性客户端和服务端几乎不需要对原有的软件进行任何修改 (当然要升级服务端的 web server)。现代浏览器也对 HTTP/2 和 HTTP/3 有了很好的支持。\n\n下表是截止到该文章发表我的主页 [hozen.site](https://www.hozen.site) 7 天内的访问请求的客户端 HTTP 版本统计。从统计结果可以看出，HTTP/2 和 HTTP/3 的访问占比已经高达三分之二，并且我估计其中真实用户的 HTTP/2 和 HTTP/3 的占比会更高。因为应该有很多网络爬虫使用了低版本的 HTTP 协议。\n\n| 版本 | 请求 | 请求百分比|\n| - | -| -|\n|HTTP/2|8,045|49.72%|\n|HTTP/1.1| 5,344 |33.03%|\n|HTTP/3 |2,767 |17.1%|\n|HTTP/1.0| 23| 0.1%\n\n当然由于用户群体的不同 HTTP 协议版本的分布会有差别，但毫无疑问的是客户端使用高版本 HTTP 的占比会不断的提高。所以低成本带来的高性能提升使得所以 HTTP/3 非常值得尝试。\n\n### 2.2. 使用 CDN\n\n在 1.1 节中的表格可以看出，信号传播的时延与距离成正比。若服务器离客户端非常远，那么信号传播时延无疑会非常高。而 Contente Delivery Network 正是为了解决此问题而生的。CDN 将就近为用户分配资源服务器，以缩短由于距离造成的传播时延过长。并且 CDN 已经有非常成熟的技术和提供商，唯一的问题可能就是需要支付一定的费用。\n\n### 2.3. 提高网络资源的并行效率\n\n由于浏览器对于同一个域名下的并行请求数量有限制，那么当网络资源过多时可以将它们分别放置在不同的域名下，这样浏览器就会为该页面使用更多的并行连接。\n\n另一方面，对于一些体积很小但数量很多的资源，例如图标文件。要想办法将这些资源整合起来减少资源的数量。因为无论网络资源体积的大小有多大，建立连接和**传播**消耗的时间都是相同的常数时间。当资源体积较小时，资源的**传输**时间占据的相对比例就会变得很小，整个网络的利用率就会降低。另一方面这些数量众多的资源还会消耗很多并行请求，使得其他资源的请求不得不进入排队队列。解决该问题的一个常见的例子就是使用“雪碧图”技术拼接一些小体积的图片以减少请求次数。\n\n但还要注意，当某个资源体积过大造成数据的**传输**时间占据过高比重时。那么就需要对该资源进行拆分，以利用浏览器的并行请求加快对该资源的加载。这种思路在单页面应用中比较常见，由于主要的 JS 文件融合许多依赖库导致体积过大，当该文件加载完成前页面可能会面临白屏的风险。所以一些“拆包”插件应运而生。\n\n但是问题是进行拆包或者资源合并这两个看似矛盾的举措之间的分界线在哪里？也就是说当资源文件多小时要整合，又当达到多大时要拆分？很显然这个阈值和用户的网络带宽和网络延迟有关，因此需要对用户群体的网络状况进行统计分析后才有可能得到整体较优的阈值。\n\n**但是**！当你使用了 HTTP/2 或 HTTP/3 之后，你就无需考虑这些问题了。因为 HTTP/2 和 HTTP/3 使用数据分帧技术只需要建立一个连接就可以并行传输资源。甚至以上的方法可能产生负优化的效果，例如将资源放在不同的域名反而会额外增加建立连接的时间。当这里的负优化是相对 HTTP/3 自身来说的，相对与 HTTP/1.1 仍然具有性能的提升。\n\n### 2.4. 服务端渲染和缓存控制\n\n使用服务端渲染的对网络性能提升的好处很明显，那便是减少客户端网络资源请求的次数。但并不是所有的资源都适合服务端渲染，服务端渲染的目的是提高 Web 的响应速度，所以服务端渲染最好用于一些长时间有效的静态资源或者用户共享资源。否则可能会给服务端造成过大的压力，导致资源响应过慢反而降低了页面的加载速度。\n\n缓存是一个老生常谈但却并不简单的问题，网上的材料很多这里不再赘述。\n\n>There are only two hard things in Computer Science: cache invalidation and naming things.  -- Phil Karlton\n\n### 2.5. 合理的组织 HTML\n\n合理的组织 HTML 页面包括:\n\n* 合理放置样式文件和脚本文件的位置\n* 使用 script 标签的 `async` 和 `defer` 属性加快资源加载\n* 尽可能使用 image 标签提前向浏览器暴露资源请求 (而不是使用 `background-images` 属性)\n* 合理使用 base64 编码减少资源请求\n\n等。由于这些方法和 Web 性能优化的其他方面产生重合，本文不再展开。\n\n## 3. 小结\n\n本文对最近对于 Web 网络性能的学习和实践做了一个小的总结，主要的资料和经验来自于《计算机网络》[<sup>[1]</sup>](#ref1)、《Web 性能权威指南》[<sup>[2]</sup>](#ref2)、各大开发者社区及开放文档，以及对个人项目 [hexo-theme-tranquility](https://github.com/hooozen/hexo-theme-tranquility) 的优化实践。正如文章开头所讲 Web 性能是一个复杂但重要的问题，所以难免有所疏漏，恳请读者批评。\n\n----\n*参考资料*\n\n<div id='ref1'></div>\n[1] 谢希仁. 计算机网络[M/OL]. 6 版. 电子工业出版社, 2013[2023-07-09].\n\n<div id='ref2'></div>\n[2] GRIGORIK I. Web性能权威指南[M/OL]. 李松峰, 译. 人民邮电出版社, 2013[2023-07-09].\n\n[3] 等\n","tags":["性能优化","计算机网络"],"categories":["developer"]},{"title":"Hexo 的多主题自动化部署","url":"/archives/67/","content":"\n“对项目进行配置化改造可以提高开发效率，让开发者将精力集中在业务开发中，减少琐碎重复工作对心情的影响。更重要的是，配置化可以减少因人工操作带来的失误，并且利于排查问题。”\n\n<!--more-->\n\n上面正是我在对自己的项目进行改造后的感受。我维护了两个 Hexo 主题项目， [hexo-theme-tranquility](https://github.com/hooozen/hexo-theme-tranquility) 和 [hexo-theme-academic](https://github.com/hooozen/hexo-theme-academic)（未正式发布）。由于两个主题的测试用例重合度非常高，每次新增测试用例都得手动在两个主题上测试，很不方便。并且为了方便用户使用和查看示例，我想构建一个专门的演示网站对两个主题进行展示，并且希望每当我更新测试用的项目时，演示网站的两套主题都会自动更新部署。\n\n于是考虑通过配置化利用一个博客资源同时部署若干主题，并通过 Github Actions 让两个主题更新后都自动部署，方便用户查看更新内容和测试示例。\n\n最终实现的效果是这样的，建立测试项目 [hexo-theme-test](https://github.com/hooozen/hexo-theme-test)。每当该项目进行推送时，自动在网址 [theme.hozen.site/tranquility](https://theme.hozen.site/tranquility) 和 [theme.hozen.site/academic](https://theme.hozen.site/academic) 部署使用了主题 [hexo-theme-tranquility](https://github.com/hooozen/hexo-theme-tranquility) 和 [hexo-theme-academic](https://github.com/hooozen/hexo-theme-academic) 的网站。\n\n简言之，需要解决两个问题，一个就是同一个博客资源部署多个主题，另一个是 Github Actions 的自动部署。下面分别介绍。\n\n## Hexo 多主题部署\n\nHexo 在 `themes/` 目录下可以存放多个主题文件，但只能通过 `_config.yml` 指定一个主题进行部署，并且部署到网站根目录。当修改主题后，之前生成的内容会被覆盖。我希望 `themes/` 目录下的主题都能部署，并且互不影响。\n\n部署多个主题的解决方法很简单，只需要通过更改 `_config.yml` 的配置，修改主题的输出目录，使不同的主题使用不同的子目录即可。例如我要部署【致远】和【academic】两个主题时分别修改 `_config.yml` 的以下部分：\n\n```yml 致远主题\nurl: http://theme.hozen.site/tranquility\npublic_dir: public/tranquility\ntheme: tranquility\n```\n\n```yml academic 主题\nurl: http://theme.hozen.site/academic\npublic_dir: public/academic\ntheme: academic\n```\n\n这样在两个 URL 下就输出了使用不同主题渲染的网站了。\n\n### 配置分离\n\n通过以上方法虽然解决了业务需求，但是由于每次部署主题都得去修改 `_config.yml` 文件。并且万一忘记修改，那么另一个主题网站就会被当前的主题所覆盖，很不方便。因此这里利用 Hexo 的配置融合机制。将两个主题不同的配置项分别放入配置文件: `_build.tranquility.yml` 和 `_build.academic.yml` 中。通用的配置仍然放在 `_config.yml`。\n\n最后编写两个 `scripts` 命令来加载不同的配置文件：\n\n```json package.json\n{\n  \"scritps\": {\n    ...\n    \"build-tranquility\": \"hexo generate --config _config.yml,_build.tranquility.yml\",\n    \"build-academic\": \"hexo generate --config _config.yml,_build.academic.yml\",\n    \"trqlt\": \"hexo server --config _config.yml,_build.tranquility.yml\",\n    \"acdmc\": \"hexo server --config _config.yml,_build.academic.yml\"\n  }\n  ...\n}\n```\n\n这样我们就可以通过执行 `npm run trqlt` 和 `npm run acdmc` 来在本地运行不同的主题，并通过执行 `build-tranquility` 和 `build-academic` 来构建不同的主题了。并且两个主题互不影响，构建后的文件分别放置在 `public/tranquility` 和 `public/academic` 下。\n\n### 使用子模块管理两个主题\n\n需要注意，由于这个博客网站只是为了测试和演示，其使用到的主题都是单独的项目，并且以后可能加入其他主题。所以需要使用 Git 的子模块 submodule 功能来管理模块。具体来说就是在该仓库下将 [hooozen/hexo-theme-tranquility](https://github.com/hooozen/hexo-theme-tranquility) 和 [hooozen/hexo-theme-academic](https://github.com/hooozen/hexo-theme-academic) 两个项目作为子模块分别导入到 `themes/tranquility` 和 `themes/academic` 目录下。这样做的好处是，可以在该仓库下直接对两个项目进行更新和维护，同时又保证了这两个项目的独立性。\n\n有关 Git 子模块的使用方法，可以参考 [Git 子模块 submodule 的使用](https://www.hozen.site/archives/23/)\n\n## 自动部署网站\n\nHexo 官网给出了利用 Github Actions 自动部署网站的[示例](https://hexo.io/zh-cn/docs/github-pages)，但并不能完全满足我的需求，主要有以下几点需要改进：\n\n1. 网页的生成依赖到了第三方软件 [pandoc](https://www.pandoc.org/)，Github Actions 的默认环境中没有该软件\n\n2. 需要部署两个主题网站到子目录下\n\n3. 需要移动 CNAME 文件到根目录\n\n对于第 1 个问题，需要利用 Docker 来解决。第 2 和第 3 个问题增加相应的指令即可。\n\n### 创建 Docker 镜像\n\n创建具备 Node 和 Pandoc 环境的镜像，可以 Node 镜像为基础在其中安装 Pandoc 软件包。由于把项目生成和部署的操作在 Github Actions 中执行，因此 Docker 镜像中并不放入项目代码也不执行任何项目命令，只是创建运行环境。所以 Dockerfile 非常简单，如下：\n\n```Dockerfile\n# 使用一个包含 Node.js 的基础镜像\nFROM node:18\n\n# 设置工作目录\nWORKDIR /app\n\n# 安装 Pandoc\nRUN apt-get update && apt-get install -y pandoc\n```\n\n使用以上 Dockerfile 创建镜像后，将该镜像上传到 [Dockerhub](https://hub.docker.com/) 就能在 Github Actions 中拉取镜像并创建容器了。\n\n### 编写 workflows 配置\n\n准备好镜像后，只需要子啊 Github Actions 中使用该镜像创建容器，并执行相应的项目命令就能构建项目代码了，并使用相关的插件实现网站的自动部署。\n\n首先在项目根目录下创建 `.github/workflows/pages.yml` 文件，然后编写以下内容：\n\n```workflows\nname: Pages\n\non:\n  push:\n    branches:\n      - main # default branch\n\njobs:\n  pages:\n    runs-on: ubuntu-22.04\n    permissions:\n      contents: write\n    container:\n      image: docker://hooozen/node-pandoc:latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n        with:\n          submodules: recursive\n      - name: Cache NPM dependencies\n        uses: actions/cache@v3\n        with:\n          path: node_modules\n          key: ${{ runner.OS }}-npm-cache\n          restore-keys: |\n            ${{ runner.OS }}-npm-cache\n      - name: Install Dependencies\n        run: npm install\n      - name: Build tranquility\n        run: npm run build-tranquility\n      - name: Clean config\n        run: rm -f db.json\n      - name: Build academic\n        run: npm run build-academic\n      - name: Set CNAME\n        run: cp source/CNAME public/CNAME\n      - name: Deploy\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./public\n```\n\n在该配置文件中:\n\n* 使用 `container` 项指定了上文中创建并上传的具备 Node 和 Pandoc 的 Docker 镜像。Github actions 在执行时会使用该镜像创建 Docker 容器，接下的操作都会在该容器中进行。\n\n* 使用 `actions/cache@v3` 检出项目主分支，然后使用 `actions/cache@v3` 缓存 `node_modules` 目录以提高构建速度。\n\n* 接下来执行 `npm install` 安装依赖，然后依次运行 `npm run build-tranduility` 和 `npm run build-academic` 来使用两个不同的主题构建页面。注意两个构建命令之间执行 `rm -f db.json` 来清除 Hexo 的缓存文件。\n\n* 构建完成后，在 `public` 文件夹下会生成两个子目录 `tranquility` 和 `academic` 分别存放了两个主题的页面。\n\n* 由于我使用了自定义域名，因此使用 `mv` 命令将 CNAME 文件移动到 `public` 目录下。\n\n* 最后使用 `peaceiris/actions-gh-pages@v3` 来将 `public` 下所有的文件部署到 gh-pages 分支。\n\n经过以上操作，每当我在 `hexo-theme-test` 项目中推送代码时，Github Actions 都会自动将更新内容使用两个主题分别部署在 [theme.hozen.site/tranquility](https://theme.hozen.site/tranquility) 和 [theme.hozen.site/academic](https://theme.hozen.site/academic) 上。\n\n## 总结\n\n* 对于 Node 项目不同环境和子项目的配置化，可以通过编写 `scripts` 命令和编写 Node 或者 Bash 脚本来读取配置文件实现。\n* Github Actions 是对 Github 仓库进行自动化配置的好工具，有非常强大的功能。\n* Docker 的应用对于跨平台的项目运行和部署非常方便。\n","tags":["Git","Github Pages","配置化","Docker"],"categories":["developer"]},{"title":"数学老师","url":"/archives/70/","content":"\n上学时做暑期兼职，带六个年级的小学数学。从二年级到初一的数学，一天正好上满六节课，不得休息。在城中村中，工资很低，老板是一对上了年纪的夫妇，班级就设在他们的两层楼房里。孩子多来自附近村里，父母托管过来，交个饭钱，不求学到什么，直消能有个地儿管束下孩子，吃顿午饭，不影响自己上班。\n<!--more-->\n\n有的孩子好像爱上我的课，我也爱教他们，我一直以为我教的不错，孩子们会喜欢我。直到后来在“办公室”里和其他老师聊天，才发现孩子们最害怕上数学课，“因为数学老师最严厉”。我竟一直不觉。\n\n暑期班快结束时，七年级语文试卷的作文题目是“我的老师”。有一些失落，全班只有一个孩子写了数学老师。那是一个胖胖的男孩，老板阿姨在午饭时总是调侃他太能吃，让他多交钱，他只嘿嘿笑。他上数学课时反应总是慢别人一拍，做题很慢，班里的女生不喜欢他，甚至恶语相向，说到急处他也会骂回去。有时上课会走神，刚讲过的知识点也答不出，我常罚他站着听课。我没想到选我写进作文的是这个孩子。我看了他的作文，字写得很大，每个都挤出了方格。他说，他最喜欢数学老师，虽然别的同学都觉得数学老师很严厉，但只有数学老师在课堂上当他没弄懂时会等着他。\n","tags":["散文","随笔"],"categories":["life"]},{"title":"读书","url":"/archives/66/","content":"\n身边一些朋友开始读书，我总会半调侃地说，“你有烦恼了，有烦恼的人才会想读书”。读书不是一件轻松的事，甚至枯燥。生来爱读书的人少之又少，我不是。我认识的人里，没有缘由的爱读书的大概屈指可数。这是一种我未有却能感受到的天分。\n<!--more-->\n\n有人说，人到四十岁还不信命那么这个人悟性太差。我二十多岁的年龄便开始信命，确切的说是从不相信到接受。因为有些人是不关心命的，便谈不上信不信。信命不是迷信，想得总可得到才是迷信。夏天出生的虫子，不知冰是什么，这就是他的命。人生来便带着一些特质，这些特质是强求不来也舍弃不掉的。这是一个人的命。我能做的是找到这些特质，找到我的命。\n\n阿城说，每个人都会碰到绝境。我非常赞同，若用更技术性的语句来阐述便是，大概率每个人都会碰到绝境，至少每个人都无法避免地具有碰到绝境的可能。以我的观察，普通人往往在成家立业后才会碰到人生的绝境，大概便是四十岁前后。年轻的，活力的，激扬的，往往未曾感受到过绝境。每个人的绝境不尽相同，但对于没经历过绝境的人，有些事是不可说的。说了便是无趣。\n\n既如此，如何穿越绝境便是人生一个重要的课题。这个方法在心里，如何从心里找出这个方法？有很多途径，但都脱不了孤独。读书是其中之一。\n","tags":["散文","随笔"],"categories":["life"]},{"title":"记住两个函数轻松处理 Go 语言 OJ 输入","url":"/archives/65/","content":"\n处理操作系统的标准输入输出在 Web 项目开发中并不常用，像 [LeetCode](https://leetcode.cn) 一些现代刷题平台也取消了输入输出的处理，让用户专注于算法的实现。但对于传统的 OJ 平台和算法竞赛，往往需要用户从标准输入中读取指定格式的数据，然后使用标准输出返回答案。如果平时没有经验的话，在比赛或笔试时可能会浪费不必要的时间。本文主要介绍 Go 语言的 `fmt.Scan` 和 `Scanner.Scan` 函数来应对常见的 OJ 输入。\n\n<!--more-->\n\n## 两个函数\n\n先考虑常规的 OJ 数据格式：使用空格分隔数据元素，使用换行符分隔不同组数据。\n\n### [`fmt.Scan`](https://pkg.go.dev/fmt@go1.20.2#Scan)\n\n```go\nfunc Scan(a ...any) (n int, err error)\n```\n\n> Scan scans text read from standard input, storing successive space-separated values into successive arguments. Newlines count as space. It returns the number of items successfully scanned. If that is less than the number of arguments, err will report why.\n\n`fmt.Scan` 方法会从标准输入中**连续读入**由空格（**或换行**）分隔的变量到传入的参数。当读入的变量个数小于传入的参数个数时，`err` 会报告错误。也就是说，`Scan` 方法会一直读取变量直至读取完毕所有输入。\n\n根据 `fmt.Scan` 方法的这个特性，可以方便地处理空格对数据的划分，但由于换行也视作空格，导致无法区分数据组。因此使用该方法读入数据时，我们需要**提前知道每组数据的长度**，根据这个长度来对数据组进行划分即可。具体见下面两个例子。\n\n#### 例 1. [两数之和](https://ac.nowcoder.com/acm/contest/5657/A)\n\n```bash 输入描述\n输入包括两个正整数a,b(1 <= a, b <= 1000),输入数据包括多组。\n```\n\n```bash 输出描述\n输出a+b的结果。\n```\n\n**示例**\n\n```bash 输入\n1 5\n10 20\n```\n\n```bash 输出\n6\n30\n```\n\n**解答**\n\n由于每个用例固定有两个数据，只需要两个两个输入读入，然后计算两数之和即可：\n\n```Go 两数之和\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    var a, b int\n    for {\n        _, err := fmt.Scan(&a, &b)  // 两个两个变量读入\n        if err != nil { break }  // 读到末尾结束循环\n        fmt.Println(a + b)\n    }\n}\n```\n\n#### 例 2. [数列之和](https://ac.nowcoder.com/acm/contest/5657/F)\n\n```bash 输入描述\n输入数据有多组, 每行表示一组输入数据。\n每行的第一个整数为整数的个数n(1 <= n <= 100)。\n接下来n个正整数, 即需要求和的每个正整数。\n```\n\n```bash 输出描述\n每组数据输出求和的结果\n```\n\n**示例**\n\n```bash 输入\n4 1 2 3 4\n5 1 2 3 4 5\n```\n\n```bash 输出\n10\n15\n```\n\n**解答**\n\n这一题输入虽然每组的变量数不固定，但通过读入的第一个变量可以预先知道每组的变量数，因此通过循环控制即可对数据正确分组。\n\n```go 数列之和\npackage main\n\nimport (\n    \"fmt\"\n)\n\nfunc main() {\n    var n int\n    for {\n        _, err := fmt.Scan(&n) // 获取该组数据长度\n        if err != nil { break }\n        \n        sum := 0\n        // 通过循环控制每一组的数据读入\n        for i := 0; i < n; i++ {\n            var v int\n            fmt.Scan(&v)\n            sum += v\n        }\n        \n        fmt.Println(sum)\n    }\n}\n```\n\n#### `fmt.Scan` 小结\n\n`fmt.Scan` 方法简单易用，无需提前知道用例的组数，可以一直从标准输入读取由空格以及换行分隔的数据直至结束。但需要能够（从题目规定或输入变量）提前获知**每组数组的长度**。因此当每组数据长度无法提前获知时，该方法使用起来就不方便了。\n\n### [`bufio.Scanner`](https://pkg.go.dev/bufio@go1.20.2#Scanner)\n\n首先查看 [`Scanner`](https://pkg.go.dev/bufio@go1.20.2#Scanner) 的定义：\n\n```go\ntype Scanner struct {\n    // contains filtered or unexported fields\n}\n```\n\n> Scanner provides a convenient interface for reading data such as a file of newline-delimited lines of text. Successive calls to the Scan method will step through the 'tokens' of a file, skipping the bytes between the tokens. The specification of a token is defined by a split function of type SplitFunc; the default split function breaks the input into lines with line termination stripped. Split functions are defined in this package for scanning a file into lines, bytes, UTF-8-encoded runes, and space-delimited words. The client may instead provide a custom split function.  \n\n简言之，Scanner 提供了**每次读入一行输入**的接口。\n\n然后查看 `Scanner` 的 [`Scan`](https://pkg.go.dev/bufio@go1.20.2#Scanner.Scan) 方法\n\n```go\nfunc (s *Scanner) Scan() bool\n```\n\n> Scan advances the Scanner to the next token, which will then be available through the Bytes or Text method. It returns false when the scan stops, either by reaching the end of the input or an error. After Scan returns false, the Err method will return any error that occurred during scanning, except that if it was io.EOF, Err will return nil. Scan panics if the split function returns too many empty tokens without advancing the input. This is a common error mode for scanners.\n\n`Scanner` 的 `Scan` 方法（默认情况下）将 `Scanner` 推进到下一行，读取的该行数据可以被 [`Text`](https://pkg.go.dev/bufio@go1.20.2#Scanner.Text) 方法使用。当扫描结束时，该方法返回 `false`。\n\n其中 `Text` 方法将读取的该行输入转换为字符串返回：\n\n```go\nfunc (s *Scanner) Text() string\n```\n\n> Text returns the most recent token generated by a call to Scan as a newly allocated string holding its bytes.\n\n因此通过使用 `bufio.Scanner` 我们可以逐行读取输入为一个字符串变量，然后通过 `strings.Split` 方法将每行字符串转变为数组便成功读入了一组数据。\n\n`bufio.Scanner` 在具体使用中需要注意一些细节，包括传入标准输入，字符串分隔和类型转换等，具体见下例：\n\n#### 例 4. [数列求和](https://ac.nowcoder.com/acm/contest/5657/G)\n\n```bash 输入描述\n输入数据有多组, 每行表示一组输入数据。\n\n每行不定有n个整数，空格隔开。(1 <= n <= 100)。\n```\n\n```bash 输出描述\n每组数据输出求和的结果\n```\n\n**示例**\n\n```bash 输入\n1 2 3\n4 5\n0 0 0 0 0\n```\n\n```bash 输出\n6\n9\n0\n```\n\n**解答**\n\n该题和例 3 是同一个问题，但缺少对每组数据个数的规定，因此无法使用 `fmt.Scan` 方法读取，需要使用 `bufio.Scanner` 逐行读取数据：\n\n```go 数列之和\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"bufio\"\n    \"strings\"\n    \"strconv\"\n)\n\nfunc main() {\n    scanner := bufio.NewScanner(os.Stdin)\n    \n    for scanner.Scan() {\n        nums := strings.Split(scanner.Text(), \" \")\n        \n        sum := 0\n        for _, x := range nums {\n            v, _ := strconv.Atoi(x)\n            sum += v\n        }\n        fmt.Println(sum)\n    }\n}\n```\n\n## 总结\n\n从上文以及例题中可以发现，`bufio.Scanner` 的应用场景是可以完全覆盖 `fmt.Scan` 的，但前者使用起来需要配合很多其他的库，比较繁琐。因此当每组用例的变量数是可知的情况下优先使用 `fmt.Scan` 方法即可。当 `fmt.Scan` 方法不适用时再考虑使用 `bufio.Scanner`。\n\n另外还有一点需要注意，`fmt.Scan` 只处理空格分隔的变量，因此当输入格式由其他字符分隔变量时，则考虑使用 `bufio.Scanner` 读入后再调用 `strings.Split` 进行相应的分隔即可。\n\n读取 OJ 常见输入的方法有很多，我查阅相关文章后发现上述两种方法最简单方便。如果有其他更好的方法请留言讨论。\n","tags":["Go","OJ","stdio"],"categories":["developer"]},{"title":"前端工程师需要知道的字体知识","url":"/archives/64/","content":"\n随着网页个性化设计和品牌特色的需要，在网页中使用特定的字体将成为越来越常见的需求。现代字体设计经历了数十年的发展，已经积累了成熟的标准和规范，但对于许多前端开发者来说可能可能还比较陌生，本文就前端开发过程中可能遇到的字体知识做一个梳理和介绍。\n\n<!--more-->\n\n## 字体基础\n\n### 字体标准\n\n字体的设计和使用和其他任何工业设计产品一样，需要统一的标准和规范。\n\n最初的计算机字体是点阵字体，放大后会有明显的马赛克。为了高清打印和缩放的需求，Adobe 公司于 1984 年发布了 [PostScript](https://www.adobe.com/cn/products/postscript.html) 语言，使用三次贝塞尔曲线来绘制字体，极大的提高了字体打印和屏幕显示质量[<sup>[1]</sup>](#ref1)。很快苹果又推出了 [TrueType](https://developer.apple.com/fonts/TrueType-Reference-Manual/) 字体标准，采用二次贝塞尔曲线绘制字体，被广泛应用于 macOS 和 Windows 系统中[<sup>[2]</sup>](#ref2)。\n\n1996 年微软联合 Adobe 在 TrueType 的基础上推出了 [OpenType](https://learn.microsoft.com/en-us/typography/opentype/) 字体标准，该标准整合了 PostScript 字体和 TrueType 字体的特点，并新增了许多新的特性。OpenType 陆续得到苹果和谷歌等公司的支持，在主流计算机平台应用广泛，目前已经成为字体设计的主要发展趋势[<sup>[3]</sup>](#ref3)。\n\n总的来说，字体（轮廓字体 [Outline fonts](https://en.wikipedia.org/wiki/Computer_font#Outline_fonts)）标准整体上有 3 种，但对于普通用户和开发者来说 TrueType 和 Opentype 比较常见。\n\n### 字体文件\n\n字体设计完成后将打包成特定文件分发给用户，字体文件根据标准的不同采用不同的后缀名。TrueType 字体以 `.ttf` 作为后缀名。OpenType 字体根据不同的情况采用 `.otf`, `.ttf`, `.otc` 和 `.ttc` 为后缀，其中 OTF 一般表示基于 PostScript 技术，对应地，TTF 表示使用 TrueType 技术。而 OTC 和 TTC 则表示字体集合（Collection），即一个文件中包含多种字体（例如多种语言）[<sup>[4]</sup>](#ref4)。这 4 种字体文件在主流操作系统和网页设计中都是可用的。\n\n除此之外，还有专用于网页的网页开放字体（Web Open Font Format）格式，其设计标准通常为 OpenType 或 TureType，但在文件打包和压缩中专门为网络传输做了优化。WOFF 字体在主流浏览器中都得到很好的支持，文件后缀名为 `.woff` 以及 `.woff2`。\n\n### 字体类型\n\n常见的字体可以分为“衬线（serif）”、“无衬线（sans serif）”、“等宽（monospace）”等类型。衬线是指在字体笔画末端有小装饰。在论文写作中常用的 Times New Roman 字体和中文宋体便是衬线字体。无衬线字体的字体线条则相对简约，例如 Arial 和“微软雅黑”以及“苹方”。等宽字体则表示每个字符占据相等的宽度，这一点衬线和无衬线字体是无法保证的，例如小写字母 `i` 在非等宽字体中往往占据较小的字宽。\n\n由于衬线字体具有更丰富的细节且更加精致，所以多用于印刷和高清显示。无衬线字体在屏幕显示上更加普遍，主流浏览器和操作系统的默认字体一般都是无衬线字体。但随着屏幕分辨率的提高和显示技术的提升，在屏幕显示中使用衬线字体可以使文本页面更加精致具备设计感。例如[我的主页首页](https://www.hozen.site)部分字体就使用了思源宋体。等宽字体由于具备字符等宽的特点往往被用于代码的编辑和显示。\n\n### 字体家族 Font Family\n\n前文提到的诸如“Times New Roman“，“微软雅黑”等字体其实都是字体家族的概念。字体家族代表了统一的设计风格，但字体往往需要不同的粗细（字重）和样式（斜体、字宽等）。因此一个字体家族可以包含不同的子字体来实现不同的字体样式。具体地，字体样式包括字重、字宽、倾斜和视觉尺寸等方面，通过这些样式的组合便产生不同的子字体。但除非特别需要，对于屏幕显示来说常用的子字体样式一般只包括字重和倾斜。例如，苹方字体家族字体包括常规体（Regular）、极细体（Ultralight）、纤细体（Thin）、细体（Light）、中黑体（Medium）和中粗体（Semibold）6 个子字体。当然也有一些发布较早的字体只包含一种样式，即一个字体文件。\n\n当我们使用文字处理软件或者 CSS 属性对字体应用“加粗”和“倾斜”等样式时，系统会查找对应样式的子字体是否可用，如果可用则使用对应的子字体，否则则通过计算对字体进行强制的加粗和倾斜。虽然这两种方式最终都将字体进行了加粗或倾斜，但效果是完全不一样的。子字体不同的样式通过了严格的设计，使其具备统一的美感。而后者只是简单粗暴的加粗或倾斜，视觉效果往往比不上前者。例如，下图中分别使用思源宋体的常规体进行计算加粗（上）和直接使用思源宋体的 Bold 字体（下），可以明显看出上面的文字在细节和观感上相去甚远。\n\n![计算加粗和子字体的效果对比](/assets/images/64-1.png)\n\n### 可变字体（Variable Font）\n\n一款优秀的字体会提供多种字重的子字体，这样能保证在使用不同字重时能够保持优秀的观感。但每一款单独的字重或样式的字体往往需要单独的字体文件，这导致了当字体样式变多时字体文件数量增加，尤其对于网络页面来说会增加请求次数和流量负担。\n\n为了解决这一问题，在 OpenType 规范的中，Adobe、微软、苹果和谷歌于 2016 年共同推出了**可变字体**（[Variable font](https://learn.microsoft.com/en-us/typography/develop/font-variations)）的标准，这一标准改变了字体样式的设计和使用[<sup>[5]</sup>](#ref5)。就字重来说，不再需要多个字重的字体文件，一个字体文件即可使用多种字重。并且，字体字重不再被离散的划分为“常规”，“中黑”等有限的个数，而是能够通过调整字重参数获得任意粗细，实现字重的无级调节。像下图中 MIUI 的动态交互效果在没有可变字体时是很难实现的。\n\n![基于小米兰亭可变字体实现的字重无极动态变化](/assets/images/64-2.gif)\n\nOpenType 要求可变字体文件需要在命名使用 `VF`标注，例如 `Selawik-VF.ttf`。因此我们从字体文件名往往可以分辨该字体是否是可变字体。\n\n## CSS 属性\n\n### 默认字体名称\n\nCSS 属性 `font-family` 用于指定字体，并且规定了 5 种默认的字体名称：`serif`, `sans-serif`, `monospace`, `cursive`, `fantasy`，除了前面提到的 3 种字体，`cursive` 和 `fantasy` 分别表示手写字体和装饰字体。当使用这些默认字体名称时，具体使用何种字体是由浏览器决定的，往往也会根据操作系统的不用有所不同。以下是五种默认字体在当前浏览器的显示效果：\n\n| `font-family` | 显示效果                                                                            |\n| ------------- | ----------------------------------------------------------------------------------- |\n| `serif`       | <span style=\"font-family: serif\">这是衬线字体 This is serif font</span>             |\n| `sans-serif`  | <span style=\"font-family: sans-serif\">这是无衬线字体 This is sans serif font</span> |\n| `monospace`   | <span style=\"font-family: monospace\">这是等宽字体 This is monospace font</span>     |\n| `cursive`     | <span style=\"font-family: cursive\">这是手写字体 This is cursive font</span>         |\n| `fantasy`     | <span style=\"font-family: fantasy\">这是装饰字体 This is fantasy font</span>         |\n\n虽然使用默认的字体属性可能会造成跨平台字体表现不一致的情况，但对于大多数功能性网页来说不必过分担心，因为在主流平台中字体经过了严格设计，规范性和易用性是完全经得住考验的。\n\n### 字体栈\n\n使用 `font-family` 除了上述 5 种默认字体名称外，可以指定具体的字体名称，例如 `Times New Roman`。当指定的字体不可用（系统未安装该字体或远程字体加载失败）时则会使用浏览器默认字体。\n\n为了防止字体退化为默认字体，可以为 `font-family` 指定多个字体，例如 `font-family: \"Times New Roman\", Times, serif`。浏览器会按照属性列出的先后顺序查找和使用字体，直到找到第一个可用的字体，当字体都不可用时则使用浏览器默认的字体。\n\n在字体栈的最后使用一个默认字体名称是不错的选择，因为即使浏览器没有找到合适的字体也会使用一个还算合适的字体。否则，当所有字体都不可用时，为了强调这一点，相应文字将被赋予浏览器的默认**衬线字体** - 通常是 Time New Roman - 这对于 sans-serif 字体是不利的！\n\n### 网络安全字体\n\n前文提到，在不同的浏览器和操作系统中网页的默认字体会有所不同。当对页面有跨平台时保持字体统一的要求时，可以使用“网络安全字体“，安全字体即挑选出在主流平台都默认安装的字体，来保证跨平台时字体的可用性。\n\n以下是拉丁文字体的网络安全字体：\n\n| 字体名称        | 泛型       | 注意                                             |\n| --------------- | ---------- | ------------------------------------------------ |\n| Arial           | sans-serif | 使用 Helvetica 作为 Arial 首选替代               |\n| Georgia         | serif      |                                                  |\n| Times New Roman | serif      | 使用 Times 作为 Times New Roman 的首选替代方案   |\n| Courier New     | monospace  | 使用 Courier 作为 Courier New 的首选替代方案     |\n| Trebuchet MS    | sans-serif | 应该小心使用这种字体——它在移动操作系统上并不广泛 |\n| Verdana         | sans-serif |                                                  |\n\n其中“首选替代方案”往往是因为同一款字体的不同版本在新旧操作系统上安装情况或名称不一致，使用字体栈包含各种可能的名称来保证可用性。\n\n## CSS 自定义字体\n\nCSS3 引入 @font-face 规则，可以从远程服务器加载字体文件或使用户本安装的字体。这一特性使得网页设计不必局限于默认字体或“网络安全字体”，使得网页设计更具个性和品牌表达力。\n\n一个使用 @font-face 的加载远程字体的典型例子：\n\n<p class=\"codepen\" data-height=\"300\" data-default-tab=\"html,result\" data-slug-hash=\"LYJjwbG\" data-user=\"Hozen\" style=\"height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;\">\n  <span>See the Pen <a href=\"https://codepen.io/Hozen/pen/LYJjwbG\">\n  Untitled</a> by Hozen (<a href=\"https://codepen.io/Hozen\">@Hozen</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.</span>\n</p>\n<script async src=\"https://cpwebassets.codepen.io/assets/embed/ei.js\"></script>\n\n**但是，请注意**！上面例子中的文字将以“Times New Roman”字体展示，这是因为 @font-face 的远程字体文件加载同样需要遵循**同源策略**，我们在 codepen.io 加载 github.io 的跨域资源将加载失败。还记得前文提到，当字体栈不可用时会使用浏览器的默认衬线字体作为提醒吗？这就是为什么上例的文字最终会以“Times New Roman”字体展示。\n\n@font-face 常用的属性有：\n\n* `font-family`，指定字体的名字，将会被用于 font 或 font-family 属性\n\n* `src`，远程字体文件位置的 URL 或者用户计算机上的字体名称，可以使用 `local` 语法通过名称指定用户的本地计算机上的字体 ( i.e. `src: local('Arial');` )。如果找不到该字体，将会尝试其他来源，直到找到它。\n\n* `font-weight`，定义该字体的字重，如果所需字体符合描述，则采用本 font-face 所定义的字体。\n\n* `font-style`，定义该字体的样式。如果所需字体符合描述，则采用本 font-face 所定义的字体。\n\n除此之外还有 `font-variant`，`font-stretch` 和 `unicode-range` 等属性，可以参照 [@font-face - CSS：层叠样式表 | MDN](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face)。\n\n### @font-face 定义多字重字体\n\n上文提到，虽然浏览器可以对常规字体进行强制加粗但视觉效果并不理想，但不同的样式又对应不同的字体文件，如何使用 @font-face 加载不同样式的子字体文件呢？答案是通过定义不同的字体样式来加载不用的字体文件，例如：\n\n```html\n<html>\n  <head>\n    <style>\n      @font-face {\n        font-family: 'Source Han Serif';\n        src: url(/font/SourceHanSerifCN/regular.ttf);\n      }\n      @font-face {\n        font-family: 'Source Han Serif'; /* 同一个字体名称 */\n        src: url(/font/SourceHanSerifCN/bold.ttf); /* 但不同的字体文件 */\n        font-weight: bold; /* 根据字重应用不同的文件 */\n      }\n\n      .regular{\n        font-family: \"Source Han Serif\";\n        font-size: 30px;\n        /* 常规字体，应用 regular.ttf 字体文件 */\n      }\n      .bold {\n        font-family: \"Source Han Serif\";\n        font-size: 30px;\n        font-weight: bold;\n        /* 加粗字体，应用 bold.ttf 字体文件 */\n      }\n    </style>\n  </head>\n  <body>\n    <div class=\"regular\">海内存知己，天涯若比邻。</div>\n    <div class=\"bold\">海内存知己，天涯若比邻。</div>\n  </body>\n</html>\n```\n\n显示效果如下：\n<style>\n      @font-face {\n        font-family: 'Source Han Serif';\n        src: url(/font/SourceHanSerifCN/regular.ttf);\n      }\n      @font-face {\n        font-family: 'Source Han Serif';\n        src: url(/font/SourceHanSerifCN/bold.ttf); font-weight: bold;\n      }\n\n      #id64-regular{\n        font-family: \"Source Han Serif\";\n        font-size: 30px;\n        line-height: 40px;\n      }\n      #id64-bold {\n        font-family: \"Source Han Serif\";\n        font-size: 30px;\n        font-weight: bold;\n        line-height: 40px;\n      }\n</style>\n<div style=\"padding: 10px\">\n<div id=\"id64-regular\">海内存知己，天涯若比邻。</div>\n<div id=\"id64-bold\">海内存知己，天涯若比邻。</div>\n</div>\n\n类似地，还可以为斜体等字体效果单独指定字体文件。\n\n如果你使用的字体有可变字体版本，那么只需要加载一个字体文件就可以把全部样式搞定了！\n\n## 字体提取压缩\n\n对于拉丁文语言来说，一个完整的字体文件通常不过几百 KB，因为只需要很少的一些字符就能完整地表达所有单词和句子。但对于汉字这种象形文字来说，每一个字符都需要单独的设计，因此完整的汉字字体包往往达到数十兆大小。这对于网络页面加载来说是十分不利的。\n\n因此，在页面设计中如无必要往往不会对汉字正文字体使用自定义的远程字体。但在有些时候，我们为了页面设计的美观和各种文本的区分，可能需要对主页标题或重要信息使用特定设计的字体。在这种情况下，使用特殊字体的字符数往往很少，如果因此就引入一个数十兆的字体文件显然得不偿失。\n\n应对这种情况，使用切图可能是一种解决方案。但切图不利于 SEO，且当字体内容频繁更新时需要依赖设计人员，十分不便。此时，可以考虑使用自动化的脚本将页面中使用到特殊字体的字符进行提取，然后重新压缩成一个只包含特定字符的字体包来取代完整的字体包，这将大大提高页面加载速度。\n\n页面字体提取和压缩已经有一些第三方库可用，例如 [font-snake](https://github.com/ghost-axe/font-snake)、[fontmin](https://github.com/ecomfe/fontmin) 和 [font-spider](https://github.com/aui/font-spider) 等。除此之外还有专门针对字体设计的 [opentype.js](https://github.com/opentypejs/opentype.js)，该库保持积极的更新和活跃的用户群体，我的主页主题 [hexo-theme-tranquility](https://github.com/hooozen/hexo-theme-tranquility) 便使用了该库进行字体压缩。但需要注意，这些库目前都不支持可变字体的提取，所以当你进行字体提取时仍然可能需要加载多字重子字体文件。\n\n----\n*参考资料*\n\n<div id=\"ref1\"></div>\n[1]\tPostScript[EB/OL]//Wikipedia. (2023-02-06)[2023-03-08]. https://en.wikipedia.org/w/index.php?title=PostScript&oldid=1137755001.\n\n<div id=\"ref2\"></div>\n[2]\tTrueType[EB/OL]//Wikipedia. (2023-02-14)[2023-03-08]. https://en.wikipedia.org/w/index.php?title=TrueType&oldid=1139357629.\n\n<div id=\"ref3\"></div>\n[3]\tOpenType[EB/OL]//Wikipedia. (2023-02-12)[2023-03-08]. https://en.wikipedia.org/w/index.php?title=OpenType&oldid=1138857238.\n\n<div id=\"ref4\"></div>\n[4]\tPETERCON. Recommendations for OpenType Fonts (OpenType 1.9) - Typography[EB/OL]. (2021-12-09)[2023-03-08]. https://learn.microsoft.com/en-us/typography/opentype/spec/recom.\n\n<div id=\"ref5\"></div>\n[5]\t可变字体[EB/OL]//维基百科，自由的百科全书. (2021-08-19)[2023-03-08]. https://zh.wikipedia.org/w/index.php?title=%E5%8F%AF%E5%8F%98%E5%AD%97%E4%BD%93&oldid=67230919.\n\n等\n\n\n","tags":["CSS","字体","性能优化"],"categories":["developer"]},{"title":"Hexo 主题「致远」发布","url":"/archives/61/","content":"\n查看 <https://github.com/hooozen/hexo-theme-tranquility>\n","tags":["app"],"categories":["timeline"]},{"title":"什么时候我们才能够说一个陈述是“显然的”？","url":"/archives/62/","content":"\n我们在读数学教材或者题目解析时经常能看到“显然”、“不难证”等字眼，这时往往代表其推导过程对于读者来说**应该**是足够简单的，因此被略掉了。那么当我们读到这些内容或者自己做题时，这些结论真的是“显然”的吗？如果不是，那么什么时候我们才能说一个定理或者结论是显然的呢？\n\n<!--more-->\n\n我的数学启蒙老师经常挂在嘴边的一句话就是“数学最怕想当然”，我用了很长时间才真正领悟了这句话。并且我发现很多人在对待数学时往往是“想当然的”，因此我总是逼问他们“为什么这里你可以做这样的推导？”，当对方回答“这不是显然的吗”的时，我总是难以找到有力的反驳。直到我在一本数学通识书[<sup>[1]</sup>](#ref1)中读到了一句话，让我直呼高明。在公布这句话之前，先让我们来看一个例子：\n\n请你思考一下，“[质数](https://en.wikipedia.org/wiki/Prime_number)有无穷多个”这个命题对不对，如果对（或者错）那么这个结论是不是显然的？我想大多数人都会认为“质数确实有无穷多个”，并觉得这个结论是显然的。\n\n首先，质数确实有无穷多个（这一次你的直觉做出了正确的选择），但是这个定理真的“显然”吗？如果我现在要求你证明这个定理，你能否立刻证明出来呢？\n\n> 如果脑子里立刻就有证明，那么这条陈述才是显然的[<sup>[1]</sup>](#ref1)。\n\n正是这句话让我拍案叫绝。如果你脑海里不能立刻浮现证明它的思路，那么你就不能说“质数有无穷多个”是显然正确的。实际上这条定理早在两千多年前就被欧几里得证明了，但我问过多个朋友（其中包括硕士生甚至博士生）他们都没能立刻给出证明，并且很快表示了放弃。因此我应该可以说，这条定理确实不足以称得上“显然”。\n\n下面让我们来看看欧几里得是怎么证明这条定理的[<sup>[2]</sup>](#ref2)：\n\n任意列举若干有限个质数列 $p_1,p_2,\\cdots,p_n$，记 $P = p_1p_2\\cdots p_n$，$q = P + 1$。则 $q$ 要么是质数要么不是质数。\n\n* 如果 $q$ 是质数时，我们则在原质数列外找到了新的质数，即 $q$。\n\n* 如果 $q$ 不是质数，则存在 $q$ 的质因子可以整除 $q$，不妨记作 $p$。若 $p$ 在原质数列 $p_1,p_2,\\cdots,p_n$ 中，则 $p$ 也可以整除 $P$。由于 $P$ 和 $q$ 都可以被 $p$ 整除，则应得 $P - q = 1$ 也可以被质数 $p$ 整除，但并不存在能够整除 $1$ 的质数，因此 $p$ 一定不在原质数列中。故在原质数列外又找到了新的质数 $p$。\n\n综上，给定任意质数列，总可以找到额外的新的质数，故质数有无穷多个得证。\n\n看完欧几里得的证明，我只有一个感觉，那就是“天才就是天才”。别说“立刻就有证明”，给我三年我都不一定证得出来。因此，我断不敢言这个定理是“显然的”。但至少这个证明只需要中小学数学知识并用短短几句话就说明了，而在我读到那句话的后面，作者给出的是另外三个看似十分显然实则更加复杂的定理，足以让我感受到这句话的分量和精妙。\n\n虽然以上的例子我们的直觉做出了正确的选择，若总是如此，我们在学习或考试时倒也不必“锱铢必较”。但实际上数学很多时候是“反直觉”的，当我们或者他人脑海中想当然的“显然怪”出现时，请务必追问一下“我（你）能立刻证明它吗？”\n\n![欧几里得](/assets/images/62-1.jpg)\n\n## 参考资料\n\n<div id=\"ref1\"></div>\n[1] 蒂莫西•高尔斯. 牛津通识读本：数学 [Mathematics: A Very Short Introduction][M]. 刘熙, 译. 译林出版社, 2014[2022-12-21].\n\n<div id=\"ref2\"></div>\n[2] Euclid’s theorem [EB/OL]//Wikipedia. [2022-12-19](2022-12-21). <https://en.wikipedia.org/w/index.php?title=Euclid%27s_theorem&oldid=1128360450>.\n","tags":["欧几里得","质数","数学思维"],"categories":["science"]},{"title":"多少冬天","url":"/archives/57/","content":"\n冬天一下子就来了。一场雨，一夜风，忽然落满街巷的树叶。\n<!--more-->\n\n我曾读过一个山脚下的小学。说是山脚下，其实校园已经完全建在了山坡上，学校四周都是荒野，出了校门便是一条近百米的陡坡。从坡下远远地看校园，竟有些庄严巍峨，当校园里空无一人时，更使人不敢高声语。我在这所学校读了两年书。\n\n冬天来的时候，学校后山一篇荒芜，满目的土黄色，和学校操场一个颜色。气温会在某天突然降低，这天老师们购入煤炭，然后打开最角落教室的门，把煤炭存进去，把碳炉和烟筒取出来。每个班级各自领一套，安置在讲台旁取暖。老师指定一名离家近的“炉长”，这名同学每天就会带着责任早早地赶到教室，用从自己家带来的棒瓤子引着炉子，并拥有携带火柴或火机的特权。等到晨读同学们陆陆续续赶到时，教室里已十分温暖了。炉子上面什么也不煮，用一层钢圈加一层钢盖盖着。一把火钩和一把火铲，需要加煤时，钩开炉盖，铲一铲煤进去。炉子里煤炭默默地燃烧着，炉子外老师不紧不慢地给我们讲课。“火要空心，人要实心”。煤炭快烧完时，“炉长”就会拿着垃圾斗去仓库领煤，有时确实紧急便又获得在课堂上出入教室的特权。到放学的时候，等值日的同学打扫完卫生，把炉箅一抽，没烧完的煤炭散落到炉灰里，便锁门离去。负责看管炉子的是我们班长，是我的好朋友，老师同学都喜欢他。\n\n有天晚上下了一场大雪，第二天早上远远近近的老师们赶了泥泞的雪路陆续抵达学校时，学生们已经早早打了几轮雪仗了。当我赶到教室时，几个好朋友神采奕奕，告诉我他们弄炸了一个炉盖。我看着裂成两半的生铁炉盖碎片，很惊讶。他们说应该是打雪仗不小心扔上面的雪球导致的。我很好奇，班长去仓库领来了一个新的炉盖，这次的炉盖看起来很厚实。等炉盖烧热后，我们捏了一个雪块放在炉盖上，众目睽睽下，随着雪块滋滋的滑动，炉盖突然砰的一声裂成了两半。我们都满意的笑了，然后趁着老师还没来教室，把炉盖碎片扔进了教学楼后面的垃圾堆，换了个同学竟然又顺利地领回来一个新的炉盖。\n\n每个学期开学，老师们从镇上采购物品，为每个教室配备卫生用具，几把小扫帚，几个垃圾斗。分配了室外卫生区的班级，还会配备两把大笤帚。小扫帚用不了几个星期就完全磨损得不能用了，所以值日生要记得值日的那天把家的扫帚带来，放学时再带走，也不会耽误家里用。我们班有一个同学，他带的扫帚很特别，不同于我们平时用的高粱扎的扫帚，他的扫帚是芒草扎的。柔软细腻，打扫时能把垃圾灰尘打扫的非常干净。他和我们班最漂亮的女生一个卫生小组，放学后一起穿梭在一排排课桌间打扫教室。他时常忘记值日后把扫帚带回家，大概是他的妈妈特意为他上学准备的扫帚吧，所以并不着急。那个女生便课间偶尔借用他的扫帚打扫自己的座位，也顺便帮他打扫。我的一个好朋友终于看不下去了，他和我们几个说，“放假的时候我得揍他”。他说服也喜欢那位女同学的班长一起，并让我也参与，那个同学平时确实会对我出言不逊，我没有理由拒绝。\n\n​放假那天中午，他们几个特意等到很晚。等人都走后，叫来我去了教室，打开炉盖，把那个同学的扫帚扔进了炉子。确实是一把好扫帚，扔进炉子里火一下子就顺着扫帚着起来，火势很旺，火苗都快窜到房顶了。看着炉火烧断捆扎的绳子，紧实细密的扫帚一下子散开，火苗慢慢把它们吞噬，我觉得有些可惜。下午放学后，我跟着他们一起出了校门，我的朋友叫来了高年级的同学，在下坡的拐弯处围住了他，那位同学平时的神气完全不见了，在我的朋友们的撕扯和踢踹中左右摇晃也不还手。我在旁边看着，竟然觉得他有点可怜。我的那个朋友对我说“踹他一脚。”“别害怕，他不敢还手。”我没有动也没有说话，我突然忘记我为什么讨厌这个同学了。后来他们各自回家了，天很快黑了，我也回家了。\n\n后来上了四年级，我们几个还是好朋友，我们还是不喜欢那个同学。再后来我转学了，许多事我已经记不清楚。多少冬天过去，我再也没回到过那所山脚下的学校。\n\n![57-1](/assets/images/57-1.jpg)\n","tags":["散文"],"categories":["life"]},{"title":"Wallpaper Enginner 创意工坊更新","url":"/archives/60/","content":"\n## [release v2.0.2](https://github.com/hooozen/WE-theme-Timer/releases)\n\n有了“昼夜模式”就可以在白天和晚上使用两套不同亮度或风格的壁纸了！\n\n- 勾选【昼夜模式】后自定义明亮和深色两套背景图片\n- 根据所在地和个人习惯设置“日出时间”和“日落时间”\n- 设置“明亮主题目录”和“深色主题目录”，壁纸就会根据时间应用不同的目录\n\n<https://steamcommunity.com/sharedfiles/filedetails/?id=2222111958>\n\ngithub: <https://github.com/hooozen/WE-theme-Timer>\n","tags":["app"],"categories":["timeline"]},{"title":"JS探幽——移位运算符 <<，>> 和 >>> ","url":"/archives/56/","content":"\n移位运算符在数据结构与算法中有着重要的作用，很多时候可以大大提高算法性能，简化问题求解。同时也是高级语言连接计算机机器码的工具。本文介绍了 JavaScript 中移位运算符 <<，>> 和 >>> 的规范和表现。\n\n<!--more-->\n\n## 前言\n\n可能很多前端开发者对位运算并不感冒，觉得过于接近于 C、C++ 等语言的风格以至于与 JavaScript 简单易用的风格所不符。事实确实如此，大多数情况下位运算都可以用普通的数值操作符替代实现，并且前端开发者对于接近于底层的性能优化并不敏感。诸多有关位运算的优化算法又过于晦涩[<sup>1</sup>](#ref1)，深入了解又不免过于消耗精力。但有时稍花费一点时间了解一些常用的位操作技巧，能够提升编码的效率和性能。例如，在 JavaScript 中求两数中间的整数，即可使用移位操作简化代码：\n\n```javascript\nlet a = 0, b = 11, mid\n\nmid = Math.floor((a + b) / 2)  // 使用四则运算并调用函数\nmid = (a + b) >> 1  // 求和后直接向右移位\n```\n\n既然要用，那么就要对其规范和表现有一个准确的了解，使用时遇到意外的表现也可快速定位问题。\n\n## 引例\n\n照例，在阅读本文前请思考下面的代码，考虑它们的预期处理结果是什么。如果你能完全预料和理解这种表现，那么无需拨冗阅读本文了。如果一些表现使你疑惑，也许能从本文得到答案。\n\n```javaScript\n/*-- part 1 --*/\n1 << 31 === 2 << 30 // true\n1 << 32 === 2 << 31 // false\n\n1 << 30 === Math.pow(2, 30)  // true\n1 << 31 === Math.pow(2, 31)  // false\n\n2 << 29 === Math.pow(2, 30)  // true\n2 << 30 === Math.pow(2, 31)  // false\n\n\n/*-- part 2 --*/\n1 >> 31 === 0 // true\n1 >> 32 === 1 // true\n1 >> 33 === 0 // true\n2 >> 31 === 0 // true\n2 >> 32 === 2 // true\n\n/*-- part 4 --*/\n-1 >> 1 === -1 // true\n-1 >> 2 === -1 // true\n-1 >> 32 === -1 // true\n\n-2 >> 1 === -1 // true\n-2 >> 31 === -1 // true\n-2 >> 32 === -2 // true\n-2 >> 33 === -1 // true\n\n/*-- part 5 --*/\n\n-1 >>> 1 === 2147483647 // true\n\n```\n\n## JS 的移位运算符\n\n其实引例中的表现均可用以下几个规则来解释：\n\n1. 位运算符将被操作数视作由 0 和 1 构成 32 位的二进制数串[<sup>2</sup>](#ref2)\n2. 按照第一条规则转换数字时使用 32 位二进制补码表示\n3. 移位操作的移动位数为右操作数对 32 取模后的值，例如 `a << 33 === a << 1`，`a << -31 === a << 1`\n\n根据以上规则，再结合 `<<` `>>` 和 `>>>` 3 种运算符的具体规则[<sup>2</sup>](#ref2)：\n\n* `<<` 左移位运算符，将左操作数的 32 位补码每个数位的数都向左移动指定位数，左溢出的数字舍弃，右侧补 `0`\n* `>>` 有符号右移位运算符，将左操作数的 32 位补码每个数位的数都向右移动指定位数，右溢出的数字舍弃，左侧根据原操作数的最高位补 `0` 或 `1`\n* `>>>` 无符号右移位运算符，将左操作数的 32 位补码每个数位的数都向右移动指定位数，右溢出的数字舍弃，左侧补 `0`\n\n有了以上规则，JavaScript 的移位操作符的运算结果就都能正确判断了。至此文章的核心内便已经结束，如果你已经熟悉其它语言的移位运算，那么只需要参考以上规则即可。下面结合具体例子进行解释。\n\n### 计算机的补码\n\n在开始介绍具体的运算符前，先简单回顾下计算机的补码。计算机的补码是为了简化整数间的减法运算而设计的一种非常巧妙地编码方式，这里只简单的介绍补码的编码规则，以备后用。\n\n对于 32 位整数来说，正数的补码与原码一致，由于最高位为符号位固定为 `0` 表示正数，故 32 个数位所能表示的正整数范围为 $[1, 2^{31} - 1]$。数字 `0` 的补码则表示为 32 个 `0`。对于负数来说，首先最高位固定为 `1` 表示负数，剩余数位则在其原码的基础上“取反加1”。例如 `-1` 的原码为 `10000000000000000000000000000001`，则先对其非符号位取反得到 `11111111111111111111111111111110`，然后再加 1，得到 `-1` 的补码为 `11111111111111111111111111111111`。容易验证“-0”的原码在补码下表示 $-2^{31}$，故负整数的取值范围为 $[-2^{31}, -1]$。\n\n### `<<` 运算符\n\n根据规定，左移位运算符无非就是将所有数位左移，并在右侧补零。对于正整数来说，左移几位就是在原来的数乘上 2 的几次（对 32 取模后）幂：\n\n```js\nnum << n === num * Math.pow(2, n mod 32)\n```\n\n当然，上述公式基于所有数值对于 32 位整数来说没有溢出。当溢出时，将按照 32 位补码溢出处理。例如引例中 `2 << 31`，即将二进制 `10` 所有数位向左移动 31 位，显然第 2 位的 `1` 最终会移至（从右到左数）第 “33” 位，导致溢出被舍弃，最终所有数位皆为 `0`，因此 `2 << 31 === 0`。而对于 `1 << 32`，由于右操作数对 32 取模后为 0，故并不移位 `1 << 32 === 1`。\n\n同理，当左操作数对于 32 位整数溢出时，仍然先处理溢出后在进行移位操作。此处，仅举例：`(Math.pow(2,32) + 1) << 1 === 2`。\n\n另外需注意，左移操作时虽然限制了右操作数对 32 取模，但仍无法避免左侧溢出数位被舍弃。这就可能导致当操作数较大时，正数左移位后变为负数。例如，`2 << 30 === -2147483648  // -2^31`。\n\n### `>>` 运算符\n\n右移位运算符和 `<<` 左移位运算符对于溢出和取模的处理一致，不再赘述。但 `>>` 在补位的处理上略有不同，`<<` 运算符在右侧直接补 `0`。而 `>>` 运算符视被操作数的最高位选择补 `0` 或 `1`。具体地，当被操作数最高位为 `0`（即为正数或零）则补 `0`，反之补 `1`。也就说右移运算符保证了操作前后的符号。并且也解释了为什么对于 `-1 >> n` 无论 `n` 为多少结果都为 `-1`。因为 `-1` 的补码在各个数位上为 `1`，则右侧被移除多少个 `1`，左侧就会被补进来多少个 `1`，故并不改变数值大小。\n\n### `>>>` 运算符\n\n介绍完前两个运算符，无符号的右移运算符就一目了然了。该运算符与 `<<` 除了在移动方向上不同外，其余溢出、补零等规则都一致，不再赘述。仅解释引例中 `-1 >>> 1 === 2147483647`。由于 `-1` 的补码为 `111...111`，故右移一位后，右侧被舍弃一个 1，左侧最高位补 0，则变为 `0111...111`，显然该值为 $2^{31-1}$。与 `<<` 运算符一致，`>>>` 也可能使操作数发生符号变化。\n\n------\n\n*有关对于 32 取模的规则未找到官方文档支持，仅实验推断，并且未发现反例，读者可自测。*\n\n## *参考资料*\n\n<div id=\"ref1\"></div>\n\n[1] HENRY S. WARREN J. 算法心得：高效算法的奥秘（原书第2版）[M/OL]. 爱飞翔, 译. 机械工业出版社, 2014[2022-09-09]. <https://book.douban.com/subject/25837031/>.\n\n<div id=\"ref2\"></div>\n\n[2] Expressions and operators - JavaScript | MDN[EB/OL]. [2022-09-09]. <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#bitwise_operators>.\n","tags":["ECMAScript","JS探幽","移位运算符"],"categories":["developer"]},{"title":"JS探幽——从数据类型到包装器对象","url":"/archives/55/","content":"\n本文介绍了 JavaScript 的数据类型、基本数据类的包装器对象，以及对应的“装箱”机制，对一些违反直觉的语言表现进行了解释和查证。\n\n<!--more-->\n\n在阅读本文前思考下面的代码，考虑它们的预期处理结果是什么。如果你能完全预料和理解这种表现，那么无需拨冗阅读本文了。如果一些表现使你疑惑，也许能从本文得到答案。\n\n```javaScript\nconst v1 = 'a'\nconst v2 = String('a')\nconst v3 = new String('a')\n\n/*-- part 1 --*/\n\nconsole.log(v1) // 'a'\nconsole.log(v2) // 'a'\nconsole.log(v3) // String {'a'}\n\ntypeof v1 // 'string'\ntypeof v2 // 'string'\ntypeof v3 // 'object'\n\nv1 instanceof String // false\nv2 instanceof String // false\nv3 instanceof String // true\n\nv1 === v2 // true\nv1 === v3 // false\n\n/*---------------*/\n\n/*-- part 2 --*/\n\nv1 == v2 // true\nv1 == v3 // true\n\nv1.__proto__ === String.prototype // true\nv2.__proto__ === String.prototype // true\nv3.__proto__ === String.prototype // true\n\nv1[1] = 'b'\nconsole.log(v1[1]) // undefined\nv2[1] = 'b'\nconsole.log(v2[1]) // undefined\nv3[1] = 'b'\nconsole.log(v3[1]) // 'b'\n```\n\n对于数字类型（Number）和布尔类型（Boolean）有以上类似的表现。\n\n## 8 种数据类型\n\n根据最新的 ECMAScript 标准，定义了 8 种数据类型：\n\n* 7 种基本数据类型（Primitive value）\n  * 布尔值（Boolean），有两个值分别是：`true` 和 `false`  \n  * null，一个表明 null 值的特殊关键字\n  * undefined，表示变量未赋值，同样是一个特殊的关键字\n  * 数字（Number），表示整数或浮点数。使用双精度浮点类型\n  * 任意精度的整数（BigInt），用于大整数的计算。 日前已经成为 ES 的正式标准被主流浏览器实现\n  * 字符串（String）\n  * 代表（Symbol），ES6 中新增的类型。一般用以获取一个唯一的标识符\n* 对象（Object）\n\n标准中没列出数组、函数等其他数据类型，因为它们都被视为对象类型。作为 Javascript 开发者一定听过广为流传的“一切都是对象”这句话，是否意味着 7 种基本数据类型也是对象呢？若如此，标准中为何要将他们在对象类型外单独列出呢？若不是，为何可以调用字符串的 `length` 属性和 `toLocaleLowerCase()` `toLocaleUpperCase()` 等方法？内置的 `Number` `String` `Boolean` 对象又是何用呢？\n\n暂且不管“一切都是对象”这句话到底是什么意思，但需要明确的是 **7 种基本类型既不是对象也没有属性和方法**[<sup>1</sup>](#ref1)！那如何解释 `'a'.length` 等对基本数据类型进行方法和属性的调用？这就涉及到了 JS 的基本类型包装器对象和“自动装箱”机制。在此之前，我们先弄明白文章开头例子里几种变量的声明方式，以及他们分别生成了什么类型的变量。\n\n## 变量的声明\n\n上文只是抽象地指出了哪些数据类型是基本数据类型，但没有给出具体的声明语法。\n\n对于数字、字符串、布尔类型以及 `undefined` 和 `null`，可以直接使用字面量（Literals）声明。例如 `val1 = 1`，`val2 = 'a'`，`val3 = true`。其中 `1`、`'a'`、`true` 分别为数字字面量、字符串字面量和布尔字面量，由他们所赋值的变量 `val1`、`val2`、`val3` 即为数字型、字符串型、布尔型，属于基本数据类型。对于 BigInt 类型，可以在数字末尾加上 `n` 来使用字面量赋值：`const theBiggestInt = 9007199254740991n`。\n\n对于 Symbol 类型没有对应的字面量语法，则使用 `Symbol()` 函数返回一个 Symbol 类型的值，例如 `const symbol1 = Symbol()`。同样地，数字、字符串、布尔、BigInt 类型的值也可以通过直接调用函数 `Number()`、`String()`、`Boolean()`、`BigInt()` 来获取。\n\n以上两种方法所举例子中所声明的变量均为基本数据类型。而本文开头的示例代码中，还使用了 `new` 关键字 + 构造函数生成的变量的语法。在这种语法下所生成的变量则为对象类型。例如 `new Number(1)` 语法赋值的变量即为 `Number` 对象，属于对象数据类型。通过这种方式生成的对象也相应的被称为对应基本数据类型的**包装器对象**。\n\n需要注意的是，在 ES 标准中已不允许围绕基本数据类型**显性地**生成包装器对象。例如 `new BigInt()` 和 `new Symbol()` 会报错 `Uncaught TypeError: Symbol/BigInt is not a constructor`。而 `new Number()`、`new String()` 和 `new Boolean()` 的语法由于历史原因被保留下来[<sup>2</sup>](#ref2)。但在大多数情况下，这种语法都是没有必要的。(*`Symbol` 和 `BigInt` 的包装器对象仍可以通过其他方法手动生成，查看参考资料 [2] [<sup>2</sup>](#ref2)*。)\n\n至此，便可以解释示例代码中 part 1 的表现了。前两种声明方式生成了基本数据类型——字符串类型，第三种声明方式生成了包装器对象。因此才会有前两者的类型为 `sting` 而后者为 `Object`；同时前两者既不是对象，则使用 `instanceof` 找不到任何构造函数；最后基本数据类型完全判等时只比较值，故有前两者完全相等，而不等于第三者。\n\n## 包装器对象和“装箱”\n\n上文介绍了基本数据类型的包装器对象，即对基本数据类型进行“包装”生成对应的对象类型，以赋予其特定的属性和方法。除了 undefined 和 null 外，所有的基本类型都有对应的包装器对象：\n\n* Boolean\n* Number\n* String\n* Symbol\n* BigInt\n\n使用包装对象的 `valueOf()` 方法则返回该包装对象的原始基本类型值。\n\n使用 `new` 关键词可以显性地构造包装器对象，但在对于基本数据类型进行操作时包装器对象常常被隐性地构造。\n\n例如在尝试对一个字符串变量进行属性读取和方法调用时，则首先将该字符串包装成一个 String 对象，然后再调用该对象的方法和属性。而该对象在被调用完成后即被销毁，因此原来基本类型变量的值并不受影响。这就解释了为何在设置 `v1[1] = 'b'` 后 `v1` 的值仍为 `'a'`。以及调用 `v1.__proto__` 仍能得到 `String.prototype`。\n\n这种在必要时对基本数据类型进行“包装”生成对象的机制常被成为“装箱”。同样地，当试图对包装对象进行基本数据类型的操作时，包装器的 `valueOf()` 方法会被调用，用其返回的基本类型值进行运算。这种机制有人称之为“解箱”。\n\n示例代码中 `v1 == v3` 之所以为 `true`，即是因为在非严格判等时会进行隐式类型转换，调用了对象 `v3` 的 `valueOf()` 方法进行比较[<sup>3</sup>](#ref3)。\n\n**思考**\n\n以下代码有如何表现呢？\n\n```js\nconst obj1 = {\n  valueOf() { return 1 },\n  toString() { return '2' }\n}\nconst obj2 = {\n  toString() { return '2' }\n}\nconst val1 = 1\nconst val2 = 2\nconst val3 = '2'\n\nobj1 == val1\nobj1 == val2\nobj1 == val3\n\nobj2 == val2\nobj2 == val3\n```\n\n那么“一切皆是对象”是不是说 JavaScript 中的一切变量都可以看作对象来使用呢？或者说一切实现围绕对象进行呢？\n\n*参考资料*\n\n<div id=\"ref1\"></div>\n\n[1] Primitive - MDN Web Docs Glossary: Definitions of Web-related terms | MDN[EB/OL]. [2022-09-06]. <https://developer.mozilla.org/en-US/docs/Glossary/Primitive>.\n\n<div id=\"ref2\"></div>\n\n[2] Symbol - JavaScript | MDN[EB/OL]. [2022-09-06]. <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#description>.\n\n<div id=\"ref3\"></div>\n\n[3] Equality comparisons and sameness - JavaScript | MDN[EB/OL]. [2022-09-06]. <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#loose_equality_using>\n","tags":["ECMAScript","JS探幽","包装器对象"],"categories":["developer"]},{"title":"如何从零开发一款微信小程序","url":"/archives/54/","content":"\n最近开发了一款小程序，本文将介绍这款小程序在两周之内从立项到上线的全部流程，为个人开发者开发自己的第一款微信小程序简单指南。\n\n<!--more-->\n\n## 背景介绍\n\n前两周在和朋友打完球后讨论篮球规则时，互相提问了一些裁判员的手势，发现挺有意思。于是想可以开发一款小程序来考验球迷对标准篮球裁判手势的识别能力，于是去FIBA官网找了裁判手册，开始了两周开发一款小程序的历程。\n\n现在小程序已经上线，故整理一下这两周来的流程和经验，供大家参考。小程序名为「篮球裁判手势挑战」，可以扫码体验。\n\n![搜索「篮球裁判手势挑战」](/assets/images/54-1.jpg)\n\n## 开发流程\n\n一款软件的研发和维护流程涉及需求分析、产品设计、原型设计、UI和交互设计、系统设计、客服端和服务端编码实现、软件测试、运行维护、宣传运营、数据分析等等一系列工作。但如果整个项目只有你自己一个人，其实很多工作是可以简化和提高效率的，或者说是没有必要花费精力去做的。例如需求分析到UI设计的步骤完全可以合并到一起，前后端开发的也没必要花时间去指定详细的接口设计文档，测试和研发也可以随时交叉进行。毕竟自己提的需求自己改，自己的BUG自己测。\n由于一个人开发自己的小程序，没有责任和压力，所以很容易放弃，这里分享一下自己的一个经验。那就是要跳出自己开发者的定位，而更应该把自己看作项目经理的角色。具体来讲，技术的细节（或产品的设计）要让步于项目整体的规划，不然容易纠结于不断的优化代码和设计而导致进度缓慢，最终放弃。时刻提醒自己，先把事做完，再把事做完美。\n\n### 技能和工具\n\n个人开发软件，需要具备一定的设计和编程能力，但最重要的是有耐心。\n我选择了原生小程序开发和微信云开发的组合，主要涉及的工具如下。\n\n* **[微信小程序](https://mp.weixin.qq.com/)**，官网申请注册微信小程序，按照流程来很快就能申请到。\n\n* **[Pixso](https://pixso.cn/)**，一款国产“设计协作工具”，可以实现原型和UI的设计，免费且上手容易。\n\n* **[微信小程序开发文档](https://developers.weixin.qq.com/miniprogram/dev/framework/)**，微信小程序的官方文档，整体来说写的不错，有编程基础的很容易上手。\n\n* **[微信小程序开发者工具](https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html)**，微信公众号、小程序、小游戏的官方开发工具。\n\n* **[云开发](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html)** 实现小程序服务端的开发。我使用了微信云开发，优点是和小程序的无缝衔接，缺点是**收费太高**！可选阿里云开发，免费。\n\n* **PS**，主要用来处理资源图片和设计渲染宣传图。\n\n* **Git 及远程仓库**，（非必须）代码版本管理和备份。\n\n如果你是Vue选手，完全可以使用 **[uni-app](https://uniapp.dcloud.net.cn/)** 进行开发，并且可以完成一份代码多端编译（网页，微信小程序、安卓、iOS）。同时还有一个优势就是可以无缝搭配 **[uniCloud](https://uniapp.dcloud.net.cn/uniCloud/)**，使用**免费**的阿里云开发服务！但缺点是文档写得不如微信。\n\n### 产品设计\n\n我既然想开发一款考验球迷对篮球裁判手势识别能力的小程序，那么最好的选择就是做成答题类的形式，这样既有趣味性也相对简单。于是在简单进行软件流程的设计后，我着手进行了UI设计。\n\n有些开发者可能觉得自己开发软件还进行 UI 设计是多此一举，随着现在 UI 设计工具的学习门槛越来越低，专门进行 UI 设计至少有以下几个好处：\n\n* 在专门的工具上 UI 的修改成本是比开发时调试修改的成本要低，UI 设计虽然增加了工作步骤，但实际上减少了工作量，提高了效率。\n* UI 设计过程中也是对产品功能流程设计的检验，一些不合理或不符合用户习惯的流程设计会被提前发现和修改。\n* UI 设计可以保证用户界面的一致性，体现良好的页面审美。\n* 考虑到软件 UI 全局的一致性，可能会对已设计好的页面进行调整，所以当提前设计好所有 UI 时，开发过程中针对 UI 的修改将大大减少。\n* 后期出宣传图时，可以直接使用 UI 设计稿，更加灵活。\n\n由于答题类竞赛偏向游戏类软件，不可避免的有计时、动画、计分、奖励等设计，逻辑会比较复杂，很容易出BUG。所以最好的方式就是参考和模仿成熟的同类软件，这样的好处是可以快速设计出成熟的交互逻辑，并且清楚知道现有技术框架下哪些功能是可以实现的。\n\n![UI设计稿](/assets/images/54-2.png)\n\n### 编码实现\n\nUI 图稿有了进行前端的编码实现就变得比较轻松了，这里没有什么好说的，有一些经验分享给小程序开发新手：\n\n* 多读[官方文档](https://developers.weixin.qq.com/miniprogram/dev/framework/)，刚开始只需要读一下前几章，导入演示项目，把小程序开发的逻辑搞清楚就可以了。\n\n* 需要哪部分功能就去单独读文档里的相关部分，微信小程序的文档写得算不错的了，一般都能找到解决方案。\n\n* 遇到问题的话，可以去[微信开放社区](https://developers.weixin.qq.com/community/develop/question)搜索和提问，里面有很多经验丰富的老哥活跃。\n\n* 实在搞不懂的接口和功能，一般文档都附有演示项目，导入本地去调试。\n\n服务端的开发我使用了[微信云开发](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html)，非常方便，直接砸微信开发者工具中就可以调试和部署。和现在市面上很多 serverless 服务一样，微信云开发支持 `node.js`（仅支持），使用 NoSQL 数据库，对于前端开发非常友好，几乎没有上手难度。并且文档写得也不错，可以参考文档直接上手。\n\n![微信云开发控制台](/assets/images/54-3.png)\n\n除了小程序业务需求的开发，同时注意埋点和数据统计，这样有利于后期产品的优化和运营。例如我的答题小程序，由于一开始每道题的选项除了正确答案外其他选项都是随机的，那么可能会有些题很简单。于是我采集了每道题的各个选项出现的次数和错误次数，每天凌晨都会自动更新题目的选项（文档指南：[定时触发器](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/functions/triggers.html)），让错误率高的选项有更高的可能性被选中。\n\n要注意，微信云服务首月提供了配额非常少的免费环境，有时候连开发测试都会超出额度。所以项目上线必须要增加额度，并且如果需要配置测试环境等多个环境，又是一笔开销。费用相较市面的平均水平比较高，如果你一开始就对腾讯云服务的价格不满意，建议直接使用 [uni-app](https://uniapp.dcloud.net.cn/) + [uniCloud](https://uniapp.dcloud.net.cn/uniCloud/) 的开发模式，避免后期迁移的成本。\n\n### 测试和发布\n\n对个人开发者来说，测试是一个容易忽视的关键流程，因为“你永远也不知道用户将如何使用你的软件”。如果你没接触过软件测试的话很容易漏掉测试场景。所以我建议开发完成后，务必进行系统的测试。测试前用脑图软件或流程图软件，写好测试用例，尽可能涵盖每一种情况。如果软件编码完成后没测出来任何 Bug，不能说明代码写得好，只能说明测试做得差。\n\n一个人既编码又测试有优点也有缺点，要注意扬长避短。优点就是你清楚的知道每个场景的触发条件和边界情况，所以可以更好的梳理测试用例，不至于遗漏。同理，由于你知道代码的逻辑，所以容易想当然的忽略简单场景下的测试，而这就往往容易忽略Bug。所以提前梳理测试用例，不漏掉任何简单场景的做测试是必要的。\n\n微信小程序的版本管理分为体验版、审核版和正式版。测试要在体验版上进行，除了需要权限才能访问外，体验版和正式版对于用户来说没有什么区别。而审核版就是准备发布的体验版经过微信人工审核后通过的版本，审核通过的审核版就可以直接发布成为正式版了。\n\n发布前注意要想好小程序的名称，设计好 logo，因为一旦发布再去修改就比较麻烦了。小程序所有的审核时间都是 1-7 个工作日，我体验下来整个流程都很快，除了小程序名称开始申请的涉及他人商标被驳回外，其余的都在 2 天之内通过。因为小程序名称的审核是最严格的，所以要注意如果名称涉及商标，要准备好商标授权书，否则就尽量避免，以免耽误时间。\n\n### 运营和维护\n\n鼓励用户分享是一个提高小程序访问量的好方法，这就需要设置一些奖励机制，以及足够有吸引力的文案和图片。同样的可以借鉴其他小游戏的机制和设计，同时也可以根据后台数据来调整的文案和图片。线下宣传是前期积累第一批用户的有效办法，尤其对于有特定目标人群的软件，线下宣传做的好事半功倍。比如我已经制作好了宣传海报，准备往篮球场上贴，但由于发现云服务有点贵，小程序又没有任何盈利目的和规划，所以先暂时作罢。另外，微信官方提供有广告接入功能，可自行查阅。\n\n![准备好的宣传海报](/assets/images/54-4.jpg)\n","tags":["个人项目","微信小程序","全栈"],"categories":["developer"]},{"title":"「篮球裁判手势挑战」小程序发布","url":"/archives/59/","content":"![「篮球裁判手势挑战」](/assets/images/54-4.jpg)\n","tags":["app"],"categories":["timeline"]},{"title":"一致最小方差无偏估计 UMVUE 的求法归纳","url":"/archives/45/","content":"\n一致最小方差无偏估计估计 UMVUE 是参数估计中的重难点内容，也是很多高校考研专业课喜欢考察的问题. 但在很多教材中的介绍并不全面，主要问题在于本科生教材浅尝辄止，研究生教材有些晦涩，所以我归纳整理了求解 UMVUE 的背景知识和常用解法，供大家参阅批评.\n<!--more-->\n\n**转载注明出处！**\n\n## 1 一致最小方差无偏估计（UMVUE）\n\n### 1.1 均方误差\n\n在参数的点估计中，需要对各个估计量的好坏进行评价. **均方误差 (Mean Squared Error)** 是在小样本量下对点估计进行评价的常用标准，定义为 $\\text{MSE}(\\hat\\theta) = E(\\hat\\theta - \\theta)^2$，其中 $\\hat\\theta$ 代表对参数真值 $\\theta$ 的点估计量. 显然，估计的 MSE 越小越好.\n\n对于无偏估计量 $E(\\hat\\theta)=\\theta$，有\n\n$$\\begin{aligned}\n\\text{MSE}(\\hat\\theta) & = E[(\\hat\\theta - E\\hat\\theta)+(E\\hat\\theta-\\theta)]^2 \\\\\n           & = E(\\hat\\theta-E\\hat\\theta)^2 + E(E\\hat\\theta-\\theta)^2 + 2E[(\\hat\\theta-E\\hat\\theta)(E\\hat\\theta-\\theta)] \\\\\n           & = \\text{Var}(\\hat\\theta)\n\\end{aligned}$$\n\n即，无偏估计的均方误差即为其方差.\n\n### 1.2 一致最小均方误差估计\n\n**定义1**  设有样本 $X_1,X_2,\\cdots,X_n$，对待估参数 $\\theta$，有一个估计类，称 $\\hat\\theta(X_1,X_2,\\cdots,X_n)$ 是该估计类中 $\\theta$ 的**一致最小均方误差估计**，如果对该估计类中另外任意一个 $\\theta$ 的估计 $\\widetilde\\theta$，在参数空间 $\\Theta$ 上都有$\\text{MSE}_\\theta(\\hat\\theta)\\leqslant\\text{MSE}_\\theta(\\widetilde\\theta)$\n\n一致最小均方误差估计通常在一个确定的估计类中考虑，若不加限制，一致最小均方误差估计通常是不存在的（[1]287）.\n\n### 1.3 一致最小方差无偏估计\n\n当在参数 $\\theta$ 的无偏估计类中考虑一致最小均方误差估计时，由（1）式知，一致最小均方误差估计变为一致最小方差无偏估计.\n\n**定义2**  对参数估计问题，设 $\\hat\\theta$ 是 $\\theta$ 的一个无偏估计，如果对另外任意一个 $\\theta$ 的无偏估计 $\\widetilde\\theta$，在参数空间 $\\Theta$ 上都有 $\\text{Var}_\\theta(\\hat\\theta)\\leqslant\\text{Var}(\\widetilde\\theta)$，则称 $\\hat\\theta$ 是 $\\theta$ 的**一致最小方差无偏估计 (Uniform Minimum-Variance Unbiased Estimator)**，记为 **UMVUE**.\n\n**定理1** 设 $X=(x_1,x_2,\\cdots,x_n)$ 是来自总体样本的一个样本，$\\hat\\theta=\\hat\\theta(\\mathbf X)$ 是 $\\theta$ 的一个无偏估计，$\\text{Var}(\\hat\\theta) < \\infty$. 则 $\\hat\\theta$ 是 $\\theta$ 的 UMVUE 的充要条件是，对任意一个满足 $E(\\varphi(\\mathbf X))=0$ 和 $\\text{Var}(\\varphi(\\mathbf X))<\\infty$ 的 $\\varphi(\\mathbf X)$，都有 $\\text{Cov}_\\theta(\\hat\\theta,\\varphi)=0, \\forall \\theta \\in \\Theta.$\n\n **证明** 充分性：对于 $\\theta$ 的任意一个无偏估计 $\\widetilde\\theta$，令 $\\varphi = \\widetilde\\theta - \\hat\\theta$，则 $E(\\varphi)=0$.  于是\n\n$$\\begin{aligned}\n\\text{Var}(\\widetilde \\theta) &= E(\\widetilde\\theta - \\theta)^2 \\\\\n         &= E[(\\widetilde\\theta - \\hat\\theta) + (\\hat\\theta - \\theta)]^2 \\\\\n         &= E(\\varphi^2) + \\text{Var}(\\hat\\theta)+2\\text{Cov}(\\varphi, \\hat\\theta) \\\\\n         &\\geqslant \\text{Var}(\\hat\\theta)\n\\end{aligned}$$\n\n得证 $\\hat\\theta$ 为 $\\theta$ 的 UMVUE. 必要性证明见参考文献[1]第288页.\n\n## 2 充分完备统计量\n\n### 2.1 充分统计量\n\n**定义3** 设样本 $\\mathbf{X}$ 的分布族为 $\\{f(\\boldsymbol\\theta,x), \\boldsymbol\\theta \\in \\Theta\\}$，$\\Theta$ 是参数空间.   对于统计量 $\\boldsymbol T(\\boldsymbol X)$ ，若在已知 $\\boldsymbol T$ 的条件下，样本 $\\mathbf X$ 的条件分布与参数 $\\boldsymbol\\theta$ 无关，则称 $\\boldsymbol T$ 为 $\\boldsymbol\\theta$ 的**充分统计量 (Sufficient Statistic)**.\n\n**定理2 (因子分解定理)**  设 $\\boldsymbol{X} = (X_1,X_2,\\cdots,X_n)$ 是随机向量，$\\boldsymbol T(\\boldsymbol x)$ 是已知函数. 则 $T = T(\\boldsymbol X)$ 为充分统计量的充分必要条件是：存在两个函数 $g\\left(\\boldsymbol T(\\boldsymbol{\\boldsymbol x}),\\boldsymbol \\theta \\right)$ 和 $h(\\boldsymbol{x})$ 使得对任意的 $\\boldsymbol\\theta$ 和任一组观测值 $\\boldsymbol{x}$，有联合概率函数 (简便起见，将连续变量的概率密度函数和离散变量的概率分布列统称为概率函数，下同)\n$$\nf(\\boldsymbol{x},\\boldsymbol\\theta) = g\\big(\\boldsymbol T(\\boldsymbol{x}),\\boldsymbol\\theta\\big)h(\\boldsymbol{x})\n$$\n其中 $g(\\boldsymbol t,\\boldsymbol\\theta)$ 是 $\\boldsymbol  t,\\boldsymbol \\theta$ 的函数，$\\boldsymbol T(\\boldsymbol x)=(T_1(\\boldsymbol x), T_2(\\boldsymbol x),\\cdots,T_m(\\boldsymbol x))$ 和 $h(\\boldsymbol x)$ 是 $\\boldsymbol x = (x_1,x_2,\\cdots,x_n)$ 的函数.\n\n**例1** 设 $X_1,\\cdots,X_n$ 为来自正态总体 $N(\\mu,\\sigma^2)$ 的 i.i.d 样本，求 $\\mu, \\sigma^2$ 的充分统计量.\n\n**解** 样本的联合概率函数为 $f(\\boldsymbol{x},\\mu,\\sigma^2) = (\\sqrt{2\\pi}\\sigma)^{-n}\\mathrm{exp}\\left[-\\frac{\\sum\\limits_{i=1}^n(x_i - \\mu)^2}{2\\sigma^2}\\right]$，整理可得\n$$\nf(\\boldsymbol{x},\\mu,\\sigma^2)=(\\sqrt{2\\pi}\\sigma)^{-n}\\mathrm{exp}\\left[-\\frac{\\sum\\limits_{i=1}^nx_i^2-2\\mu\\sum\\limits_{i=1}^nx_i + n\\mu^2}{2\\sigma^2}\\right]\n$$\n由因子分解定理 $\\boldsymbol T = (\\sum\\limits_{i=1}^n X_i, \\sum\\limits_{i=1}^n X_i^2)$ 是参数 $(\\mu, \\sigma^2)$ 的充分统计量. 进一步整理得\n$$\nf(\\boldsymbol{x},\\mu,\\sigma^2)=(\\sqrt{2\\pi}\\sigma)^{-n}\\mathrm{exp}\\left[\\frac{n(\\bar x - \\mu)^2 + (n-1)s^2}{2\\sigma^2}\\right]\n$$\n说明 $(\\bar X,S^2)$ 也是参数 $(\\mu, \\sigma^2)$ 得充分统计量. 事实上 $(\\sum\\limits_{i=1}^n X_i, \\sum\\limits_{i=1}^n X_i^2)$ 与 $(\\bar X,S^2)$ 是一一对应的.\n\n**定理2 Rao–Blackwell 定理**：假设 $g(\\boldsymbol X)$ 是 $\\theta$ 的一个任意估计，$T(\\boldsymbol{X})$ 是一个充分统计量；那么 $g(\\boldsymbol{X})$ 相对于给定 $T(\\boldsymbol X)$ 的条件期望 $\\widetilde{g}=E\\big(g(\\boldsymbol{X})|T\\big)$ 是一个比 $g(\\boldsymbol X)$ 更好的估计量（至少不差于），即 $\\mathrm{Var}(\\widetilde{g})\\leqslant\\mathrm{Var}(g)$.\n\n**证明** 由定义3知 $\\widetilde{g}=E\\big(g(\\boldsymbol{X})|T\\big)$ 与参数 $\\theta$ 无关，故 $\\widetilde{g}$ 可作为 $\\theta$ 的估计量，并可表示为充分统计量 $T$ 的函数，记为 $\\widetilde{g} = \\widetilde{g}(T)$. 由重期望公式得 $E(\\widetilde{g}) =E(g)$，不妨记为 $\\theta_0$. $\\mathrm{Var}(g) = E\\left[(g-\\widetilde g)+(\\widetilde{g}-\\theta_0)\\right]^2=E(g-\\widetilde{g})^2+E(\\widetilde{g}-\\theta_0)^2+2E\\left[(g-\\widetilde{g})(\\widetilde{g}-\\theta_0)\\right]$，其中\n\n$$\\begin{aligned}\nE\\left[(g-\\tilde g)(\\tilde g - \\theta_0)\\right]\n&= E\\left\\{E\\left[(g-\\tilde g)(\\tilde g - \\theta_0)|T\\right]\\right\\} \\\\\n&= E\\left\\{(\\tilde g-\\theta_0)E\\left[(g-\\tilde g)|T\\right]\\right\\} \\\\\n& = E\\left\\{(\\tilde g-\\theta_0)\n\\left[E(g|T)-E(\\tilde g|T)\\right]\n\\right\\} \\\\\n& = E\\left[(\\tilde g-\\theta_0)\n(\\tilde g-\\tilde g)\n\\right] \\\\\n&=0\n\\end{aligned}$$\n\n故 $\\mathrm{Var}(g) = E(g-\\widetilde{g})^2 + \\mathrm{Var}(\\widetilde{g})$, 则 $\\mathrm{Var}(\\widetilde{g}) \\leqslant \\mathrm{Var}(g)$.\n\n由 Rao–Blackwell 定理可知，若参数得 UMVUE 存在，则一定是充分统计量或充分统计量的函数.\n\n### 2.2 完备统计量\n\n**定义4** 设总体 $X$ 的分布函数是 $F(x;\\theta)$，$\\Theta$ 是参数空间，$\\mathbf T=\\mathbf T(\\mathbf X)$ 是基于 $X$ 的样本 $X_1, X_2, \\cdots, X_n$ 的统计量. 如果对于任何函数 $g(\\mathbf t)$，条件\n$$\nE_\\theta g(\\boldsymbol T) = 0,\\forall \\boldsymbol\\theta \\in \\Theta\n$$\n蕴涵 $P_\\theta(g(\\mathbf T))=0) = 1(\\forall \\boldsymbol\\theta \\in \\Theta)$，则称 $\\mathbf T(\\mathbf X)$ 是**完全统计量**或**完备统计量 (Complete Statistic)**.\n\n既是充分的又是完备的统计量称为**充分完备统计量**.\n\n## 3 指数型分布族\n\n### 3.1 指数分布族\n\n**定义5** 设 $\\boldsymbol X = (X_1, X_2, \\cdots, X_n)$ 是随机向量，$h(\\boldsymbol x), T_i(\\boldsymbol x)$ 是 $\\boldsymbol x = (x_1, x_2, \\cdots, x_n)$ 的实值函数，$C(\\boldsymbol \\theta), Q_i(\\boldsymbol \\theta)$ 是 $\\boldsymbol \\theta$ 的函数. 如果 $\\boldsymbol X$ 有联合概率函数\n$$\nf(x,\\boldsymbol\\theta) = C(\\boldsymbol\\theta)\\mathrm{exp}\\left[\\sum\\limits_{i=1}^mQ_i(\\boldsymbol\\theta)T_i(\\boldsymbol x)\\right]h(\\boldsymbol x),\\boldsymbol\\theta\\in\\Theta\n$$\n则称 $\\boldsymbol X$ 服从**指数族分布**，其分布族称为**指数型分布族**.\n\n### 3.2 自然形式\n\n**定义6** 对于上述指数型分布族，引入新参数\n$$\n\\eta_i = Q_i(\\boldsymbol\\theta), i = 1,2,\\cdots,m.\n$$\n如果能从 $(18)$ 中解出唯一 $\\theta_i = h_i(\\boldsymbol\\eta)(1\\leqslant i \\leqslant m)$，其中 $\\boldsymbol \\eta = (\\eta_1, \\eta_2,\\cdots,\\eta_m)$，则有 $C(\\boldsymbol \\theta) = \\widetilde C(\\boldsymbol \\eta)$，这就得到指数族分布的自然形式\n$$\n\\tilde C(\\boldsymbol\\eta)\\mathrm{exp}\\left[\\sum_{i=1}^m\\eta_iT_i(\\boldsymbol x)\\right]h(\\boldsymbol x)\n$$\n则称 $(19)$ 为**自然指数族**或**标准指数族**，称\n$$\n\\widetilde{\\Theta} = \\{\\boldsymbol{\\eta}|\\boldsymbol{\\eta} = \\big(Q_1(\\boldsymbol\\theta),Q_2(\\boldsymbol{\\theta}),\\cdots,Q_m(\\boldsymbol{\\theta})\\big), \\boldsymbol{\\theta}\\in\\Theta\\}\n$$\n为**自然参数空间**或**标准参数空间**.\n\n**例2** 证明 $\\mathrm{Ga}(\\alpha, \\lambda)$ 的样本分布服从指数型分布，并写出其自然形式.\n\n**解** 记 $\\boldsymbol\\Theta = (\\theta_1, \\theta_2) = (\\alpha, \\lambda)$，则样本随机变量 $X=(X_1,X_2,\\cdots, X_n)$ 的联合密度为\n\n$$\\begin{aligned}\nf(\\boldsymbol x,\\boldsymbol{\\Theta}) &= \\frac{\\lambda^{n\\alpha}}{\\Gamma^n(\\alpha)}\\mathrm{exp}\\left[(\\alpha-1)\\sum_{i=1}^n\\ln x_i-\\lambda\\sum_{i=1}^nx_i\\right] \\\\\n& = C(\\boldsymbol\\Theta)\\mathrm{exp}\\left[Q_1(\\boldsymbol\\theta)T_1(\\boldsymbol{x}) + Q_2(\\boldsymbol{\\theta})T_2(\\boldsymbol{x})\\right]h(\\boldsymbol{x})\n\\end{aligned}$$\n\n其中 $C(\\Theta) = \\frac{\\theta_2^{n\\theta_1}}{\\Gamma^n(\\theta_1)},\nQ_1(\\boldsymbol{\\theta})  = \\theta_1 - 1,\nQ_2(\\boldsymbol{\\theta}) = -\\theta_2,\nh(\\boldsymbol{x}) = 1.$ $(\\theta_1, \\theta_2)$的参数空间是\n$$\n\\Theta = \\left\\{\\boldsymbol{\\theta}=(\\theta_1,\\theta_2)|\\theta_1>0,\\theta_2>0 \\right\\}.\n$$\n所以 $\\boldsymbol{X}$ 服从指数分布. 下面取 $\\eta_1 = Q_1(\\boldsymbol{\\theta})  = \\theta_1 - 1, \\eta_2 = Q_2(\\boldsymbol{\\theta}) = -\\theta_2$，则唯一解出\n$$\n\\theta_1 = \\eta_1 + 1, \\theta_2 = -\\eta_2, \\widetilde{C}(\\boldsymbol{\\eta}) = \\frac{(-\\eta_2)^{n(\\eta_1 + 1)}}{\\Gamma^n(\\eta_1 + 1)}\n$$\n所以 $X$ 分布的自然形式为\n$$\n\\tilde C(\\boldsymbol\\eta)\\mathrm{exp}\\left[\\eta_1T_1(\\boldsymbol{x})+\\eta_2T_2(\\boldsymbol{x})\\right]h(\\boldsymbol x)\n$$\n且自然参数空间为\n$$\n\\widetilde{\\Theta} = \\left\\{\\boldsymbol{\\eta}=(\\eta_1,\\eta_2) | \\eta_1>-1, \\eta_2<0\\right\\},\n$$\n**定理3** 如果 $\\boldsymbol X$ 的概率分布族能写成指数分布的自然形式 $(19)$，且自然参数空间 $\\widetilde\\Theta$ 有内点，则\n$$\n\\boldsymbol T(\\boldsymbol{X}) = \\big(T_1(\\boldsymbol{X}),T_2(\\boldsymbol{X}),\\cdots, T_m(\\boldsymbol{X})\\big)\n$$\n是 $\\boldsymbol\\theta$ 和 $\\boldsymbol\\eta$ 充分完备统计量.\n\n**证明** 由因子分解定理易证 $T(\\boldsymbol{X})$ 为充分统计量，完全性的证明参见参考资料[2]第 80 页.\n\n**例3** 对于正态分布 $\\{N(0,\\sigma^2):\\sigma\\in \\mathbb R^+ \\}$，证明统计量 $X_1$ 不是完备统计量，而 $T=\\sum\\limits_{i=1}^n X_i^2$ 是完备统计量.\n\n**解** $E_\\sigma(X_1) = 0$ 而 $P_\\sigma(X_1 = 0) = 0\\not=1(\\forall \\sigma\\in\\mathbb R^+)$，故 $X_1$ 不是完备统计量.\n\n$X_i / \\sigma \\sim N(0,1)$，故 $T/\\sigma^2 \\sim Ga(\\frac n 2,\\frac 1 2)$，因此 $T \\sim Ga(\\frac n2, \\frac 1{2\\sigma^2})$，由例1知，$\\boldsymbol X$ 服从指数型分布族，且其自然参数空间有内点，故由定理3，$T$ 为充分完备统计量，证必.\n\n## 4 Lehmann–Scheffé 定理\n\n**定理4 Lehmann–Scheffé 定理** 设 $\\boldsymbol T = \\boldsymbol T(\\boldsymbol{X})$ 是充分完备统计量，若 $\\hat g(\\boldsymbol X)$ 是 $h(\\boldsymbol\\theta)$ 的方差有限的无偏估计，即\n$$\nE_\\theta\\hat g(\\boldsymbol{X}) = h(\\boldsymbol{\\theta}), \\mathrm{Var}_\\theta(\\hat g(\\boldsymbol{X}))<\\infty, \\forall \\boldsymbol{\\theta} \\in \\Theta,\n$$\n则条件数学期望\n$$\n\\eta(\\boldsymbol{T}) = E\\left[\\hat g(\\boldsymbol{X})|T\\right]\n$$\n是 $h(\\boldsymbol{\\theta})$ 的唯一的 UMVUE. 证明见参考文献[3]103页\n\n## 5 Cramer-Rao 不等式\n\n**定理5 Cramer-Rao 不等式** 设总体分布 $f(x,\\theta)$，$X_1,\\cdots,X_n$ 是来自该总体的简单样本，$T=T(X_1,\\cdots,X_n)$ 是 $g(\\theta)$ 的任一个无偏估计，$g'(\\theta) = \\frac{\\partial g(\\theta)}{\\partial\\theta}$ 存在，且对 $\\Theta$ 中一切 $\\theta$，对\n$$\ng'(\\theta) = \\int_{-\\infty}^\\infty\\cdots\\int_{-\\infty}^\\infty T(x_1,\\cdots,x_n)\\prod_{i=1}^np(x_i,\\theta)\\mathrm dx_1\\cdots\\mathrm dx_n,\n$$\n的微商可在积分号下进行，即\n$$\ng'(\\theta) =  \\int_{-\\infty}^\\infty\\cdots\\int_{-\\infty}^\\infty T(x_1,\\cdots,x_n)\\frac\\partial{\\partial\\theta}\\left(\\prod_{i=1}^np(x_i,\\theta)\\right)\\mathrm dx_1\\cdots\\mathrm dx_n.\n$$\n则有\n$$\n\\mathrm{Var}(T) \\geqslant \\frac{[g'(\\theta)]^2}{nI(\\theta)}\n$$\n其中 $I(\\theta) = E\\left[\\frac\\partial{\\partial\\theta}\\ln f(x,\\theta)\\right]^2$ 为费希尔信息量，$\\frac{[g'(\\theta)]^2}{nI(\\theta)}$ 称为参数估计的 C-R 下限. 证明详见参考文献[1]291页.\n\n$(31)$ 式中若等号成立则称 $T$ 是 $g(\\theta)$ 的有效估计，有效估计一定是 UMVUE.\n\n## 6 UMVUE 的求法\n\n根据 Rao–Blackwell 定理 ，UMVUE 若存在一定是基于充分统计量的估计. 故寻找 UMVUE 可以利用因子分解定理寻找充分统计量，然后对充分统计量进行无偏修正，得到可能的 UMUVE，最后可以利用 UMVUE 的充要条件 (定理1)、Lehmann–Scheffé 定理、Cramer-Rao 不等式等方法说明其方差一致最小.\n\n下面通过例题说明求 UMVUE 的具体思路.\n\n**例4**  设 $X_1,\\cdots,X_n$ 为来自正态总体 $N(\\mu,\\sigma^2)$ 的 i.i.d 样本，求 $\\mu, \\sigma^2$ 的 UMVUE.\n\n**解法1** 由例1知，$(\\bar X, S^2)$ 是 $(\\mu, \\sigma^2)$ 的充分统计量. $E(\\bar X) = \\mu, E(S^2)=\\sigma^2$ 均为无偏估计，且为充分统计量的函数. 令 $E(\\varphi(\\boldsymbol{X})) = 0$，即\n\n$$\\int_{-\\infty}^\\infty\\cdots\\int_{-\\infty}^\\infty\\varphi(x_1,\\cdots,x_n)\\frac1{(2\\pi\\sigma^2)^{n/2}}\\mathrm{exp}\\{-\\frac1{2\\sigma^2}\\sum_{i=1}^n(x_i-\\mu)^2\\}\\mathrm{d}x_1\\cdots\\mathrm{d}x_n = 0$$\n\n两边对 $\\mu$ 求导，得\n\n$$\\begin{aligned}\n\\int_{-\\infty}^\\infty\\cdots\\int_{-\\infty}^\\infty\\varphi(x_1,\\cdots,x_n)\\sum_{i=1}^n(x_i-\\mu)\\mathrm{exp}\\{-\\frac1{2\\sigma^2}\\sum_{i=1}^n(x_i-\\mu)^2\\}\\mathrm{d}x_1\\cdots\\mathrm{d}x_n &= 0 \\\\\n\\int_{-\\infty}^\\infty\\cdots\\int_{-\\infty}^\\infty\\varphi(x_1,\\cdots,x_n)\\bar xf(\\boldsymbol{x},\\theta,\\sigma^2)\\mathrm{d}x_1\\cdots\\mathrm{d}x_n &= 0 \\\\\n\\mathrm{Cov}(\\varphi, \\bar X) &= 0\n\\end{aligned}$$\n\n由定理1知，$\\bar X$ 是 $\\mu$ 的 UMVUE.\n\n同理，式 $(32)$ 俩边对 $\\sigma^2$ 求导，得到 $\\mathrm{Cov}(\\varphi, S^2) = 0$，证得 $S^2$ 是 $\\sigma^2$ 的UMVUE.\n\n**解法2** 记 $\\boldsymbol{T} =(T_1(\\boldsymbol{X}), T_2(\\boldsymbol{X})) = (\\sum\\limits_{i=1}^nX_i, \\sum_{i=1}^n X_i^2)$ 样本的联合密度函数为\n\n$$\\begin{aligned}\nf(\\boldsymbol{x},\\theta,\\sigma^2) &= \\frac1{(2\\pi\\sigma^2)^{n/2}}\\mathrm{exp}\\left[-\\frac1{2\\sigma^2}\\sum_{i=1}^n(x_i-\\mu)^2\\right] \\\\\n& = \\frac1{(2\\pi\\sigma^2)^{n/2}}\\mathrm{exp}\\left(-\\frac{n\\mu^2}{2\\sigma^2}\\right)\\mathrm{exp}\\left[\\frac{\\mu T_1(\\boldsymbol{x})}{\\sigma^2}-\\frac{T_2(\\boldsymbol{x})}{2\\sigma^2}\\right] \\\\\n& = C(\\boldsymbol{\\Theta})\\mathrm{exp}\\left[Q_1(\\boldsymbol{\\theta})T_1(\\boldsymbol{x}) + Q_2(\\boldsymbol{\\theta})T_2(\\boldsymbol{x})\\right]h(\\boldsymbol{x})\n\\end{aligned}$$\n\n其中，$\\boldsymbol{\\theta} = (\\theta_1, \\theta_2) = (\\mu,\\sigma^2), h(\\boldsymbol{x})=1$.\n\n取 $\\eta_1 = Q_1(\\boldsymbol{\\theta}) = \\frac{\\theta_1}{\\theta_2}, \\eta_2 = Q_2(\\boldsymbol{\\theta}) = \\frac{-1}{2\\theta_2}$，唯一解出 $\\theta_1=\\frac{-\\eta_1}{2\\eta_2}, \\theta_2=\\frac{-1}{2\\eta_2}$，带入 $C(\\boldsymbol{\\theta})$ 得到 $\\widetilde{C}(\\boldsymbol{\\eta})$. 所以 $\\boldsymbol{X}$ 的分布族为指数型分布族且有自然形式，自然参数空间为\n$$\n\\widetilde{\\Theta} = \\left\\{\\boldsymbol{\\eta}=(\\eta_1,\\eta_2)|\\eta_1\\in(-\\infty,\\infty),\\eta_2<0\\right\\}\n$$\n\n由定理3知，$\\boldsymbol{T} = (\\sum\\limits_{i=1}^nX_i, \\sum_{i=1}^n X_i^2)$ 是 $\\boldsymbol{\\Theta}=(\\mu, \\sigma^2)$ 的充分完备统计量，基于该统计量构造 $\\mu, \\sigma^2$ 的无偏估计 $\\bar X, S^2$. 显然 $\\bar X, S^2$ 都可以表示为 $\\boldsymbol{T}$ 的函数，故由Lehmann–Scheffé 定理 $\\bar X = E(\\bar X|\\boldsymbol{T})$ 和 $S^2=E(S^2|\\boldsymbol{T})$ 分别为 $\\mu$ 和 $\\sigma^2$ 的 UMVUE.\n\n上例中，分布族为指数型分布族，使用定理3确定充分完备统计量是方便的，然后使用 Lehmann–Scheffé 定理说明 UMVUE. 对于非指数族分布，可以尝试使用因子分解定理和定义4说明充分性和完备性.\n\n**例5** 设 $X_1,\\cdots,X_n$ 为来自均匀样本分布 $U(0, \\theta), \\theta>0$ 的 i.i.d 样本，求 $\\theta$ 的UMVUE.\n\n**解** 样本的联合概率分布为 $f(\\boldsymbol{x},\\theta)=\\frac1{\\theta^n}I_{\\{0<x_{(n)}<\\theta\\}}$，其中 $X_{(n)}=\\max\\{\\boldsymbol{X}\\}$ 为次序统计量. 根据因子分解定理，$T=X_{(n)}$ 为充分统计量. $T$ 的概率密度函数为 $f(t,\\theta)=n\\frac{t^{n-1}}{\\theta^n} I_{\\{0<x_{(n)}<\\theta\\}}$. 则 $E(T) = \\frac{n}{n+1}\\theta$，可得 $\\frac{n+1}nT$ 为 $\\theta$ 的无偏估计，记为 $\\hat\\theta(T)$. 设 $E(g(T)) = 0$，即\n\n$$\\begin{aligned}\n\\int_0^\\theta g(T)n\\frac{t^{n-1}}{\\theta^n}\\mathrm{d}t &= 0 \\\\\n\\int_0^\\theta g(T)t^{n-1}\\mathrm{d}t &= 0 \\\\\n\\end{aligned}$$\n\n两边对 $\\theta$ 求导，得 $g(\\theta) = 0$，由定义4知 $T$ 为完备统计量. $\\hat\\theta(T) = E(\\hat\\theta(T)|T)$, 由 Lehmann–Scheffé 定理，$\\hat\\theta = \\frac{n+1}nX_{(n)}$ 为 $\\theta$ 的 UMVUE.\n\n相对于以上解法，估计的 C-R 下限的计算是简单而直接的，所以对于某估计我们可以先验证它的方差是否达到 C-R 下限，一旦达到 C-R 下限则立即说明该估计为 UMVUE.\n\n**例6** 设总体为指数分布 $Exp(1/\\theta)$，求参数 $\\theta$ UMVUE.\n\n**解** 先计算费希尔信息量 $I(\\theta) = E\\left[\\frac\\partial{\\partial\\theta}\\ln f(x,\\theta)\\right]^2 = \\frac1{\\theta^2}$，则 $\\theta$ 的 C-R 下限为 $\\frac{1}{nI(\\theta)} = \\frac{\\theta^2}n$. 对于 $\\theta$ 的无偏估计量 $\\bar X = \\frac1n\\sum\\limits_{i=1}^n X_i$，其方差为 $\\mathrm{Var}(\\bar X) = \\frac{\\theta^2}n$ 达到 C-R 下限，故为有效估计，则为 UMVUE.\n\n通过以上例题，总结 UMVUE 的求法思路.\n\n1. 首先应明确，并不是所有的参数都有 UMVUE.\n\n2. 根据 Rao–Blackwell 定理，若 UMVUE 存在则一定是基于充分统计量的，故应先寻找参数的充分统计量.\n\n3. 确定待证明的统计量，一般基于充分统计量构造，然后进行无偏修正.\n\n4. 证明选择的统计量为 UMVE. 具体地，\n   1. 首先考虑 C-R 下限，因为该方法计算相对简单，一旦估计的方差达到下限，则立即说明其为 UMVUE. 但应注意方差达到 C-R 下限是 UMVUE 的充分不必要条件.\n   2. 由于指数族分布的优良性质，整理联合概率函数，证明其为指数族分布且有自然形式，并写出自然参数空间，使用定理3说明 UMVUE.\n   3. 若分布族不是指数族分布，则考虑使用完备统计量的定义说明完备性(例5)，然后利用 Lehmann–Scheffé 定理说明 UMVUE.\n   4. 使用 UMVUE 的充分必要条件 (定理1)，对 $E(\\varphi) = 0$ 两边求导，整理得到 $\\mathrm{Cov}(\\varphi, T) = 0$ 来证明.\n   5. 对于某些特殊的情况可以使用定义法直接说明其方差一致最小，但一般比较困难.\n   6. 若以上方法均无法证明，则考虑更换估计量，或者估计的 UMVUE 不存在.\n\n## 参考文献\n\n[1] 茆诗松, 程依明, 濮晓龙. 概率论与数理统计教程. 3版. 北京: 高等教育出版社, 2019.\n\n[2] 陈希孺. 数理统计引论. 北京：科学出版社, 1981.\n\n[3] 韦来生, 数理统计. 北京: 科学出版社, 2015.\n\n[4] 周伟萍, 关于一直最小方差无偏估计的教学思考, 高师理科学刊, 2013,33(06)\n\n[5] Charles Elkan, Rao-Blackwell Theorem: Intuition, Lemmas and Start of Proof\n","tags":["数理统计","UMVUE"],"categories":["science"]},{"title":"使用 Web 前端技术开发一个 Wallpaper Engine 壁纸","url":"/archives/44/","content":"\n本文基于实例介绍使用 Web 技术开发一个实用的 Wallpaper Engine 壁纸.\n\n<!--more-->\n\n### Wallpaper Engine 简介\n\nWallpaper Engine 是 Steam 上的一款收费买断软件，提供个性化的桌面壁纸，包括但不限于炫酷的动效、音视频及实用功能，具体可查看商店地址：[Wallpaper Engine：壁纸引擎](https://store.steampowered.com/app/431960/Wallpaper_Engine/).\n\n网络上也提供有盗版软件，个人情感上不推荐使用.\n\n### 一个实例\n\nWallpaper Engine 基于 [CEF](https://bitbucket.org/chromiumembedded/cef) 技术可以使开发者方便地使用 Web 开发技术快速开发属于自己的壁纸.\n\n我在去年简单开发了一款倒计时壁纸，主要有背景轮播、名言警句轮播、截止日期倒计时的功能，后来陆续添加了一些自定义功能，是一款实用壁纸.\n\n![倒计时壁纸](/assets/images/44-1.jpg)\n\n[壁纸 Steam 地址](https://steamcommunity.com/sharedfiles/filedetails/?id=2222111958)\n\n[壁纸 Github 源码](https://github.com/hooozen/WE-theme-Timer)\n\n---\n\n由于使用了 CEF，所以功能上的开发基本由 Web 前端技术实现，所以前期完全可以在本地浏览器上开发调试. 但要注意，由于产品最终是壁纸形态，所以不支持页面点击等交互方式.\n\nWeb 前端技术的内容不赘述，要想开发简单的壁纸大学网页设计课学的内容就够用，即使零基础可以面向百度编程很快上手，下面主要讲一下 Wallpaper Engine 提供的接口，以及我开发中遇到的一些问题.\n\n### Wallpaper Engine 开发流程\n\n对于 Wallpaper Engine 的开发流程，[官方文档](https://docs.wallpaperengine.io/en/web/overview.html)提供了较为详细和明确的内容，下面提纲挈领的介绍一下，以求对整个流程有个概览.\n\n#### 新建壁纸\n\n使用 Wallpaper Engine 的【壁纸编辑器】，可以新建和导入壁纸项目. 要注意的是，当你导入文件后，源文件会被复制到 steam 的特定目录下使用，所以修改原来目录下的文件不能实时生效.\n\nWallpaper Engine 在项目根目录提供 `project.json` 用以配置壁纸的一些信息，诸如名称、简介、和用户自定义项等.\n\n#### 自定义属性\n\n浏览文档可以发现，Wallpaper Engine 主要通过接口提供了**配置能力**，包括文本、数值、颜色、图片文件、音视频文件等配置项，这些配置项可以通过 `project.json` 文件配置也可以在【壁纸编辑器】中的“编辑”->“更改项目配置”的图形界面中配置. [文档详情](https://docs.wallpaperengine.io/en/web/customization/properties.html)\n\n```json\n/* project.json */\n{\n  \"contentrating\": \"Everyone\",\n  \"description\": \"some text\",\n  \"file\": \"index.html\",\n  \"general\": {\n    \"properties\": {\n      \"deadline\": {\n        \"index\": 1,\n        \"order\": 101,\n        \"text\": \"截止日期（YYYY-MM-DD）\",\n        \"type\": \"textinput\",\n        \"value\": \"\"\n      },\n      \"externalImages\": {\n        \"index\": 3,\n        \"mode\": \"fetchall\",\n        \"order\": 103,\n        \"text\": \"自定义背景\",\n        \"type\": \"directory\",\n        \"value\": \"\"\n      },\n      \"title\": {\n        \"index\": 0,\n        \"order\": 100,\n        \"text\": \"标题\",\n        \"type\": \"textinput\",\n        \"value\": \"\"\n      }\n      // ...\n    }\n  },\n  \"preview\": \"preview.jpg\",\n  \"tags\": [\n    \"Landscape\"\n  ],\n  \"title\": \"倒计时 —— 励志语句（自定义/考研/公考/高考/中考/年末）\",\n  \"type\": \"web\",\n  \"version\": 7,\n  \"visibility\": \"public\",\n  \"workshopid\": \"2222111958\",\n  \"workshopurl\": \"steam://url/CommunityFilePage/2222111958\"\n}\n```\n\n通过 `window.wallpaperPropertyListener` 中 `applyUserProperties` 方法监听用户属性的变化. 每次用户配置自定义属性时，该方法都会被调用来完成特定的交互逻辑：\n\n```js\nwindow.wallpaperPropertyListener = {\n  applyUserProperties: function (properties) {\n    if (properties.title) {\n      if (properties.title.value)\n        $('#targetYear').innerText = properties.title.value\n    }\n    if (properties.deadline) {\n      if (properties.deadline.value)\n        window.GOLOBAL.deadline.date = new Date(properties.deadline.value)\n    }\n    // ...\n  },\n}\n```\n\n上面的代码中，我通过 `title` 和 `deadline` 属性来接收用户自定义的标题和截止日期.\n\n对于目录属性，有两种获取模式（[文档详情](https://docs.wallpaperengine.io/en/web/customization/properties.html#directory-property)）：\n\n一种是 `ondemand`，该模式在需要时可以通过调用 `window.wallpaperRequestRandomFileForProperty(propertyName, callback)` 从选定的路径中随机获取一个文件路径.\n\n第二种是 `fecthall` 模式，该模式与其他所有属性不同，需要通过特有的方法 `userDirectoryFilesAddedOrChanged` 和 `userDirectoryFilesRemoved` 来分别监听：\n\n```js\nwindow.wallpaperPropertyListener = {\n  userDirectoryFilesAddedOrChanged: function (propertyName, changedFiles) {\n    // propertyName is the name of the property that triggered the event.\n    // changedFiles contains all added (or modified) file paths\n    GOLOBAL.batchImportImages(changedFiles)\n  },\n  userDirectoryFilesRemoved: function (propertyName, removedFiles) {\n    // propertyName is the name of the property that triggered the event.\n    // removedFiles contains all removed file paths\n    GOLOBAL.batchImportImages([])\n  },\n\n  applyUserProperties: function (properties) {\n    // listner normal properties\n  },\n}\n```\n\n在我的项目中，通过监听目录变化来调用我的 `batchImportImages` 方法实现用户自定义背景图片. （这里由于我只定义了一个目录属性，所以略去了属性名的判断，当使用了多个目录属性时要对其进行区分）\n\n#### 调试和发布\n\n在 Wallpaper Engine 的设置界面，通过配置“常规”->“开发人员”->“CEF 开发工具端口”，便可在 Chrome 浏览器（任意 Chromium 内核浏览器）中输入 `localhost:[port]` 进行调试. [文档详情](https://docs.wallpaperengine.io/en/web/debug/debug.html)\n\n开发完成后就可以发布到 Steam 创意工坊了，在【壁纸编辑器】中点击“创意工坊”->“在创意工坊上分享壁纸”，然后在弹出框对项目进行简单的说明即可发布. 这些项目说明的内容保存在 `project.json` 中.\n\n#### 一个小 Trick\n\nWallpaper Engine 只提供了媒体文件（图片/音/视频）的目录属性，无法导入文本文件. 可以通过修改后缀名和 JSONP 的方法实现文本文件的导入，这里给出思路，具体的实现不赘述了.\n\n### 其他问题\n\n前文提到新建或导入壁纸时，源文件会被复制后使用，这就需要你每次更改源文件后重新导入，这样开发和调试很不方便. 所以我的做法是，直接打开导入后的目录进行开发，这样即使不打开壁纸编辑器，只需要切换一下壁纸就能即使热更新和调试.\n\n`project.json` 中的 `workshopid` 是你的项目在创意工坊的唯一标识，这就意味着你每次更新时，会根据 `worksopid` 来选择更新到哪一个项目，这在开发多个壁纸和备份恢复时需要注意.\n","tags":["个人项目","Wallpaper Engine"],"categories":["developer"]},{"title":"多 Git 仓库的 SSH-key 配置","url":"/archives/43/","content":"\n本文介绍了在一个设备上配置多个 SSH-key 以用于不同的远程 Git 仓库的方法.\n\n<!--more-->\n\n### 问题背景\n\n当我们使用诸如 [GitHub](https://github.com/)、[码云](https://gitee.com/)等远程 Git 托管平台时，往往会配置账号中的 SSH-key 来方便进行拉取和推送仓库.\n\n典型的做法是使用 [`ssh-keygen -t rsa -c \"someCommentLikeEmail\"`](https://www.ssh.com/academy/ssh/keygen) 命令及其默认配置生成在路径 `~/.ssh` 下的 RSA 公钥和私钥文件：`id_rsa` 和 `id_rsa.pub`. 然后只需要把公钥文件中的内容复制粘贴到托管平台相应的位置即可. 这样一台设备的一个默认 RSA 密钥就能在多个不同的托管平台上使用了.\n\n但当我们使用了两个 Github 账号时（例如一个用于公司项目，一个用于个人项目），便不得不配置另一个密钥，因为在不同账号中配置相同的 RSA 公钥是不被允许的，如下图：\n\n![GitHub 不允许在不同账号下配置同一个 SSH key ](/assets/images/43-1.png)\n\n### 配置多 SSH key\n\n#### 1. 添加 RSA key\n\n仍然使用命令\n\n```bash\nssh-keygen -t rsa -c \"your@email.com\"\n```\n\n生成 RSA 密钥对，但在接下来的选项中指定一个不同的文件名，例如：\n\n```bash\nEnter file in which to save the key (/Users/userName/.ssh/id_rsa): /Users/userName/.ssh/new_rsa\n```\n\n这样就在 `~/.ssh` 目录下生成了一对新的 RSA 密钥：`new_rsa` 和 `new_rsa.pub`.\n\n#### 2. 密钥配置\n\n生成了新的密钥后，便可将新密钥成功添加到第二个 GitHub 账号. 但此时向第二个 Github 仓库推送更新仍然会显示无权限，因为若不经配置系统默认仍使用默认的密钥对 `id_rsa`.\n\n需要如下配置：\n\n在密钥目录 `~/.ssh/` 下编辑或新建配置文件 `config`，添加如下内容：\n\n```bash\nHost github.com\n  HostName github.com\n  IdentityFile ~/.ssh/id_rsa\n  User git\n\n\nHost alias\n  HostName github.com\n  IdentityFile ~/.ssh/new_rsa\n  User git\n```\n\n理解其中配置项就可以灵活配置更多的 SSH key 了：\n\n* `Host` 是我们**自己定义**的一个别名，用来更方便地指代 `HostName`.\n* `HostName` 是远程地址的域名，需要正确配置.\n* `IdentityFile` 指定使用该配置项中的域名（或别名）时所使用的密钥文件.\n* `User` 使用 SSH 时的用户名，对于远程 Git 仓库来说一般使用 `git`.\n\n以上第一个配置项，使域名为 `github.com` 的仓库默认使用 `id_rsa` 密钥对，第二个配置项为地址中使用了别名 `alias` 的仓库使用 `new_rsa` 密钥对\n\n#### 3. 使用别名配置仓库的远程地址\n\n配置完以上内容后，当我们使用 `alias` 作为登陆地址时会使用指定的 `new_rsa` 密钥，否则仍默认使用 `id_rsa` 密钥，因此我们需要对想要使用 `new_rsa` 密钥的仓库地址做修改. 例如：\n\n对于仓库地址为\n\n```bash\ngit@github.com:user_name/repository_name.git\n```\n\n的 GitHub 远程仓库，我们推送更新时系统仍默认使用 `id_rsa` 密钥，若想使用 `new_rsa` 密钥则需修改地址为：\n\n```bash\ngit@alias:user_name/repository_name.git\n```\n\n### 其他\n\n* 对于 Windows 用户需要注意 `.ssh` 目录的路径\n* config 不生效的话检查语法或尝试重启终端或设备后重试\n* 对于更多的密钥配置在 `~/.ssh/config` 文件中同理追加更多配置项即可\n","tags":["Tools","Git"],"categories":["developer"]},{"title":"熵与信息量","url":"/archives/42/","content":"\n本文主要结合公式和定义解释了信息熵（Entropy）和信息量（Quantities of information）的含义和联系.\n\n<!--more-->\n\n### 背景\n\n信息熵是由信息论之父，克劳德·艾尔伍德·香农（Claude Elwood Shannon）于 1948 年发表的论文《通信的数学理论》（[A Mathematical Theory of Communication](https://web.archive.org/web/19980715013250/http://cm.bell-labs.com/cm/ms/what/shannonday/shannon1948.pdf)）中提出.\n\n熵这个词是香农从热力学中借用的：热力学中的热熵是表示分子状态的混乱程度的物理量，香农则使用信息熵来描述信源的**不确定度**.\n\n**信息熵的提出解决了对信息的量化度量问题**.（应注意，信息量不等同于信息熵）\n\n### 定义\n\n**熵**（Entropy）：对于给定的离散随机变量 $X$，以可能性 $P(x_1), \\cdots, P(x_n)$ 取值为 $x_1, \\cdots, x_n$，则 $X$ 的熵为：\n\n$$ H(X) = -\\sum_{i=1}^nP(x_i)\\log_2 P(x_i) $$\n\n上述定义可以看出，熵是对于随机变量而言的，那么又是如何与信息量联系起来的呢？\n\n### 熵与信息量\n\n虽然我们有了信息熵的公式，但抽象且不容易理解. 应该如何理解信息熵呢？下面是维基百科中给出的一句解释：\n\n>In information theory, the entropy of a random variable is the average level of \"information\", \"surprise\", or \"uncertainty\" inherent in the variable's possible outcomes.\n\n也就是说，一个随机变量的熵是指该变量可能的结果所蕴含的**不确定性**的平均水平.\n\n举个例子，对于一枚不均衡的硬币，抛掷它时以概率 $p$ 正面朝上，以概率 $1-p$ 反面朝上. 则容易理解，当 $p=1/2$ 时，抛出一枚硬币的不确定性最大，即很难判断抛出后哪一面朝上；当 $p$ 接近 $1$（或 $0$）时，这种不确定性减小，直到 $p=1$（或 $p=0$）时不确定性最小，这时即使不抛该硬币，我们也确定的知道哪一面朝上.\n\n我们就用熵来定量衡量这种随机事件的不确定性，至于如何定量先不讨论，先来看看熵与信息量有什么联系.\n\n信息论中有一句常见的口诀：“不确定性越多（概率越低），信息量越大；不确定性越低（概率越高），信息量越小“，也就是对信源来说，所发出的信号对于接受者可以看作随机变量，接受者在接受前对该变量的不确定性越大，则接收到后所“消除”的不确定越大，则获得的信息量越大.\n\n举个例子：你**知道**你每天起床后你妈**一定**会对你说：“你看你像猪一样起这么晚！”，这句话对你来说没有任何不确定性（概率为 $1$），那么你听到这句话后也就不会消除任何不确定性，也即没有获得信息量. 然后你还知道，你妈接下来会告诉你早餐吃什么，虽然不是包子就是油条. 这时你妈开口了：“还不快点起，包子都凉了！”，在你听到这句话前对于你妈这句话说什么是有不确定性的，你不知道是“包子都凉了”还是“油条都软了”，因此你妈的这句话消除了你对于吃包子还是吃油条的不确定性，你因此获得了一定的信息量.\n\n以上通俗的解释了“熵”、“信息量”的概念，但需要注意的是信息熵不等同于信息量，但它们在量上是相等的. 即，“熵”度量了不确定性，而接受信息后所消除的不确定性即为该信息的“量”.\n\n信息量和熵都是相对于某一主体来说的，即同一个信息对于不同的人而言信息量不同，同一件不确定的事情对于不同的人所蕴含的熵也不同.\n\n### 定量\n\n以上定性的解释了“熵”的含义，那么公式中熵的值是怎么确定的呢？\n\n类似于质量、长度等物理量，信息熵同样作为物理量也需要有一个基本度量单位. 类似于光年作为长度单位被定义为光行驶一年的长度，熵的基本单位被定义为等概率 $0-1$ 分布随机变量的不确定性，记作 $1\\mathrm{bit}$. 也就是说抛一枚均匀的硬币，对于哪面朝上这一事件包含的不确定性的量是 $1\\ \\mathrm{bit}$ 熵.\n\n有了基本单位，衡量其他随机变量的熵就有了基准，类似于光行驶 $3$ 年的距离为 $3$ 光年，那么抛掷 $2$ 均匀枚硬币结果的不确定性即为 $2\\ \\mathrm{bit}$. 容易理解，对于抛掷 $n$ 枚硬币而言，其熵为 $n\\ \\mathrm{bit}$. 因此，所有与抛掷硬币分布相同的随机变量其熵都可以被类似的计算.\n\n对于等概率事件仍可以类似量化，比如对于猜一道有四个选项的选择题的答案，那么四个答案的概率均等分布，与先后掷两枚硬币的分布是等同的，因此其熵为 $2\\ \\mathrm{bit}$. 类似地，对于有 $8 = 2^3$ 个等可能结果的分布，与掷 $3$ 枚硬币等同，其熵为 $\\log_2 8 = 3\\ \\mathrm{bit}$. 将其**推广**至有 $n$ 个等可能结果的概率分布，其熵为\n\n$$\n\\log_2n = \\log_2\\frac1{p} \\ \\mathrm{bit}\n$$\n\n其中 $p = \\frac 1n$ 为每个结果发生的概率.\n\n至此，已经解决了等概率分布的随机变量的熵的计算，那么对于不等概率的分布将如何计算呢？公式中展示出了加权的思想，即把每一个结果都看作等可能事件中的一个结果，按照其发生的概率加权求和.\n\n例如，通过某些“手段”答题人得知选项 A、B、C、D 为正确答案的概率分别为 $\\frac12,\\frac14,\\frac18,\\frac18$，那么此时如何求熵呢？首先把 A 选项看作投掷一枚硬币某一面朝上，对应的熵为 $1\\ \\mathrm{bit}$，但 A 为正确答案的可能性只有 $\\frac 12$，因此将 $\\frac12$ 作为 $1\\ \\mathrm{bit}$ 的权值. 类似地，得到 B、C、D 对应的数值项：$\\frac14 \\log_24$，$\\frac18\\log_2 8$，$\\frac18\\log_28$. 将以上各项相加就得到此时正确答案 $X$ 的熵：\n\n$$ \\begin{aligned}\nH(X) &= \\frac12\\log_2 2 + \\frac14\\log_24+\\frac18\\log_28 + \\frac18\\log_28 \\\\\n& = -\\frac12\\log_2\\frac12 - \\frac14\\log_2\\frac14- \\frac18\\log_2\\frac18 - \\frac18\\log_2\\frac18 \\\\\n& = -\\sum_{i=1}^4P(x_i)\\log_2P(x_i)\n\\end{aligned}\n$$\n\n至此，便得到了熵的定义中的公式形式.\n\n$$\n\\begin{aligned}\nH(X) & = \\sum_{i=1}^nP(x_i)\\log_2\\frac1{P(x_i)} \\\\\n&= -\\sum_{i=1}^nP(x_i)\\log_2 P(x_i)\n\\end{aligned}\n$$\n\n### 性质\n\n香农总结出了信息熵的三条性质：\n\n1. 单调性，即发生概率越高的事件，其所携带的信息熵越低.\n2. 非负性，即信息熵不能为负.\n3. 累加性，即多随机事件同时发生的的总不确定性的度量可以表示为各事件不确定性的度量的和，也即：\n\n  对于相互独立的随机变量 $X,Y$：\n  $$ P(X=A, Y=B) = P(X=A)\\cdot P(Y=B) $$\n  有:\n  $$ H(XY) = H(X) + H(Y) $$\n\n香农从数学上，严格证明了满足上述三个条件的随机变量不确定度量具有唯一的形式：\n\n$$ H(X) = -C\\sum_{x\\in \\mathcal{X}} P(x)\\log_2P(x) $$\n\n### 信息量（Quantities of information）\n\n信息量是衡量信息多少的度量，其值等于获得该信息后减少的随机变量不确定性量.\n\n例如，对于一个有四个选项的选择题，我根本不会做，则正确答案对应的随机变量 $X$ 的熵 $H_1(X)$ 为\n\n$$\n-\\sum_{i=1}^4 P(x_i)\\log_2P(x_i) = -4\\times\\frac14\\times \\log_2\\frac14 = 2\\ \\mathrm{bit}\n$$\n\n若此时老师说 A 选项是错的，不选，根据公式则有\n$$\nH_2(X) = -3\\times\\frac13\\times\\log_2\\frac13 \\approx 1.5850\\ \\mathrm{bit}\n$$\n\n那么老师这句话带给我的信息量则为:\n\n$$H_1(X) - H_2(X) \\approx 0.4150\\ \\mathrm{bit}$$\n\n如果我的同桌小农一开始就知道这题选 D，那么关于这道题答案的熵对于他来说即为 $0$，老师的话对于他来说信息量为 $0$. （当然这里讨论的假设必须都是客观的：小农是真正的知道正确答案，而不是错误的知道“正确答案”，即熵和信息量作为物理量虽然相对于主客体的不同而不同，但具有不以主观意志转移的客观性）\n\n---\n\n#### *参考资料*\n\n* [Entropy (information theory), wikipedia.org](https://en.wikipedia.org/wiki/Entropy_(information_theory))\n\n* [Quantities of information, wikipedia.org](https://en.wikipedia.org/wiki/Quantities_of_information)\n\n* [信息熵, 百度百科](https://baike.baidu.com/item/%E4%BF%A1%E6%81%AF%E7%86%B5/7302318?fr=aladdin)\n  \n* [“信息熵是什么？”，知乎](https://www.zhihu.com/question/22178202)\n","tags":["信息熵","信息量"],"categories":["science"]},{"title":"Swift 函数作为参数的写法","url":"/archives/41/","content":"\n本文主要介绍 Swift 中函数作为参数传递的几种写法.\n\n<!--more-->\n\nSwift 作为一种强类型语言，其语法却有非常灵活的写法. 类似于 JavaScrip 等现代语言，Swift 也具备闭包（closure）的机制，并且函数作为一种数据类型，可以很方便的作为参数传递给目标函数.\n\n下面举一个例子对于这种情况的几种写法做一下记录.\n\n函数 `hasAnyMatches` 接受两个参数，第一个接受一个整型数组，第二个接受一个函数，检查数组中的元素，若有任意一个元素通过参数 2 函数的检查，则返回 `true`，否则返回 `false`.\n\n```swift\nfunc hasAnyMatches(list: [Int], condition: (Int)->Bool) -> Bool {\n  for item in list {\n    if condition(item) {\n      return true\n    }\n  }\n  return false\n}\n```\n\n我们写一个函数用以检查数组中是否有小于 10 的数，有以下几种写法\n\n1. 有名函数作为参数传递\n\n    ```swift\n    func lessThanTen(number: Int) -> Bool {\n      number < 10  // 单行代码可省略 return，认为返回该行的值\n    }\n\n    hasAnyMatches(list: numbers, condition: lessThanTen)\n    ```\n\n2. 内敛匿名函数作为参数\n\n    使用 `{}` 包裹匿名函数，并使用 `in` 分隔返回类型和函数题：\n\n    ```swift\n    hasAnyMatches(list: numbers, condition: {(number: Int) -> Bool in\n        number < 10\n    })\n    ```\n\n3. 内联写法的省略形式\n\n    当函数作为最后一个参数时，可以将匿名函数拿到调用函数的小括号外：\n\n    ```swift\n    hasAnyMatches(list: numbers) {(number: Int) -> Bool in\n        number < 10\n    }\n    ```\n\n4. 内敛写法的进一步省略\n\n    Swift 虽为强类型语言，单当类型可以被推断时，则可省略关于类型的声明：\n\n    ```swift\n    hasAnyMatches(list: numbers) {number in\n        return number < 10\n    }\n    ```\n\n*参考*\n\n[A Swift Tour](https://docs.swift.org/swift-book/GuidedTour/GuidedTour.html)\n","tags":["swift"],"categories":["developer"]},{"title":"数据结构基础（4）线性表的顺序存储结构——顺序表","url":"/archives/39/","content":"\n本文主要介绍了线性表的顺序存储结构，以及基于 C++ 的具体实现.\n\n<!--more-->\n\n***目录（更新中）***\n\n* 第一章 绪论\n\n    [(1) 数据结构的基本概念](https://www.hozen.site/archives/36/)\n\n    [(2) 算法及算法分析](https://www.hozen.site/archives/37/)\n\n* 第二章 线性表\n\n    [(3) 线性表的逻辑结构](https://www.hozen.site/archives/38/)\n\n    **(4) 线性表的顺序存储结构——顺序表**\n\n*参考资料*\n\n[1] 王红梅编著. 数据结构（C++版本）（第2版）. 北京：清华大学出版社，2011.\n\n[2] 钱能著. C++ 程序设计教程（第二版）. 北京：清华大学出版社，2005.\n\n***\n\n### 顺序表（sequential list）\n\n**线性表**的顺序存储结构称为**顺序表**.\n\n需要辨析的是，线性表的链接存储结构被称为**链表**，链表又分为**单链表**、**循环链表**、**双链表**等，他们都是**线性表**属于**线性结构**的分类. 本文讨论的是顺序表.\n\n![图 4-1 数据结构的分类](/assets/images/39-1-n.png)\n\n顺序表是用一段**地址连续**的存储单元依次存储线性表的数据元素.  由于线性表中每个数据元素的类型相同，通常用一维数组来实现顺序表，也就是把线性表中相邻的元素存储在数组中相邻的位置.\n\n### 顺序表的实现\n\n将线性表的抽象数据类型定义用 C++ 的类实现，由于线性表的数据元素类型不确定，所以采用 C++ 的**模板机制**.\n\n这里我们规定顺序表序号从 $1$ 开始，因此与数组的下标相差 $1$.\n\n```C++\nconst int MaxSize = 100;\n\ntemplate <typename DataType>\nclass SeqList {\n public:\n  SeqList();\n  SeqList(DataType a[], int n);\n  ~SeqList(){};\n  int getLength();\n  DataType get(int i);\n  int locate(DataType x);\n  void insert(int i, DataType x);\n  DataType remove(int i);\n  void printList();\n\n private:\n  DataType data[MaxSize];\n  int length = 0;\n};\n```\n\n下面实现成员函数：\n\n#### 构造函数\n\n* 无参构造函数 `SeqList()`\n\n    创建一个空顺序表.\n\n    ```C++\n    template <typename DataType>\n    SeqList<DataType>::SeqList() {\n        length = 0;\n    }\n    ```\n\n* 有参构造函数 `Seqlist(DataType a[], int n)`\n\n    使用传入的数组构造顺序表，并指定顺序表长度.\n\n    ```C++\n    template <typename DataType>\n    SeqList<DataType>::SeqList(DataType a[], int n) {\n        if (n > MaxSize) throw \"参数非法\";\n\n        for (int i = 0; i < n; i++)\n        data[i] = a[i];\n\n        length = n;\n    }\n    ```\n\n#### 求线性表的长度\n\n```C++\ntemplate <typename DataType>\nint SeqList<DataType>::getLength() {\n    return length;\n}\n```\n\n#### 查找操作\n\n* 按位查找 `get(int i)`\n\n    由于使用数组存储数据，则查找第 `i` 个元素直接返回数组 `data[]` 中的第 `i - 1` 个元素. 时间复杂度为 $O(1)$.\n\n    ```C++\n    template <typename DataType>\n    DataType SeqList<DataType>::get(int i) {\n      if (i < 1 && i > length)\n        throw \"查找位置非法\";\n      return data[i - 1];\n    }\n    ```\n\n* 按值查找 `locate(DataType x)`\n\n    对顺序表进行遍历，返回第一个匹配元素的序号（注意不是数组下标）；如果查找不到该值则返回失败的标志 `0`.\n\n    ```C++\n    template <typename DataType>\n    int SeqList<DataType>::locate(DataType x) {\n      for (int i = 0; i < length; i++)\n        if (data[i] == x) return i + 1;\n      return 0;\n    }\n    ```\n\n    平均情况下，假设数据平均分布，时间复杂度为 $O(n)$.\n\n#### 插入操作\n\n注意插入位置的合法性. 同时由于插入后元素的逻辑关系发生改变，所以应由存储关系反应这一变化，即调整相应元素在数组中的位置.\n\n```C++\ntemplate <typename DataType>\nvoid SeqList<DataType>::insert(int i, DataType x) {\n    if (length > MaxSize - 1)\n    throw \"顺序表已满，无法插入\";\n    if (i < 1 || i > length + 1)\n    throw \"非法位置\";\n\n    for (int j = length; j > i - 1; j--)\n    data[j] = data[j - 1];\n\n    length++;\n    data[i - 1] = x;\n}\n```\n\n同理考虑时间复杂度，为 $O(n)$.\n\n#### 删除操作\n\n同理考虑位置的合理性，并且通过调整存储关系来反映逻辑关系的变化.\n\n时间复杂度为 $O(n)$.\n\n```C++\ntemplate <typename DataType>\nDataType SeqList<DataType>::remove(int i) {\n    if (i < 1 || i > length)\n    throw \"非法位置\";\n\n    DataType temp = data[i - 1];\n\n    for (int j = i - 1; j < length; j++)\n    data[j] = data[j + 1];\n\n    length--;\n    return temp;\n}\n```\n\n#### 遍历操作\n\n按顺序打印顺序表中的元素. 以可直接打印的数据类型为例.\n\n```C++\ntemplate <typename DataType>\nvoid SeqList<DataType>::printList() {\n    for (int i = 0; i < length; i++)\n    std::cout << data[i] << \" --> \";\n\n    std::cout << \"end\";\n}\n```\n\n显然时间复杂度为 $O(n)$\n","tags":["数据结构","线性表","顺序表","C++"],"categories":["developer"]},{"title":"数据结构基础（3）线性表的逻辑结构","url":"/archives/38/","content":"\n本文主要介绍了线性结构的典型代表——线性表的逻辑结构和抽象数据结构.\n\n<!--more-->\n\n***目录（更新中）***\n\n* 第一章 绪论\n\n    [(1) 数据结构的基本概念](https://www.hozen.site/archives/36/)\n\n    [(2) 算法及算法分析](https://www.hozen.site/archives/37/)\n\n* 第二章 线性表\n\n    **(3) 线性表的逻辑结构**\n\n    [(4) 线性表的顺序存储结构——顺序表](https://www.hozen.site/archives/39/)\n\n*参考资料*\n\n[1] 王红梅编著. 数据结构（C++版本）（第2版）. 北京：清华大学出版社，2011.\n\n[2] 张铭. [coursera-数据结构基础](https://www.coursera.org/learn/shuju-jiegou-suanfa). coursera.\n\n***\n\n### 线性结构\n\n根据前文的讨论，数据结构主要有集合、线性结构、树结构、图结构四大类，本文要讨论的**线性表**正是线性结构的典型代表.\n\n除线性表外，线性结构用可根据不同标准分为许多类型：\n\n**按复杂程度划分**\n\n* 简单的：线性表、栈、队列、散列表\n* 高级的：广义表、多维数组、文件……\n\n**按访问方式划分**\n\n* 直接访问型（direct access)\n* 顺序访问型（sequential access）\n* 目录索引型（directory access）\n\n**按操作划分**\n\n* 线性表\n* 栈\n* 队列\n\n本文讨论的**线性表**是**线性结构**的**典型代表**.\n\n![图 3-1 数据结构的分类](/assets/images/39-1-n.png)\n\n### 线性表的定义\n\n**线性表**（linear list）简称表，是 $n(n\\geqslant 0)$ 个具有相同类型的数据元素的有限序列，线性表中数据元素的个数称为线性表的**长度**. 长度等于零时称为空表，一个非空表通常记为：\n\n$$ L=(a_1, a_2, \\cdots, a_n) $$\n\n![图 3-2 线性表示意图](/assets/images/38-2.jpg)\n\n其中，$a_i(1\\leqslant i \\leqslant n)$ 称为数据元素，小脚标 $i$ 表示该元素在线性表中的位置或序号.  任意一堆相邻的数据元素 $a_{i-1}$ 和 $a_i(1<i\\leqslant n)$ 之间存在**序偶关系** $<a_{i-1}, a_i>$ ，且 $a_{i-1}$ 称为 $a_i$ 的**前驱**， $a_i$ 称为 $a_{i-1}$ 的**后继**.\n\n线性表的数据元素具有抽象（即不确定）的数据类型，在具体的应用程序中被具体的数据类型所替代.\n\n具体地，线性表具备以下特点：\n\n1. **均匀性**：虽然不同线性表的数据元素可以是各种各样的，但对于同一线性表的各数据元素必定具有相同的数据类型和长度.\n\n2. **有序性**：各数据元素在线性表中都有自己的位置，且数据元素之间的相对位置是线性的.\n\n### 线性表的抽象数据类型定义\n\n线性表应当满足存取访问、插入和删除等操作. 可将其抽象数据类型定义如下：\n\n```adt\n\nADT List\n  Data\n    线性表中的数据元素具有相同的类型，相邻元素具有前驱和后继关系.\n\n  Operation\n\n    InitList\n      前置条件：线性表不存在\n      输入：无\n      功能：线性表的初始化\n      输出：无\n      后置条件：一个空的线性表\n\n    DestoryList\n      前置条件：线性表已存在\n      输入：无\n      功能：销毁线性表\n      输出：无\n      后置条件：释放线性表所占用的存储空间\n\n    Length\n      前置条件：线性表已存在\n      输入：无\n      功能：求线性表的长度\n      输出：线性表中数据元素的个数\n      后置条件：线性表不变\n\n    Get\n      前置条件：线性表已存在\n      输入：元素的序号 i\n      功能：按位查找，在线性表中查找序号为 i 的数据元素\n      输出：若序号合法，返回序号为 i 的元素值，否则抛出异常\n      后置条件：线性表不变\n\n    Locate\n      前置条件：线性表已存在\n      输入：数据元素 x\n      功能：按值查找，在线性表中查找值等于 x 的元素\n      输出：若查找成功，返回元素 x 在表中的序号，否则返回 0\n      后置条件：线性表不变\n\n    Insert\n      前置条件：线性表已存在\n      输入：插入位置 i；待插元素 x\n      功能：插入操作，在线性表的第 i 个位置插入一个新元素 x\n      输出：若插入不成功，抛出异常\n      后置条件：若插入成功，表中增加了一个新元素\n\n    Delete\n      前置条件：线性表已存在\n      输入：删除位置 i\n      功能：删除操作，删除线性表中的第 i 个元素\n      输出：若删除成功，则返回被删元素，否则抛出异常\n      后置条件：若删除成功，表中减少被删元素\n\n    IsEmpty\n      前置条件：线性表已存在\n      输入：无\n      功能：判空操作，判断线性表是否为空\n      输出：若是空表，返回 1，否则返回 0\n      后置条件：线性表不变\n\n    PritList\n      前置条件：线性表已存在\n      输入：无\n      功能：遍历操作，按序号依次输出线性表中的元素\n      输出：线性表中的各个数据元素\n      后置条件：线性表不变\n\nendADT\n```\n\n需要注意的是：\n\n1. 对于不同的应用，线性表包含的基本操作可能不同，同名操作的实现细节可能不能.\n\n2. 对于实际问题中更复杂的操作，可以用这些基本操作的组合来实现. 如按值删除，可以通过上述定义的 `Locate` 和 `Deleta` 操作的组合实现.\n","tags":["数据结构","线性表"],"categories":["developer"]},{"title":"数据结构基础（2）算法及算法分析","url":"/archives/37/","content":"\n本文主要讲述了算法的基本概念和算法的分析方法，主要包括算法的时间复杂度分析.\n\n<!--more-->\n\n***目录（更新中）***\n\n* 第一章绪论\n\n    [(1) 数据结构的基本概念](https://www.hozen.site/archives/36/)\n\n    **(2) 算法及算法分析**\n\n* 第二章 线性表\n\n    [(3) 线性表的逻辑结构](https://www.hozen.site/archives/38/)\n\n    [(4) 线性表的顺序存储结构——顺序表](https://www.hozen.site/archives/39/)\n\n*参考资料*\n\n[1] 王红梅编著. 数据结构（C++版本）（第2版）. 北京：清华大学出版社，2011.\n\n[2] 张铭. [coursera-数据结构基础](https://www.coursera.org/learn/shuju-jiegou-suanfa). coursera.\n\n***\n\n### 算法（Algorithm）\n\n#### 概述\n\n算法被公认为是计算机科学的基石.\n\n通俗地讲，算法是解决问题的方法. 现实生活中算法的实例不胜枚举，如一道菜谱、一个安装转移的操作指南等.\n\n严格地说，算法是对特定问题求解步骤的一种描述，是指令的有限序列.\n\n通常一个问题可以有多种算法，一个算法可以解决某个特定的问题.\n\n算法必须满足以下 5 个重要特性：\n\n1. **输入**：一个算法有零个或多个输入，这些输入通常取自于某个特定的对象集合.\n\n2. **输出**：一个有一个或多个输出，通常输出与输入之间有着某种特定的关系.\n\n3. **有穷性**：一个算法必须总是（对任何合法的输入）在执行有穷步之后结束，且每一步都在有穷时间内完成.\n\n4. **确定性**：算法中每一条指令必须有确切的含义，不存在二义性。并且，在任何条件下，对于相同的输入只能得到相同的输出.\n\n5. **可行性**：算法描述的操作过程可以通过已经实现的基本操作执行有限次来实现.\n\n算法和程序不同. 原则上，算法可以用任何一种程序设计语言实现.\n\n算法的有穷性意味着并不是所有的计算机程序都是算法，例如操作系统是一个在无限循环中执行的程序而不是一个算法. 然而我们可以把操作系统的各个任务看成是一个单独的问题，每一个问题由操作系统中的一个子程序通过特定的算法来实现，得到输出结果后便终止.\n\n#### 优良性\n\n一个“好\"算法首先要满足算法的五大特性，此外还要具备下列特性.\n\n1. **正确性**：对于任何合法的输入，算法都会得出正确的结果.\n\n2. **鲁棒性**：也称健壮性，算法对非法输入的抵抗能力，即对于错误的输入，算法应能是被并做处理，而不是产生错误动作或陷入瘫痪.\n\n3. **简单性**：算法容易理解和实现.\n\n4. **抽象分级**：为了时算法便于阅读、理解、使用和修改，应使用抽象分级来组织算法表达的思想. 换言之，算法中的每一条逻辑步骤可以是一条简单的指令，也可以是一个模块，通过模块调用完成相应功能. 每个模块表示一种抽象，模块的内部描述了怎样实现抽象，而模块的名称描述了模块的功能.\n\n5. **高效性**：算法的效率包括时间效率和空间效率.\n\n#### 描述方法\n\n常用的描述算法的方法有：\n\n* 自然语言：容易理解；但准确性不佳，容易出现二义性.\n\n* 流程图：直观易懂；但严密性和灵活性欠佳，在描述复杂算法时极不方便.\n\n* 程序设计语言：能直接由计算机执行；但抽象性差，往往拘泥于描述算法的具体细节，容易失去算法的整体观，还要求算法设计者熟练掌握程序设计语言及其编程技巧.\n\n* **伪代码**：表达能力上类似于编程语言，同时极小化了描述算法所不必要的技术细节，比较适合描述算法，被称为“**算法语言**”或“**第一语言**”.\n\n伪代码（pseudo-code）是介于自然语言和程序设计语言之间的方法，它采用某一程序设计语言的基本语法，操作指令可以结合自然语言来设计. 至于算法中自然语言的成分有多少，取决于算法的抽象级别：往往抽象级别越高自然语言使用得越多.\n\n### 算法分析\n\n#### 时间复杂度\n\n显然，事后统计的方法可以准确的计算一个算法的效率. 但该方法至少有以下缺点：\n\n1. 编写程序实现算法将花费较多时间和精力，若事后统计发现算法效率并不理想，则编写程序的成分白白浪费.\n\n2. 所的实验结果依赖于计算机的软硬件等客观环境，有时容易掩盖算法本身的优劣.\n\n因此，我们通常采用事前分析估算的方法——**渐进复杂度**（**symptotic complexity**）.\n\n### 算法的时间复杂度\n\n撇开与计算机软硬件有关的因素，影响算法时间代价的最主要因素是问题规模. 问题规模（problem scope）是指输入量的多少，一般来说，它可以从问题描述中得到.\n\n显然，算法运行的时间 $T$ 是问题规模 $n$ 的函数，记作 T(n).\n\n要精确表示算法的运行时间函数是很困难的，且即使能够给出往往也是个相当复杂的函数，这与我们摒弃“事后统计”的方法，希望通过“估算”来节约成本的原则违背. 在准确度与效率之间，“渐进时间复杂度”取得了一个良好的平衡.\n\n渐进时间复杂度通过衡量算法中**基本语句**（basic statement）执行的次数，并且只关心其中随着问题规模增大对时间成本贡献最大的部分. 类似于高数中对于一个由多项式给出的无穷大，很多情况下，我们只需关注其中最高阶无穷大项即可.\n\n*高数中，对于极限 $\\lim\\limits_{x\\to+\\infty}(x^4 + 100 x^3 + 1)$，我们知道随着 $x$ 的增大，第二项 $100x^3$ 对于整个多项式增大的贡献逐渐小于 $x^4$，直至可以忽略.*\n\n由以上讨论，我们给出渐近时间复杂度分析的常用方法：\n\n1. **大 $O$ 表示法**：若存在常数 $c,N > 0$，对于任意 $n\\geqslant N$ 时，都有 $T(n)\\leqslant c\\times f(n)$，则称 $T(n)=O(f(n))$，或称 $T(n)$ 在 $O(f(n))$ 中.\n\n2. **大 $\\Omega$ 表示法**：若存在常数 $c,N > 0$，对于任意 $n\\geqslant N$ 时，都有 $T(n)\\geqslant c\\times f(n)$，则称 $T(n)=\\Omega(f(n))$，或称 $T(n)$ 在 $\\Omega(f(n))$ 中.\n\n3. **大 $\\Theta$ 表示法**：若 $T(n)$ 既在 $O(f(n))$ 中，又在 $\\Omega(n)$ 中，则称 $T(n)$ 在 $\\Theta(n)$ 中. 更具体地，若存在常数 $c_1, c_2, N >0$，对于任意 $n\\geqslant N$ 时，都有 $c_1f(n) \\leqslant T(n) \\leqslant c_2f(n)$，则称 $T(n)=\\Theta(f(n))$，或称 $T(n)$ 在 $\\Theta(f(n))$ 中.\n\n不难理解：\n\n* 大 $O$ 表示法给出算法时间复杂度的渐近上限，大 $\\Omega$ 表示法给出渐近下限.\n* 大 $O$ 和大 $\\Omega$ 表示法往往是不唯一的. 为了尽可能精确，往往选择上（下）限中最“紧”的那个.\n* 当 $T(n) = O(f(n)) = \\Omega(f(n))$ 时，有 $T(n)=\\Theta(f(n))$.\n\n其中大 $O$ 表示法最为常用，且往往选择最“紧”的那个上限，即选择所有上限中最小的.\n\n对于大 $O$ 表示法，容易得到如下规则：\n\n1. **加法规则**\n$$T_1(n)+T_2(n) = O\\left(\\max\\{T_1(n), T_2(n)\\}\\right) $$\n\n2. **乘法规则**\n$$T_1(n)\\cdot T_2(n) = O\\left(T_1(n)\\cdot T_2(n)\\right) $$\n\n#### 最好、最坏和平均情况\n\n对于某些算法，即使问题规模相同，如果输入数据不同，其时间开销也不同.\n\n例如，在一维整型数组 $A[n]$ 中顺序查找与给定值 $k$ 相等的元素：\n\n```c++\n/**\n * @param int[] 待查数组\n * @param int 数组长度\n * @returns 元素 k 的下标，返回 n 时表示查找失败\n */\nint Find(int A[], int n) {\n  for (i = 0; i < n; i++)\n    if (A[i] == k) break;\n  return i;\n}\n```\n\n对于输入的数组 $A[]$，如果第一个元素恰好等于 $k$，算法只需要比较一次，这是**最好的情况**；如果直到最后一个元素才等于 $k$，则算法需要比较 $n$ 次，这是**最坏情况**.\n\n显然直接使用**最好情况**来估计算法性能是不合理的，因为它发生的概率往往是很小的，得到的结果将过于乐观了；当然**最坏情况**发生的概率往往也很小，但估计最坏情况下的算法性能是有意义的，即据此来保证某些系统的可靠性.\n\n算法往往是对不同数据进行多此执行的，因此考虑**平均情况**是有必要的. 从概率统计的角度来讲，我们需要知道输入数据的分布情况，以此估计算法性能的“均值”.\n\n比如，上例中，当我们知道 $k$ 极大概率出现在第一个元素位置时，使用**最好情况**估算性能是合理的. 当我们对数据的分布一无所知时，采用“等同无知”原则，认为各数据元素是等概率分布的，则上例中平均要比较 $\\frac n2$ 个元素.\n\n#### 空间复杂度（space complexity）\n\n算法的空间复杂度是指在算法的执行过程中，需要的辅助空间数量，即除算法本身和输入输出数据所占据的空间外，算法临时开辟的存储空间，通常记作：\n\n$$ S(n) = O(f(n)) $$\n\n其中，$n$ 为问题规模，分析方法与算法的时间复杂度类似.\n","tags":["数据结构","时间复杂度"],"categories":["developer"]},{"title":"数据结构基础（1）数据结构的基本概念","url":"/archives/36/","content":"\n本文主要讲述了数据结构的基本概念及相关的理论基础，是“由远及近”认识数据结构的简要浏览.\n\n<!--more-->\n***目录（更新中）***\n\n* 第一章 绪论\n\n    **(1) 数据结构的基本概念**\n\n    [(2) 算法及算法分析](https://www.hozen.site/archives/37/)\n\n* 第二章 线性表\n\n    [(3) 线性表的逻辑结构](https://www.hozen.site/archives/38/)\n\n    [(4) 线性表的顺序存储结构——顺序表](https://www.hozen.site/archives/39/)\n\n*参考资料*\n\n[1] 王红梅编著. 数据结构（C++版本）（第2版）. 北京：清华大学出版社，2011.\n\n***\n\n## 程序设计与数据结构\n\n计算机不能分析问题并产生解决问题的方案，必须由人（程序设计者）分析问题，确定问题的解决方案，编写程序，让计算机执行从而获得问题的解. 从问题的给出到计算机程序的编写执行，便是程序设计的一般过程.\n\n分析问题的过程中，需要抽象出具体的数据模型（待处理的数据以及数据之间的关系，即数据结构），形成问题求解的基本思路.\n\n$$ 数据结构 + 算法 = 程序 $$\n\n这个由图灵奖获得者沃思给出的，广为流传的公式，说明了程序设计的核心.\n\n具体来讲，数据结构到底是什么呢？如何从问题中抽象呢？\n\n### 非数值问题\n\n计算机能够求解的问题一般可分为数值和非数值问题.\n\n数值问题抽象出的数据模型通常是数学方程，这一过程对于做过数学应用题的人来讲都是容易理解的，如小学用方程组解“鸡兔同笼”问题，其中线性方程组便是对问题中数据的抽象模型.\n\n非数值问题抽象出的数据模型通常是**线性表**、**树**、**图**等数据结构，其抽象过程虽然仍然有其数学理论基础，但对大多数人来说并不了解、或有难度，故一般而言，数据结构教程通常着重于分析和解决**非数值问题**，即重点在于线性表、树和图这三种数据结构. 例如学籍管理、人机对弈、教学计划编排问题可以分别抽象出线性结构、树结构、图结构.\n\n## 数据结构的基本概念\n\n### 数据结构\n\n**数据**（data) 是信息的载体，在计算机科学中是指所有能输入到计算机中并能被计算机程序识别和处理的符号集合.\n\n**数据元素**（data element）是数据的基本单位.\n\n**数据结构**（data structure）是指相互之间存在一定关系的数据元素的集合.\n\n按照视点不同，数据结构分为逻辑结构和存储结构.\n\n#### 数据的逻辑结构（logical structrue)\n\n数据的逻辑结构是指数据元素之间逻辑关系的**整体**。数据的逻辑结构在形式上可以定义为一个[二元组](https://baike.baidu.com/item/%E5%A4%9A%E5%85%83%E7%BB%84)([2-tuple](https://en.wikipedia.org/wiki/Tuple))：\n\n$$ Data\\_Structure = (D, R) $$\n\n其中 $D$ 是数据元素的有限集合，$R$ 是 $D$ 上关系的集合.\n\n根据数据元素之间逻辑关系的不同，数据结构分为以下四类：\n\n1. 集合：数据元素之间就是“属于同一个集合”，除此之外，**没有任何关系**.\n2. 线性结构：数据元素之间存在着**一对一**的线性关系.\n3. 树结构：数据元素之间存在着**一对多**的层次关系.\n4. 图结构：数据之间存在着**多对多**的任意关系.\n\n树结构和图结构也称为非线性结构.\n\n数据的逻辑结构常用逻辑关系图来描述：\n\n1. 将每一个数据元素看作一个结点，用圆圈表示；\n2. 元素间的逻辑关系用结点之间的连线表示;\n3. 如果强调关系的方向性，则用带箭头的连线表示.\n\n![图 1-1 数据结构的逻辑关系图](/assets/images/36-1.jpg)\n\n#### 数据的存储结构（storage structure）\n\n数据的存储结构又称为物理结构，是数据及其逻辑结构在计算机中的表示. 存储结构除了存储数据元素外，必须隐式或显式的存储数据元素之间的逻辑关系.\n\n通常有两种存储结构：顺序存储结构和链接存储结构.\n\n顺序存储结构：用一组**连续**的存储单元**依次**存储数据元素，数据源之间的逻辑关系由元素的存储位置（隐式）表示.\n\n链接存储结构：用一组**任意**的存储单元存储数据元素，数据元素之间的逻辑关系用指针（显式）来表示.\n\n例如，分别使用顺序和链接存储结构存储线性表 $(bat, cat, eat)$：\n\n![图 1-2 线性表的两种存储结构示意图](/assets/images/36-2.jpg)\n\n#### 再谈数据的逻辑结构和存储结构\n\n数据的逻辑结构是从具体问题抽象出来的数据模型，是**面向问题**的，反映了数据元素之间的关联方式或邻接关系。\n\n数据的存储结构是**面向计算机的**，其基本目标是将数据及其逻辑关系存储到计算机的内存中。\n\n因此，有必要强调，除非同时提到数据的逻辑结构和物理结构，一般的情况下“数据结构”指的即是数据的**逻辑结构**。如“线性表是一种数据结构”，即指线性表是一种逻辑结构——无论它采用了何种存储结构（顺序或链接）.\n\n### 抽象数据类型（Abstract Data Type)\n\n#### 数据类型（Data Type）\n\n数据类型是一组值的集合以及定义在这个集合上的一组操作的总称.\n\n于是数据类型规定了该类型数据的取值范围和对这些数据所能采取的操作.\n\n例如，C++ 语言中整型是一种数据类型，则规定了整型变量只能取计算机所能表示的最小负整数和最大正整数之间的任意一个整数，并只允许进行算术运算、关系运算和逻辑运算等.\n\n#### 抽象（Abstract）\n\n所谓抽象就是抽出问题本质的特征而忽略非本质的细节，是对具体事物的一个概括.  \n\n比如地图是对它所描述地域的一种抽象，物体受力分析图是对真实世界中某具体物体的抽象.\n\n很显然，使用数学知识解决实际问题时，我们提取关键因素，忽略非关键的因素，来建立对应的数学模型，这是典型的抽象过程.\n\n抽象的原因在于：一旦一个抽象的问题得到解决，则很多同类的具体问题便可迎刃而解.\n\n算法的设计需要抽象，同时在编程语言层面，抽象的思想仍然发挥作用：实现封装和信息的隐藏.\n\n例如，我们常把能够完成某种功能并可重复执行的一段代码抽象为函数，在需要执行这种功能时调用这个函数，从而将“做什么”抽象出来，与“怎么做”相分离，实现了算法细节和数据内部结构的隐藏.\n\n#### 抽象数据类型\n\n抽象数据类型简称 ADT，是一个**数据结构**以及定义在该结构上的**一组操作**的总称.\n\nADT 可理解为对编程语言本身提供的基本数据类型进行的进一步抽象，因此 ADT 和数据类型的区别仅在于：数据类型是高级编程语言支持的基本数据类型，而 ADT 指的是自定义的数据类型.\n\n在设计 ADT 时，把 ADT 的定义和实现分开. 定义部分只包含数据的逻辑结构和所允许的操作集合：一方面，使用者依据这些定义来使用 ADT；另一方面，实现者依据这些定义完成该 ADT 的各种操作的具体实现.\n\nADT 提供了定义和实现的不同试图，实现了封装和信息隐藏. 例如各种语言都提供了整数类型和具体实现，尽管它们的实现方法各有不同，但由于其 ADT 相同，在用户看来都是相同的.\n\n一个 ADT 的定义不涉及实现细节，形式上可简可繁. 如下例中对 ADT 的定义包括抽象数据类型名、数据元素之间的逻辑关系的定义、每种基本操作的接口：\n\n```ADT\nADT 抽象数据类型名\nData\n  数据元素之间逻辑关系的定义\n\nOperation\n  Operation_1\n    前置条件：执行该操作前数据所必需的状态\n    输入：执行该操作需要的输入\n    功能：该操作将完成的功能\n    输出：执行该操作后产生的输出\n    后置条件：执行该操作后数据的状态\n  \n  Operation_2\n    ... ...\n\n  ... ...\n\n  Operation_n\n    ... ...\n\nendADT\n```\n\n以上定义体现了**契约式编程**的思想.\n\n容易体会，面向对象语言的“类”体现了抽象数据类型的思想.\n","tags":["数据结构"],"categories":["developer"]},{"title":"冬天","url":"/archives/35/","content":"\n\n列车从南国缓缓驶入家乡时，我第一次得以突然进入北国的冬天。当窗外长青的树木和纵横的水道变为嶙峋的杨树和苍茫的黄土地，我突然意识到今年的冬天此刻方至。\n\n<!--more-->\n\n只需几场凛冽的寒风，北国的冬天便将天地间的一切粉饰席卷干净。正如千万年来一样，冬天亘古不变地考验着大地上的生命，一切无关生存的附属品被毫不吝啬的丢弃。土地霜冻，种子深埋地底；河流冰封，鱼蟹潜底；枯叶细枝凋零，鸟虫噤声匿迹。就连旷野上稀落的住民也关门闭户，一切都冷静而肃穆，生命就这样被揭露无遗。\n\n行驶的列车在这幅苍茫的背景图中匆匆离去，一头扎进钢铁林立的城市。\n\n下了火车，清冷的空气吸入身体，白色的水汽从口中鼻中喷薄而出，分明地标志着一个生命的存活。旁边一个终于下车的孩子兴奋地说着话，白气不停地萦绕在他的口边，象征着他生命的活力和对冬天的无意。妈妈给他紧了紧刚穿上的厚大棉衣和围巾，又给他戴上帽子，牵着他离开了。我想起了那些已经离我很远的冬天。\n\n我对童年的冬天并没有多少寒冷的印象，只记得我的手脚和耳朵经常冻伤。我记起燃着炉子的夜晚，妈妈把烧开的热水倒入脸盆，稍一冷却后就沾着洗手，慢慢的水又凉了些时就让我也一起洗。水仍然很烫，把我的手烫得通红，皲裂的口子和冻伤的红肿更加明显。等泡洗干净后，用毛巾擦干，然后用从“合社”买来的一毛钱根的油脂棒涂抹。涂抹完之后把双手放在炉火边上烤，一双大手一双小手翻来翻去。窗外是呼啸的寒风，屋内温暖安静的炉火边，我们默默无言。类似的场景常在我的梦中清晰的出现，但我从来无法给这些场景加上对话。我知道那些父母为我遮挡寒风的夜晚，和那个不知生命为何物，不知冬天有何意的我都一去不返了。\n\n我第一次感觉到童话世界的存在是在很多年前一个大雪的冬天。茫茫的大雪覆盖住校园，我走出教室时已晚自习放学许久，整个教学楼周围一片肃静，偶尔路过的人们无声无息——所有的声音都被窸窣的大雪悄然吞没。我环望四周，楼顶强力的灯光无法穿透雪幕，在一片茫茫中，只能看到离开的人群在远处的背影若隐若现，最后消失不见了。仿佛整个世界只剩下我独自一人和这一片灯光下的雪地。我向宿舍楼走去，抬头想望望这平时并不遥远的建筑物，却什么也看不到。我在雪中默默地走着，我想，如果方向没错我应该总能回到宿舍。宿舍里没有供暖，但室友们嗦嗦的说话声让我觉得暖和。风雪也许就是在那个童话般的夜晚开始浸入我的世界，多少年后我才知觉，一个无知无畏的我仍然在那个夜晚的纷扬大雪中默默前行。\n\n春节后的夜晚，我从温暖热闹的炭火小屋走出来，关上房门时把一屋子的温暖也隔绝在了身后。我看到冬夜清冷的月光洒在小巷低矮的房屋上，一阵无底的恐惧顷刻袭上心头，把我积攒在体内的温暖席卷一空。在冬月的清辉下，近处房屋的阴影淡淡地投射在小巷上，本已狭小低矮的乡间街巷更显局促。我抬眼远望，想看见广阔的夜空，目之所及却只有一片朦胧，正如很多年前那个大雪茫茫的夜晚。我突然发觉，这一切竟如暗淡聚光灯下一部舞台剧的布景，我回头看看电视闪烁的房屋，隔着凝结着水汽的玻璃窗，朦胧中大人和孩子们仍在嬉笑。我像出神的舞台剧演员，慌张中掩饰自己的失态，匆忙回到屋中。清冷月光下冬夜的巷道无人驻足，屋内屋外仿佛两个世界，我害怕晚一点就再也回不到我的家人中间。\n\n那些冬天的夜晚我久久不能忘怀，我不知道是何人布下了这一幕幕场景，朦胧夜色之外是否有观众曾屏息凝视，但我知道我已经把我全部的生命和感情都投入进来了，我的人生早已不自主地徐徐展开了。\n\n当列车驶出车站，再次驶入田野时，我看到片片积雪中陆陆续续展露出的青青麦苗，冬天里没人为它们清理积雪、遮蔽寒风，每个人有每个人的冬天。当列车远去，清晨的阳光又开始照射大地，所有的生命都在这个冬天的寒冷和冰雪中长了一岁。\n\n2020 年 5 月\n农历 四月廿七\n","tags":["散文"],"categories":["life"]},{"title":"机器学习基础-BP(Error Back Propagation)算法的数学原理","url":"/archives/34/","content":"\n\n本文就 [coursera](https://www.coursera.org/) 上斯坦福大学吴恩达教授的[《机器学习》](https://www.coursera.org/learn/machine-learning)课程中的[误差反向传播算法](https://baike.baidu.com/item/BP%E7%AE%97%E6%B3%95/1252294?fr=aladdin)（[Error Back Propagation](https://en.wikipedia.org/wiki/Backpropagation)）进行推导证明\n\n<!--more-->\n\n#### 明确一些记法\n\n简单将神经网络的示意如下，有助于推导过程中理解，读者也可自己画出示意图:\n\n![net](/assets/images/34-1.svg)\n\n本文沿用公开课中的符号记法：\n\n* 用字母 $z$ 和 $a$ 分别表示每个神经元上的输入和输出；其上标 $^{(l)}$ 表示该神经元所在的层数，$L$ 表示神经网络的总层数；其下标 $_i$ 表示该神经元在该层的标号，并用 $S_l$ 表示第 $l$ 层神经元的总个数。\n* 特别地，习惯用 $_k$ 下标表示输出层的神经元标号，$K$ 表示输出层神经元的总数，即 $S_L = K$\n* 用希腊字母 $\\boldsymbol\\Theta$ 表示系数矩阵，它应该是一个三维矩阵。$\\boldsymbol\\Theta^{(l)}$ 表示第 $l$ 层的系数矩阵，它应该是一个 $S^{l+1} \\times (S^l + 1)$ 矩阵。\n* 用 $g(x)$ 表示 [S 型函数](https://baike.baidu.com/item/S%E5%9E%8B%E5%87%BD%E6%95%B0/19178062?fr=aladdin)（[Sigmoid function](https://en.wikipedia.org/wiki/Sigmoid_function)）:\n$$\ng(x) = \\frac1{1+e^{-x}},\\ x \\in R \\tag{1.1}\n$$\n* 且容易得：\n$$\ng'(x) = g(x)\\left[1-g(x)\\right] \\tag{1.2}\n$$\n* $\\{\\boldsymbol{x}^{(i)}, y^{(i)}\\}$ 表示训练样本，当有多个训练样本时，用上标进行标号。并字母 $m$ 表示训练样本的总数。\n\n**需要注意**，除了输出层外，每一层都应加入一个偏置项:\n$$\na^{(l)}_0 = 1,\\ \\ l = 1,2,\\cdots,L-1\n$$\n\n根据以上记法，有：\n$$\nz^{(l)}_i = \\sum\\limits_{j=0}^{S_{l-1}}\\Theta^{(l)}_{ij} a^{(l-1)}_j\n,\\ \\ i = 1,2,\\cdots S_l \\tag{1.3}\n$$\n\n$$\n\\begin{aligned}\n&a^{(l)}_0 = 1, \\\\\n&a^{(l)}_i = g(z^{(l)}_i),\\ \\ i = 1,2,\\cdots S_l\n\\end{aligned}\n\\tag{1.4}\n$$\n\n\\* 另外，文中一般使用粗体字母表示矩阵（或向量），如 $\\boldsymbol x$，表示输入特征向量；常规字母表示实数，如 $x_1$ 表示向量 $\\boldsymbol x$ 中的第一个元素，它是一个实数。（即使不关注这个区别，也应能从上下文区分出一个字母代表的是向量或实数）\n\n#### 目的\n\n>我们已经走得太远，以至于忘记了为什么而出发 ——纪伯伦<a href=\"#note1\">$^{注1}$</a>\n\n我们要时刻记得我们想要得到什么，以至于当我们在进行复杂的推导过程中仍能清楚的知道每一步的意义，和接下来的方向。\n\nBP 算法是神经网络参数训练的重要算法，其关键在于得到代价函数 $J(\\boldsymbol\\Theta)$ 对于每一个参数 $\\Theta^{(l)}_{ij}$ 的偏导数，所以我们期望通过该算法，最终得到如下的内容：\n$$\\begin{aligned}\n\\frac{\\partial J}{\\partial\\Theta^{(1)}_{1\\ 0}} &= \\cdots \\\\\n\\frac{\\partial J}{\\partial\\Theta^{(1)}_{1\\ 2}} &= \\cdots \\\\\n&\\cdots \\\\\n\\end{aligned}\n\\tag{1.5}\n$$\n\n有了这些导数值我们就可以利用梯度下降或其他经典算法，很容易地（调用库）对代价函数 $J(\\boldsymbol\\Theta)$ 进行最小化，以训练出合适的参数。\n\n总而言之，我们的目的是得到一系列形如 $1.5$ 式的偏导。\n\n#### 代价函数\n\n如何选取合适的代价函数呢？当我们观察神经网络的最后一层时，可以把它看作输入为 $\\boldsymbol a^{(L-1)}$ 的 $K$ 分类问题。\n\n便得到了神经网络的代价函数:\n\n$$\\begin{array}{r}\nJ(\\boldsymbol\\Theta)\n=-\\frac1m\\sum\\limits_{j=1}^m\\sum\\limits_{k=1}^K\n\\left\\{\ny^{(j)}_kln\\left(h_\\boldsymbol\\Theta(\\boldsymbol x^{(j)})\\right)_k +\n\\left(1-y^{(j)}_k\\right)\nln\\left[1-\\left(h_\\boldsymbol \\Theta(\\boldsymbol x^{(j)})\\right)_k\\right]\n\\right\\}, \\tag{3.1} \\\\\ny_k^{(j)} = \\mathbf I_k(y^{(j)}) = \\begin{cases}\n1, & y^{(j)} = k \\\\\n0, & y^{(j)} \\not={k}\n\\end{cases}\n\\end{array}$$\n\n其中 $h_\\boldsymbol\\Theta(\\boldsymbol x)$ 是一个 $K$ 维向量，$\\Big(h_\\boldsymbol\\Theta(\\boldsymbol x)\\Big)_k$ 就是每个样本所对应的第 $k$ 个输出值，即对每个样本来说都有：\n$$\n\\Big(h_\\boldsymbol\\Theta(\\boldsymbol x)\\Big)_k = a^{(L)}_k \\tag{3.2}\n$$\n\n\\* 代价函数在不同的算法中可能有细微差别，在[西瓜书](https://baike.baidu.com/item/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/23613024?fr=aladdin)的BP算法一节中使用了均方误差作为代价函数，其值约等于上述代价函数，并且反向传播的推导过程基本一致。\n\n#### 最后一层参数的偏导\n\n**为简化记法，我们先在只有一个样本 $\\{\\boldsymbol x, \\boldsymbol y\\}$ 的情况下推导。**\n\n由 $3.1$、$3.2$ 式知，此时代价函数为：\n$$\nJ(\\boldsymbol\\Theta) =  \n-\\sum\\limits_{k=1}^K \\left[\ny_klna^{(L)}_k +\n(1-y_k)ln\\left(1-a^{(L)}_k\\right)\n\\right],\\ y_k = \\mathbf{I}_k(\\boldsymbol{y}) \\tag{4.1}\n$$\n\n由 $1.3$、$1.4$ 式，及复合函数求导法则，可得代价函数 $J(\\boldsymbol\\Theta)$ 对最后一层参数 $\\boldsymbol\\Theta^{(L-1)}$ 的偏导：\n\n$$\n\\frac{\\partial J}{\\partial\\Theta^{(L-1)}_{ij}} =\n\\frac{\\partial J}{\\partial a_i^{(L)}} \\cdot\n\\frac{\\mathrm{d}a^{(L)}_i}{\\mathrm{d}z^{(L)}_i} \\cdot\n\\frac{\\partial z^{(L)}_i}{\\partial \\boldsymbol{\\Theta}^{(L-1)}_{ij}}\n\\tag{4.2}\n$$\n\n$$\n$$\n\n分别计算上式中的 3 项：\n\n$$\n\\frac{\\partial J}{\\partial a_i^{(L)}} =\n-\\Big(\\frac{y_i}{a^{(L)}_i} + \\frac{y_i-1}{1-a^{(L)}_i}\\Big) \\tag{4.3}\n$$\n\n由 $1.4$、$1.2$ 式可得:\n$$\n\\frac{\\mathrm{d}a^{(L)}_i}{\\mathrm{d}z^{(L)}_i} =\na^{(L)}_i\\left(1-a^{(L)}_i\\right) \\tag{4.4}\n$$\n\n由 $1.3$ 式可得：\n$$\n\\frac{\\partial z^{(L)}_i}{\\partial \\boldsymbol{\\Theta}^{(L-1)}_{ij}}\n=a^{(L-1)}_j \\tag{4.5}\n$$\n\n将上述三式带回 $4.2$ 式，并化简，立即得：\n$$\n\\frac{\\partial J}{\\partial\\Theta^{(L-1)}_{ij}} =\n(a^{(L)}_i - y_i)a^{(L-1)}_j \\tag{4.6}\n$$\n\n并且有,\n$$\n\\frac{\\partial J}{\\partial z^{(L)}_i} =\n\\frac{\\partial J}{\\partial a_i^{(L)}} \\cdot\n\\frac{\\mathrm{d}a^{(L)}_i}{\\mathrm{d}z^{(L)}_i} =\na^{(L)}_i - y_i\n\\tag{4.7}\n$$\n\n**记**\n$$\n\\delta^{(L)}_i = a^{(L)}_i - y_i\n\\tag{4.8}\n$$\n\n称为第 $L$ 层（输出层）第 $i$ 个神经元的“误差项”。\n\n**至此，我们便得到代价函数对最后一层参数的偏导**:\n$$\n\\frac{\\partial J}{\\partial\\Theta^{(L-1)}_{ij}} =\n\\delta^{(L)}_i a^{(L-1)}_j\n\\tag{4.9}\n$$\n\n且有：\n$$\n\\frac{\\partial J}{\\partial z^{(L)}_i} = \\delta^{(L)}_i\n\\tag{4.10}\n$$\n\n#### 向前传播\n\n下面求代价函数 $J(\\boldsymbol\\Theta)$ 对第 $L-2$ 层参数 $\\boldsymbol\\Theta^{(L-2)}$ 的偏导：\n\n $$\n\\frac{\\partial J}{\\partial\\Theta^{(L-2)}_{ij}} \\tag{5.1}\n $$\n\n由 $1.3$、$1.4$ 式可得：\n$$\nz^{(L)}_k = \\sum\\limits_{i=0}^{S_{L-1}}\n\\boldsymbol \\Theta^{(L-1)}_{ki} a^{(L-1)}_i \\tag{5.2}\n$$\n\n$$\na^{(L-1)}_i = g(z^{(L-1)}_i), \\ i \\not ={0} \\tag{5.3}\n$$\n\n$$\nz^{(L-1)}_i = \\sum\\limits_{j=0}^{S_{L-2}}\n\\boldsymbol \\Theta^{(L-2)}_{ij} a^{(L-2)}_j \\tag{5.4}\n$$\n\n因此由上述 3 式知对于任意一个 $z^{(L)}_k$ 都是 $\\Theta^{(L-2)}_{ij}$ 的函数；而 $J(\\boldsymbol\\Theta)$ 又是每一个 $z^{(L)}_k$ 的函数，所以有（画出神经网络图中相关的部分，结合图示更容易理解）：\n\n$$\n\\begin{aligned}\n\\frac{\\partial J}{\\partial\\Theta^{(L-2)}_{ij}} &=\n\\sum\\limits_{k=1}^{K}\\frac{\\partial J}{\\partial z^{(L)}_k} \\cdot\n\\frac{\\partial z^{(L)}_k}{\\partial a^{(L-1)}_i} \\cdot\n\\frac{\\mathrm{d}a^{(L-1)}_i}{\\mathrm{d}z^{(L-1)}_i} \\cdot\n\\frac{\\partial z^{(L-1)}_i}{\\partial \\boldsymbol \\Theta^{(L-2)}_{ij}} \\\\\n&= \\frac{\\partial J}{\\partial z^{(L-1)}_i} \\cdot\n\\frac{\\partial z^{(L-1)}_i}{\\partial \\boldsymbol \\Theta^{(L-2)}_{ij}} \\\\\n\\end{aligned}\n\\tag{5.5}\n$$\n\n分别计算上式各导数项，得：\n$$\n\\frac{\\partial J}{\\partial\\Theta^{(L-2)}_{ij}} =\n\\sum\\limits_{k=1}^{K} \\delta^{(L)}_k \\cdot\n\\Theta^{(L-1)}_{ki} \\cdot\ng'(z^{(L-1)}_i) \\cdot\na^{(L-2)}_j\n\\tag{5.6}\n$$\n\n**记**\n$$\n\\delta^{(L-1)}_i =\n\\sum\\limits_{k=1}^K \\delta^{(L)}_k \\cdot\n\\Theta^{(L-1)}_{ki} \\cdot\ng'(z^{(L-1)}_i)\n\\tag{5.7}\n$$\n表示第 $L-1$ 层第 $i$ 个神经元的“误差项”\n\n则有：\n\n$$\n\\frac{\\partial J}{\\partial\\Theta^{(L-2)}_{ij}} =\n\\delta^{(L-1)}_i a^{(L-2)}_j\n\\tag{5.8}\n$$\n\n结合 $5.5$、$5.8$，同样有：\n$$\n\\frac{\\partial J}{\\partial z^{(L-1)}_i} =\n\\delta^{(L-1)}_i\n\\tag{5.9}\n$$\n\n#### 找出通式\n\n至此，我们求得了代价函数对 $\\boldsymbol\\Theta^{(L)}$ 和 $\\boldsymbol\\Theta^{(L-1)}$ 的偏导，在继续对 $\\boldsymbol\\Theta^{(L-2)}, \\cdots, \\boldsymbol\\Theta^{(1)}$ 求导前，先看看我们得到了哪些有趣的结果。\n\n我们对前面两步得到的结果稍作整理，得到：\n$$\n\\delta_k^{(L)} = a_k^{(L)} - y_k =\n\\frac{\\partial J}{\\partial z^{(l)}_k}\n\\tag{6.1}\n$$\n\n$$\n\\delta^{(L-1)}_i =\n\\sum\\limits_{k=1}^K \\delta^{(L)}_k \\cdot\n\\Theta^{(L-1)}_{ki} \\cdot\ng'(z^{(L-1)}_i) =\n\\frac{\\partial J}{\\partial z^{(L-1)}_i}\n\\tag{6.2}\n$$\n\n$$\n\\frac{\\partial J}{\\partial\\Theta^{(L-1)}_{ij}} =\na^{(L-1)}_j\\delta^{(L)}_i \\tag{6.3}\n$$\n\n$$\n\\frac{\\partial J}{\\partial\\Theta^{(L-2)}_{ij}} =\na^{(L-2)}_j \\delta^{(L-1)}_i \\tag{6.4}\n$$\n\n自然地，我们倾向于作出以下猜想：（如果你觉得这个猜想不够“自然”，可以继续求出$\\frac{\\partial J}{\\partial\\Theta^{(L-3)}_{ij}}$，再将结果放在一起比较，会发现做出这个猜想非常合理和自然）\n\n假设一：*若记：*\n$$\n\\delta_k^{(L)} =\na_k^{(L)} - y_k \\tag{6.5}\n$$\n$$\n\\delta^{(l)}_j =\n\\sum\\limits_{i=1}^{S_{l+1}} \\delta^{(l+1)}_i \\Theta^{(l)}_{ij}\ng'(z^{(l)}_j)\n,\\ \\ l\\not=K  \\tag{6.6}\n$$\n\n*则对任意 $z^{(l)}_j$ 和 $\\Theta^{(l)}_{ij}$，有:*\n\n$$\n\\text{(1).}\\ \\\n\\frac{\\partial J}{\\partial z^{(l)}_j} =\n\\delta^{(l)}_j,\n\\tag{6.7}\n$$\n\n$$\n\\text{(2).}\\ \\ \\frac{\\partial J}{\\partial\\Theta^{(l)}_{ij}} =\na^{(l)}_j \\delta^{(l+1)}_i. \\tag{6.8}\n$$\n\n若该假设正确，我们便得到了反向逐层求解代价函数对参数的偏导的方法。\n\n接下来证明该假设是否正确。\n\n#### 归纳证明\n\n显然，我们得到的 $6.1-6.4$ 式已经证明了 $l=K$ 和 $l=K-1$ 时，*假设一* 的正确性。采用数学归纳法，假设当 $l=n<L$ 时上述 *假设一* 仍成立，即有：\n\n$$\n\\frac{\\partial J}{\\partial z^{(n+1)}_i} = \\delta^{(n+1)}_i \\tag{7.1}\n$$\n\n$$\n\\frac{\\partial J}{\\partial\\Theta^{(n)}_{ij}} =\na^{(n)}_j \\delta^{(n+1)}_i \\tag{7.2}\n$$\n\n时，考察 $l=n-1$ 时假设的正确性。\n\n由 $7.1$、$7.2$ 式，同 $5.5$ 式推导过程，有：\n$$\n\\begin{aligned}\n\\frac{\\partial J}{\\partial\\Theta^{(n-1)}_{ij}} &=\n\\sum\\limits_{t=1}^{S_{n+1}}\n\\frac{\\partial J}{\\partial z^{(n+1)}_t} \\cdot\n\\frac{\\partial z^{(n+1)}_t}{\\partial a^{(n)}_i} \\cdot\n\\frac{\\mathrm{d}a_i^{(n)}}{\\mathrm{d}z^{(n)}_i} \\cdot\n\\frac{\\partial z^{(n)}_i}{\\partial\\Theta^{(n-1)}_{ij}} \\\\\n&=\n\\frac{\\partial J}{\\partial z^{(n)}_i} \\cdot\n\\frac{\\partial z^{(n)}_i}{\\partial\\Theta^{(n-1)}_{ij}}\n\\end{aligned}\n\\tag{7.3}\n$$\n\n将 $7.1$ 式带入上式，并对剩余项逐项求导，得：\n$$\n\\frac{\\partial J}{\\partial\\Theta^{(n-1)}_{ij}} =\n\\sum\\limits_{t=1}^{S_{n}}\n\\delta^{(n+1)}_t\\cdot\n\\Theta^{(n)}_{ti} \\cdot\ng'(z^{(n)}_i)\\cdot\na^{(n-1)}_j \\tag{7.4}\n$$\n\n结合 $7.3$、$7.4$ 及 $6.6$ 式便有：\n\n$$\n\\begin{aligned}\n\\frac{\\partial J}{\\partial z^{(n)}_i} &=\n\\sum\\limits_{t=1}^{S_{n}}\n\\delta^{(n+1)}_t\\cdot\n\\Theta^{(n)}_{ti} \\cdot\ng'(z^{(n)}_i)\\\\\n&=\n\\delta^{(n)}_i\n\\end{aligned}\n\\tag{7.5}\n$$\n\n$$\n\\frac{\\partial J}{\\partial\\Theta^{(n-1)}_{ij}} =\na^{(n-1)}_j \\delta^{(n)}_i\n\\tag{7.6}\n$$\n\n所以 *假设一* 对 $l=n-1$ 时也成立，由数学归纳法， *假设一* 成立得证！\n\n#### 矩阵表示法\n\n以上 *假设一* 的内容就是 BP 算法的核心内容，在更多情况下还可以使用矩阵来表示：\n\n若记：\n$$\n\\begin{aligned}\n&\\delta^{(L)}_k = a^{(L)}_k - y_k \\\\\n&\\boldsymbol\\delta^{(l)} =\n\\left(\\boldsymbol\\Theta^{(l)}\\right)^T \\times\n\\boldsymbol\\delta^{(l+1)} .*\ng'(\\boldsymbol z^{(l)}), \\ \\\nl \\not=L\n\\end{aligned}\n\\tag{8.1}\n$$\n（$.*$ 表示对对应元素逐个执行乘法运算），则有：\n$$\n\\frac{\\partial J(\\boldsymbol\\Theta)}{\\partial\\boldsymbol\\Theta^{(l)}} =\n\\boldsymbol\\delta^{(l+1)} \\times\n\\left(\\boldsymbol{a^{(l)}}\\right)^T\n\\tag{8.2}\n$$\n\n#### 多样本的情况\n\n在矩阵表示法的基础下，容易写出在 $m$ 个训练样本下 BP 算法的结论：\n\n根据多样本下的代价函数（$3.1$ 式），以及*假设一*的结论 $8.1$、$8.2$ 式，有：\n$$\n\\frac{\\partial J(\\boldsymbol\\Theta)}{\\partial\\boldsymbol\\Theta^{(l)}} =\n\\frac1m \\sum\\limits_{i=1}^m\n\\left[\n\\boldsymbol\\delta^{(l+1)} \\times\n\\left(\\boldsymbol{a^{(l)}}\\right)^T\n\\right]_i\n\\tag{8.3}\n$$\n\n#### 正则化\n\n为了一定程度地防止过拟合的情况地发生，选取合适的 $\\lambda$ 将正则项加入代价函数（$3.1$ 式），便得到：\n\n$$\n\\begin{aligned}\nJ(\\boldsymbol\\Theta) &= -\\frac1m\\sum\\limits_{j=1}^m\\sum\\limits_{k=1}^K\n\\left\\{\n y^{(j)}_kln\\left(h_\\boldsymbol\\Theta(\\boldsymbol x^{(j)})\\right)_k +\n\\left(1-y^{(j)}_k\\right)ln\\left[1-\\left(h_\\boldsymbol\\Theta(\\boldsymbol x^{(j)})\\right)_k\\right]\n\\right\\} \\\\\n&+\n\\frac\\lambda{2m} \\sum\\limits_{l=1}^{L-1}\\sum\\limits_{i=1}^{S_{l+1}}\n\\sum\\limits_{j=1}^{S_l} \\Big(\\Theta^{(l)}_{ij}\\Big)^2,\\\\\n&h_\\boldsymbol\\Theta(\\boldsymbol x) \\in \\mathbb R^K，\n\\left(h_\\boldsymbol\\Theta(\\boldsymbol x)\\right)_i = i^{(th)} \\text{output}\n\\end{aligned}\n\\tag{9.1}\n$$\n\n则：\n$$\n\\frac{\\partial J(\\boldsymbol\\Theta)}{\\partial\\boldsymbol\\Theta^{(l)}} =\n\\frac1m \\sum\\limits_{i=1}^m\n\\left[\n\\boldsymbol\\delta^{(l+1)} \\times\n\\left(\\boldsymbol{a^{(l)}}\\right)^T\n\\right]_i +\n\\frac\\lambda m\\boldsymbol\\Theta^{(l)}\n\\tag{9.2}\n$$\n\n#### *BP 算法的使用\n\n至此，我们已经将 BP 算法的核心内容的数学原理推导并阐述完整了。\n\n用伪代码表示使用 BP 算法来求解偏导的大致过程如下（其中 $\\Delta^{(l)}_{ij}$ 表示第 $i$ 个样本中的 $\\delta^{(L)}_j$，$D^{(l)}_{ij}$ 表示 $\\frac{\\partial J}{\\partial\\Theta^{(l)}_{ij}}$）：\n\n$$\n\\begin{aligned}\n&\\text{Set }\\Delta^{(l)}_{ij} = 0 \\text{ (for all l, i, j)} \\\\\n&\\text{For } i = 1  \\text{ to } m \\\\\n&\\ \\ \\ \\text{ Set } \\boldsymbol a^{(1)} = \\boldsymbol x^{(i)} \\\\\n&\\ \\ \\ \\text{ Perform forward propagation to compute } \\boldsymbol a^{(l)} \\text{ for } l = 2,3,\\cdots,L \\\\\n&\\ \\ \\ \\text{ Using } y^{(i)} \\text{, compute }\\boldsymbol\\delta^{(L)} =\n\\boldsymbol a^{(L)} - \\boldsymbol y^{(i)}_* \\\\\n&\\ \\ \\ \\text{ compute } \\boldsymbol\\delta^{(L-1)}, \\boldsymbol\\delta^{(L-2)},\n\\cdots, \\boldsymbol\\delta^{(2)} \\\\\n&\\ \\ \\ \\ \\ \\Delta^{(l)}_{ij} := \\Delta^{(l)}_{ij} +\na^{(l)}_j\\delta^{(l+1)}_i\\\\\n&D^{(l)}_{ij} := \\frac1m\\Delta^{(l)}_{ij}\n+ \\frac\\lambda m\\Theta^{(l)}_{ij} \\text{ if } j\\not=0 \\\\\n&D^{(l)}_{ij} := \\frac1m\\Delta^{(l)}_{ij} \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\\n\\text{ if } j=0\n\\end{aligned}\n$$\n\n需要注意的是，在实际使用中，上述过程很多步骤可以转换为矩阵运算以提升性能。\n\n***************\n\n<a name=\"note1\">[*注1*]</a> 这句话网传出自黎巴嫩诗人纪伯伦，但我在网络上并未查到确切证据或出处，甚至浏览了网上传言出处得作品，并未得到印证。如果你知道这句话的出处，请指正！\n","tags":["ML"],"categories":["science"]},{"title":"机器学习基础-“逻辑”回归(logistic regression)的数学原理","url":"/archives/33/","content":"通过使用 logistic regression 处理一个二分类问题来简要分析其中的数学原理。\n<!--more-->\n\n### 问题\n\n假设我们有这样一个问题，根据医学图像来判断病人的肿瘤为恶性还是良性，这就是一个二分类问题。\n\n相对于回归问题，分类问题的输出值为离散值。进一步地，二分类的输出值只有两个，通常称其为“正类”和“负类”，也可以用 1 和 0 分别表示。\n\n### 思路\n\n同回归问题一样，我们希望得到假设 $h_\\boldsymbol\\theta(\\boldsymbol{x})$ 对应的代价函数 $J(\\boldsymbol\\theta)$，并通过最小化代价函数来确定合适的参数值 $\\boldsymbol\\theta$。\n\n下面推导代价函数：\n\n先明确一些记法：粗体字母代表向量，一般使用 $\\boldsymbol{x}$ 表示一个样例的特征向量，$\\boldsymbol{\\theta}$ 表示参数向量，实数 $y\\in\\{0,1\\}$ 表示该样例的标记。当处理多个样例时，使用 $\\boldsymbol{x^{(j)}}$ 表示第 $j$ 个样例的特征向量, 对应的标记为 $y^{(j)}$。向量 $\\boldsymbol{y}$ 表示多个样例的标记向量。具体的：\n\n$$\n\\boldsymbol{x^{(j)}}=\\left[\\begin{matrix}\nx^{(j)}_1 \\\\\nx^{(j)}_2 \\\\\n\\vdots \\\\\nx^{(j)}_n \\\\\n\\end{matrix}\\right],\\\n\\boldsymbol\\theta=\\left[\\begin{matrix}\n\\theta_0 \\\\\n\\theta_1 \\\\\n\\vdots \\\\\n\\theta_n \\\\\n\\end{matrix}\\right],\\\n\\boldsymbol{y} = \\left[\\begin{matrix}\ny^{(1)}\\\\\ny^{(2)}\\\\\n\\vdots \\\\\ny^{(m)}\\\\\n\\end{matrix}\\right]\n$$\n\n#### [最大似然估计](https://baike.baidu.com/item/%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1/4967925?fr=aladdin)（[Maximum Likelihood Estimation](https://en.wikipedia.org/wiki/Maximum_likelihood_estimation)）\n\n与线性回归直接输出连续的结果不同，对于分类问题，我们期望能得到一个函数 $h_\\boldsymbol\\theta(\\boldsymbol{x})$ 来表示特征 $\\boldsymbol{x}$ 下结果为正类的概率，即 $h_\\boldsymbol\\theta(\\boldsymbol{x}) = P\\{Y=1|\\boldsymbol{x}\\}$。自然地，若 $h_\\boldsymbol\\theta(x) > 0.5$ 我们倾向于认为结果为正类，反之倾向于负类。\n\n结合实例，这意味着我们输入病人医学图像的特征 $x$，便可以给出该病人肿瘤为恶性的概率(将恶性划分为正类)，若该值大于 $0.5$ 则倾向于认为肿瘤为恶性，反之认为良性。\n\n由于二分类问题的结果非此即彼，所以应有：\n\n$$\nP\\{Y=1|\\boldsymbol{x}\\} = h_\\boldsymbol\\theta(\\boldsymbol{x})\n$$\n$$\nP\\{Y=0|\\boldsymbol{x}\\} = 1 - h_\\boldsymbol\\theta(\\boldsymbol{x})\n$$\n\n上式等价于：\n$$\nP\\{Y=y|\\boldsymbol{x}\\} = yh_\\boldsymbol\\theta(\\boldsymbol{x}) + [1-y](1-h_\\boldsymbol\\theta(\\boldsymbol{x})), \\ y\\in\\{0,1\\}\n$$\n\n对于 $m$ 个训练样本 $\\{\\boldsymbol{x}^{(j)}, y^{(j)}\\},\\ j=1,2,3,\\cdots,m$，将其视为随机事件，则每一个样本的出现的概率为:\n$$\nP\\{Y=y^{(j)}|\\boldsymbol{x}^{(j)}\\} = y^{(j)}h_\\boldsymbol\\theta(\\boldsymbol{x}^{(j)})+(1-y^{(j)})[1-h_\\boldsymbol\\theta(\\boldsymbol{x}^{(j)})],\\ y^{(j)}\\in\\{0,1\\}\n$$\n\n由于每个样本相互独立，则出现该样本的概率为：\n$$\n\\prod_{j=1}^m P\\{Y=y^{(j)}|\\boldsymbol{x}^{(j)}\\},\\ y^{(j)} \\in \\{0, 1\\}\n$$\n即：\n$$\n\\prod_{j=1}^m \\left\\{ y^{(j)}h_\\boldsymbol\\theta(\\boldsymbol{x}^{(j)}) + (1-y^{(j)})[1-h_\\boldsymbol\\theta(\\boldsymbol{x}^{(j)})] \\right\\},\\ y^{(j)} \\in \\{0,1\\}\n$$\n\n至此我们得到一个关于 $\\boldsymbol\\theta$ 的函数，记为 $L(\\boldsymbol\\theta)$，该函数值代表了出现该训练样本的概率。最大似然估法计考虑这样一个问题，为什么会出现这样的样本分布而不是其他的分布呢？我们只能认为出现这样的分布概率是大于其他分布的，也就是说只有出现该样本分布的概率 $L(\\boldsymbol\\theta)$ 尽可能的大我们才得到了这个样本分布。因此我们只需求得 $j(\\boldsymbol\\theta)$ 取得最大值所对应的 $\\hat{\\boldsymbol\\theta}$，便是我们对 $h_\\boldsymbol\\theta(\\boldsymbol{x})$ 参数值 $\\boldsymbol\\theta$ 合理估计。这便是最大似然参数估计法的思想。\n\n至此，我们可将代价函数看作 $-L(\\boldsymbol\\theta)$，我们只有使代价函数尽可能的小，即 $L(\\boldsymbol\\theta)$ 尽可能的大才能得到合理的 $\\boldsymbol\\theta$。而 $-L(\\boldsymbol\\theta)$ 中的 $h_\\boldsymbol\\theta(\\boldsymbol{x})$ 还不明确，我们需要明确其形式。\n\n#### 确定 $h_\\boldsymbol\\theta(\\boldsymbol{x})$ 的形式\n\n显然线性回归中的假设函数 $h_\\boldsymbol\\theta(\\boldsymbol{x}) = \\boldsymbol\\theta_0 + \\sum\\limits_{i=1}^n\\boldsymbol\\theta_ix_i$ 的形式不满足分类问题，因为在分类问题中我们期望把得到的 $h_\\boldsymbol\\theta(\\boldsymbol{x})$ 看作是一个概率，所以其值应该是在区间 $[0,1]$ 内的。为此，我们可以对原函数进行“挤压”，使其值域属于 $(0,1)$。此时便用到了 [S 型函数](https://baike.baidu.com/item/S%E5%9E%8B%E5%87%BD%E6%95%B0/19178062?fr=aladdin)（[Sigmoid function](https://en.wikipedia.org/wiki/Sigmoid_function)）:\n$$\nsigmod(z) = \\frac{1}{1+e^{-z}},\\ z \\in \\mathbf{R}\n$$\n\n所以令\n$$\nh_\\boldsymbol\\theta(\\boldsymbol{x}) = \\frac{1}{1 + e^{-z}},\\\nz = \\boldsymbol\\theta_0 + \\sum\\limits_{i=1}^n\\boldsymbol\\theta_ix_i\n$$\n\n其中 $z$ 也可记为矩阵形式：\n$$\n\\ z = \\boldsymbol{\\theta}^T \\left[ \\begin{matrix}1 \\\\ \\boldsymbol{x} \\end{matrix} \\right]\n$$\n\n至此我们就得到了 $h_\\boldsymbol\\theta(\\boldsymbol{x})$ 的表达式。\n\n#### 整理得到代价函数 $J(\\boldsymbol\\theta)$\n\n确定了 $h_\\boldsymbol\\theta(\\boldsymbol{x})$ 形式后，$L(\\boldsymbol\\theta)$ 的形式完全确定，在给定训练数据下是一个关于 $\\boldsymbol\\theta$ 的函数。我们可以使用 $-L(\\boldsymbol\\theta)$ 作为代价函数，但在最大似然估计法中更常用的方法是对 $L(\\boldsymbol\\theta)$ 取对数化简（$\\ln$ 函数的单调性保证了化简前后同时取得最值），令\n$$\nJ(\\boldsymbol\\theta) = -\\frac1{m}\\ln L(\\boldsymbol\\theta)\n$$\n\n进一步得到：\n$$\nJ(\\boldsymbol\\theta) =\n\\begin{cases}\n-\\frac1{m}\\sum\\limits_{j=1}^m \\ln[h_\\boldsymbol\\theta(\\boldsymbol{x}^{(j)})], & y^{(j)} = 1.\\\\\n-\\frac1{m}\\sum\\limits_{j=1}^m \\ln[1-h_\\boldsymbol\\theta(\\boldsymbol{x}^{(j)})], & y^{(j)}=0.\n\\end{cases}\n$$\n\n同样可合并，写为:\n$$\nJ(\\boldsymbol\\theta) = -\\frac1{m}\\sum_{j=1}^m\\Big(y^{(j)}\\ln[h_\\boldsymbol\\theta(\\boldsymbol{x}^{(j)})] + (1-y^{(j)})\\ln[1-h_\\boldsymbol\\theta(\\boldsymbol{x}^{(j)})]\\Big)\n$$\n\n至此便得到了代价函数 $J(\\boldsymbol\\theta)$ 的表达式，接下来就是最小化代价函数以得到合适的参数向量 $\\boldsymbol{\\theta}$\n\n### 梯度下降\n\n梯度下降的核心在于求得代价函数的梯度 $\\mathbf{Grad}J(\\boldsymbol\\theta)$，由高等数学知识可知:\n$$\n\\mathbf{Grad}J(\\boldsymbol\\theta) = (\\frac{\\partial{J}}{\\partial\\boldsymbol{\\theta}_0}, \\frac{\\partial{J}}{\\partial\\boldsymbol{\\theta}_1}, \\cdots, \\frac{\\partial{J}}{\\partial\\boldsymbol{\\theta}_n})\n$$\n\n下面求 $\\frac{\\partial J}{\\partial\\boldsymbol{\\theta}_i}$：\n\n先将 $h_\\boldsymbol\\theta(\\boldsymbol{x}) = \\frac1{1+e^{-z}}$ 带入 $J(\\boldsymbol\\theta)$，并化简，可得：\n\n$$\nJ(\\boldsymbol\\theta) = \\frac1{m}\\sum\\limits_{j=1}^m\\left[\\ln(1+e^{z^{(j)}}) - y^{(j)}z^{(j)}\\right],\\ z^{(j)} = \\boldsymbol{\\theta}^T\\left[ \\begin{matrix} 1 \\\\ \\boldsymbol{x}^{(j)} \\end{matrix} \\right]\n$$\n\n则有：\n\n$$\n\\begin{aligned}\n\\frac{\\partial{J}}{\\partial\\boldsymbol\\theta_i} &= \\frac{\\partial J}{\\partial z} \\cdot \\frac{\\partial z}{\\partial\\boldsymbol\\theta_i} \\\\\n&= \\frac1{m}\\sum\\limits_{j=1}^m\\Big(\\frac{e^{z^{(j)}}}{1+e^{z^{(j)}}}-y^{(j)}\\Big)x^{(j)}_i \\\\\n&= \\frac1{m}\\sum_{j=1}^{m}\\left[h_\\boldsymbol\\theta(x^{(j)}) - y^{(j)}\\right]x_i^{(j)}\n\\end{aligned}\n$$\n\n至此我们就求出了代价函数对于每个参数 $\\boldsymbol\\theta_i$ 的偏导，我们就可以使用梯度下降法来求得使代价函数足够小时的所有参数了：\n\n```bash\n// 选取合适的下降率 alpha\nrepeat until converge {\n  theta0 := theta0 - alpha * grad0;\n  theta1 := theta1 - alpha * grad1;\n  ...\n  thetan := thetan - alpha * gradn;\n}\n```\n\n在很多场景下使用矩阵运算往往具有更高的效率，下面根据 $\\frac{\\partial J}{\\partial\\boldsymbol\\theta_i}$ 的计算公式可得到 $\\frac{\\partial J}{\\partial\\boldsymbol{\\theta}}$ 的矩阵表示法：\n\n首先记:\n$$\n\\boldsymbol{X} = \\left[\n  \\begin{matrix}\n    1 & [x^{(1)}]^T \\\\\n    1 & [x^{(2)}]^T \\\\\n    \\vdots & \\vdots \\\\\n    1 & [x^{(m)}]^T \\\\\n  \\end{matrix}\n  \\right]\n$$\n\n则有：\n$$\n\\frac{\\partial J}{\\partial\\boldsymbol{\\theta}}\n= \\frac1m\\boldsymbol{X}^T\\left[h_\\boldsymbol\\theta(X\\times\\boldsymbol{\\theta}) - y\\right]\n$$\n","tags":["ML"],"categories":["science"]},{"title":"编写一个自动推送 Git Page 的 nodejs 脚本","url":"/archives/32/","content":"\n\n\n### 背景\n\n写了一个简单的个人主页，由于使用了一些 CSS3 的属性，考虑到浏览器兼容性问题，就使用了 webpack 的一些 loader 给这些属性加前缀。所以简单的静态单页面用了 webpack，又因为这个页面要放在 Github Pages 上，每次打包后还得手动切换分支推送到 Github 上，干脆趁这个机会写一个自动推送的脚本。\n<!--more-->\n\n**该脚本主要参考了 [hexo-deployer-git](https://github.com/hexojs/hexo-deployer-git)**，可以查看该项目获取功能更完善的源码。\n\n### 预备知识\n\n脚本比较简单，主要使用 NodeJs child_process 的 spawn 方法调用子进程执行 git 语句。如果你对 NodeJs 不熟悉可能需要了解以下内容才能完全弄懂脚本中的每一行代码：（如果你只是想大致了解一下代码原理，可不必查看以下知识，本文将做简单的解释）\n\n* [child_process](http://nodejs.cn/api/child_process.html), [child_process.spawn](http://nodejs.cn/api/child_process.html#child_process_child_process_spawn_command_args_options)\n* [stream](http://nodejs.cn/api/stream.html), [process.stdout](http://nodejs.cn/api/process.html#process_process_stdout), [process.stderr](http://nodejs.cn/api/process.html#process_process_stderr)\n* [fs](http://nodejs.cn/api/fs.html)\n\n## spawn\n\n### 用法\n\nNodeJs 的 child_process 模块提供了 `spawn` 方法，该方法将调用子进程，并执行传入的命令行及参数。该脚本主要利用该方法执行需要的 git 命令。下面是一个简单的 spawn 使用示例：\n\n```js\nconst { spawn } = require('child_process');\nconst ls = spawn('ls', ['-lh', '/usr']);\n\nls.stdout.on('data', (data) => {\n  console.log(`stdout: ${data}`);\n});\n\nls.stderr.on('data', (data) => {\n  console.error(`stderr: ${data}`);\n});\n\nls.on('close', (code) => {\n  console.log(`子进程退出，使用退出码 ${code}`);\n});\n```\n\n实例中向 `spawn` 传入了 `ls` 命令，以及 `-lh`、`/usr` 参数，并通过事件监听回调处理命令执行的结果。`spawn` 方法返回一个 `ChildProcess`实例，其中 `stdout` 和 `stderr` 是命令执行后的输出流和错误流。我们监听这两个流的事件来打印命令执行后的结果或错误信息。同时监听实例的 `close` 事件，打印命令执行后的退出码。退出码为 0 时代表命令正常执行完毕，非 0 时代表发生了异常。（如 debug 需要具体代码含义,可查看[退出码](http://nodejs.cn/api/process.html#process_exit_codes)）。\n\n### 封装 spawn\n\n如上所述，spawn 通过回调来处理响应，我们希望使用更方便易读的 Promise 来简单封装一下 spawn。(对于简单的代码来说，这一步不是必要的，但我还是参照 hexo 的做法封装了 spawn。)\n\n`spawn.js`\n\n```js\n'use strict'\n\nconst { spawn } = require('child_process')\n\nfunction promiseSpawn(command, args, options) {\n  if (!command) throw new TypeError('command is reuqired');\n\n  if (!options && args && !Array.isArray(args)) {\n    options = args;\n    args = [];\n  }\n\n  // note-1 以上是对参数的容错处理\n\n  args = args || [];\n  options = options || {};\n\n  // note-2 接下来将其封装成一个 Promise 对象\n  return new Promise((resolve, reject) => {\n    const task = spawn(command, args, options);\n    const encoding = options.hasOwnProperty('encoding') ? options.encoding : 'utf8';\n\n    /*-- note-3 start --*/\n    if (task.stdout) {\n      task.stdout.pipe(process.stdout);\n    }\n\n    if (task.stderr) {\n      task.stderr.pipe(process.stdout)\n    }\n    /* \n     这里调用子进程输出流(stdout/stderr)的 pipe 方法，\n     将其输入到当前进程的输出流，这样就能在调用该脚本的\n     进程中看到子进程中执行的命令的输入了\n\n     如果你希望子进程的命令静默执行，这些代码同样不是必要的\n     或者可以传入一个参数来决定是否在主进程中展示这些信息\n    */\n    /*-- note-3 end --*/\n\n    // note-4 监听命令结束事件，根据 code 来决定是否 resolve\n    task.on('close', code => {\n      if (code) {\n        const e = new Error('command execute failed');\n        e.code = code;\n\n        return reject(e);\n      }\n\n      resolve();\n    });\n\n\n    // note-5 命令执行错误时 reject\n    task.on('error', reject)\n\n    // note-6 处理 `exit` 事件\n    if (!task.stderr && !task.stdout) {\n      task.on('exit', code => {\n        if (code) {\n          const e = new Error('Spawn failed');\n          e.code = code;\n          \n          return reject(e);\n        }\n      });\n    }\n  });\n}\n\nmodule.exports = promiseSpawn;\n\n```\n\nChildProcess 的 `close`、`error`、`exit` 事件的触发是有区别的，并且也不是简单的包含关系，所以代码中对其分别进行了处理，具体可查看[官方文档](http://nodejs.cn/api/child_process.html#child_process_event_close)。\n\n## 执行 git 命令\n\n利用上面封装的 `spawn` 方法，可以很方便的执行 git 的语句。\n\n`deployer.js`\n\n```js\n'use strict'\n\nconst spawn = require('./lib/spawn');  // note-1 导入封装好的 spawn\nconst pathFn = require('path');\nconst fs = require('fs');\n\n// note-2 设置好执行 git 命令时需要用到的参数，也可以单独分离出配置文件\nconst args = {\n  user: {\n    name: 'name',\n    email: 'name@email.com',\n  },\n  // 需要 push 的目录，此处推送的是 webpack 默认的打包路径\n  baseDir: pathFn.resolve('./', 'dist'),\n  repo: {\n    url: 'git@github.com:username/username.github.io.git',\n    branch: 'master',\n  },\n};\n\ndeployToGit(args); // 执行推送函数\n\nfunction deployToGit(args) {\n  const message = args.message || `Site updated: ${(new Date()).toDateString()}`\n  const baseDir = args.baseDir;\n  const gitDir = pathFn.join(baseDir, '.git');\n\n  if (!args.repo) {\n    return console.log('Please check configs of repository!')\n  }\n\n  // 检查要推送的目录是否存在\n  if (!fs.existsSync(baseDir)) {\n    throw new Error('Please build before deploy')\n  }\n  // 检查该目录下是否已经存在 git 仓库\n  if (!fs.existsSync(gitDir)) {\n    setup()\n      .then(() => push(args.repo));\n  } else {\n    push(args.repo);\n  }\n\n  function git(...args) {\n    return spawn('git', args, {\n      cwd: baseDir,\n      stdio: 'inherit'\n    });\n  }\n\n  // 初始化 git 仓库\n  function setup() {\n    const userName = args.user && args.user.name || '';\n    const userEmail = args.user && args.user.emial || '';\n\n    return git('init').\n      then(() => git('config', 'user.name', userName)).\n      then(() => git('config', 'user.email', userEmail)).\n      then(() => git('add', '-A')).\n      then(() => git('commit', '-m', message));\n  }\n\n  // 提交并推送指定目录\n  function push(repo) {\n    return git('add', '-A').\n      then(() => git('commit', '-m', message).catch(() => '')).\n      then(() => git('push', '-u', repo.url, 'HEAD:' + repo.branch, '--force'));\n  }\n}\n```\n\n执行 git 命令的代码相对来说就比较简单了，但是要关注一些错误情况的检查，可能需要多 debug 几遍才能确保命令的执行达到预期的效果。\n\n## 执行脚本\n\n以上 `spawn.js` 和 `deployer.js` 就是推送脚本的全部内容，最后把这些脚本胶乳 `package.json` 中的 `script` 中，就能在打包后，一键推送部署到 github pages 上了。\n\npackage.json\n\n```json\n{\n  ...\n  \"scripts\": {\n    ...\n    \"deploy\": \"node ./script/deploy\"\n  },\n  ...\n}\n```\n\n在 shell 中执行 `npm run deploy` 即可执行脚本一键部署，下面是我执行的示，(显然我在这次部署前没有进行任何修改)\n\n```shell\nHozen@HOZEN MINGW64 /c/Workspace/localstatic/lei (dev)\n$ npm run deploy\n\n> lei@1.0.0 deploy C:\\Workspace\\localstatic\\lei\n> node ./script/deploy\n\nOn branch master\nnothing to commit, working tree clean\nEverything up-to-date\nBranch 'master' set up to track remote branch 'master' from 'git@github.com:****/****.github.io.git'.\n```\n\n## 注意\n\n由于不同操作系统和不同 shell 客户端中的命令行和格式可能会有不同，导致同一套代码可能不能在不同环境中执行，要解决这个问题可以使用 [cross-spawn](https://github.com/moxystudio/node-cross-spawn) 工具替代 NodeJs 中的 spawn。\n","tags":["Git","Node.js","Github page"],"categories":["developer"]},{"title":"经济学的旁听生-张晓风","url":"/archives/31/","content":"\n“什么是经济学呢？”他站在讲台上，戴眼镜，灰西装，声音平静，典型的中年学者。\n\n台下坐的是大学一年级的学生，而我，是置身在这二百人大教室里偷偷旁听的一个。\n<!--more-->\n\n从一开学我就昂奋起来，因为在课表上看见要开一门《社会科学概论》的课程，包括四位教授来设“政治”“法律”“经济”“人类学”四个讲座。想起可以重新做学生，去听一门门对我而言崭新的知识，那份喜悦真是掩不住藏不严，一个人坐在研究室里都忍不住要轻轻的笑起来。\n\n“经济学就是把‘有限资源’做‘最适当的安排’，以得到‘最好的效果’。”\n\n台下的学生沙沙的抄着笔记。\n\n“经济学为什么发生呢？因为资源‘稀少’，不单物质‘稀少’，时间也‘稀少’，——而‘稀少’又是为什么？因为，相对于‘欲望’，一切就显得‘稀少’了……”\n\n原来是想在四门课里跳过经济学不听的，因为觉得讨论物质的东西大概无甚可观，没想到一走进教室来竟听到这一番解释。\n\n“你以为什么是经济学呢？一个学生要考试，时间不够了，书该怎么念，这就叫经济学啊！”\n\n我愣在那里反复想着他那句“为什么有经济学——因为稀少——为什么稀少，因为欲望”而麻颤惊动，如同山间顽崖愚壁偶闻大师说法，不免震动到石骨土髓格格作响的程度。原来整场生命也可作经济学来看，生命也是如此短小稀少啊！而人的不幸却在于那颗永远渴切不止的有所索求，有所跃动．有所未足的心，为什么是这样的呢？为什么竟是这样的呢？我痴坐着，任泪下如麻不敢去动它，不敢让身旁年轻的助教看到，不敢让大一年轻的孩子看到。奇怪，为什么他们都不流泪呢？只因为年轻吗？因年轻就看不出生命如果像戏，也只能像一场短短的独幕剧吗？“朝如青丝暮成雪”，乍起乍落的一朝一暮间又何尝真有少年与壮年之分？“急把盏，夜阑灯灭”，匆匆如赴一场喧哗夜宴的人生，又岂有早到晚到早走晚走的分别？然而他们不悲伤，他们在低头记笔记。听经济学听到哭起来，这话如果是别人讲给我听，我大概会大笑，笑人家的滥情，可是……\n\n“所以”，经济学教授又说话了，“有位文学家卡莱亚这样形容：经济学是门‘忧郁的科学’……”\n\n我疑惑起来，这教授到底是因有心而前来说法的长者，还是以无心来渡脱的异人？至于满堂的学生正襟危坐是因岁月尚早，早如揭衣初涉水的浅溪，所以才凝然无动吗？为什么五月山桅子的香馥里，独独旁听经济学的我为这被一语道破的短促而多欲的一生而又惊又痛泪如雨下呢？\n","tags":["散文","摘抄"],"categories":["life"]},{"title":"在 Windows 上真机调试 iPhone(iOS) Safari Web 页面","url":"/archives/30/","content":"\n\n在移动端页面开发中，需要处理 Android 和 iOS 的兼容性问题。在 Chrome DevTools 中选择手机模式，可以一定程度上模拟移动端的页面，但更多的只是方便进行页面布局的调试和兼容。一些移动端的特性与表现，在真机和模拟情况下还是有存在很大差别的（比如软键盘的弹出等），尤其是 iOS 出于某些“考虑”表现出不符合标准的 BUG，在 Windows Chrome 中更是难以定位。\n\n本文介绍如何在 Windows 系统中连接 iPhone Web 页面进行真机调试。\n<!--more-->\n\n## 工具资料\n\n* iPhone + 数据线\n* iTunes\n* Node.js 环境\n* remotedebug-ios-webkit-adapter\n* Chrome 浏览器（勿使用过低版本 Chrome）\n* 梯子（可能需要）\n\n## 环境准备\n\n实现真机调试主要是使用了 remotedebug-ios-webkit-adapter 这一工具，使用方法在其 [gitHub 主页](https://github.com/RemoteDebug/remotedebug-ios-webkit-adapter) 上有介绍，可以直接按照其官方说明安装使用。本文对其 Windows 下的安装使用进行了一些细节的补充和说明。\n\n### 安装 scoope\n\n[scoope](https://scoop.sh/) 是一个 Windows 命令行安装工具，类似 linux 下的 yum 或 apt-get。remotedebug-ios-webkit-adapter 的安装将使用该工具。\n\n使用 [powershell](https://docs.microsoft.com/zh-cn/powershell/)（powershell 是 Windows 预装的 Shell 工具）依次执行一下命令，安装 scoope：\n\n```powdershell\nSet-ExecutionPolicy RemoteSigned -scope CurrentUser\niex (new-object net.webclient).downloadstring('https://get.scoop.sh')\n```\n\n稍等片刻就安装成功了。如果安装失败，请尝试使用管理员权限执行。\n\n### 安装 remotedebug-ios-webkit-adapter\n\n使用 cmd、powershell 或 git bash 依次执行以下命令，安装依赖环境：\n\n```bash\nscoop bucket add extras\nscoop install ios-webkit-debug-proxy\nnpm install -g vs-libimobile\n```\n\n（这里默认你的电脑已经安装了 [Node.js](https://nodejs.org) 环境，否则 `npm` 命令将执行失败）\n\n安装 remotedebug-ios-webkit-adapter：\n\n```bash\nnpm install remotedebug-ios-webkit-adapter -g\n```\n\n安装成功后，你将能在命令行中使用 `remotedebug_ios_webkit_adapter` 命令\n\n### 安装 iTunes\n\n[访问官网](https://www.apple.com/itunes/download/)，下载 iTunes。这里注意 iTunes for Windows 提供两个版本，一个是从 Windows Store 下载，另一个是安装包。选择后者下载安装。\n\n## 连接调试\n\n1. 进入 iPhonse 中的 *设置 > Safari 浏览器 > 高级 > Web 检查器*，开启该选项。\n\n2. 打开 iTunes 并连接 iPhone，在 iPhone 弹框中选择信任该电脑。\n\n3. 打开命令行，执行以下命令，启动适配器：\n\n    ```bash\n    remotedebug_ios_webkit_adapter --port=9000\n    ```\n\n4. 在 iPhone 中打开 Safari 浏览器，打开待调试页面。\n\n5. 打开 Chrome 浏览器，进入 [chrome://inspect/#devices](chrome://inspect/#devices) 页面，在 Discover network targets 选项添加 localhost:9000 配置。刷新页面，这时页面中会出现 'Remote Target' 列表，该列表展示了 iPhone 中打开的页面，点击 inspect，即可进行调试。\n\n**注意**：如果第 5 步中未出现待调试页面，请重启 remotedebug_ios_webkit_adapter 工具，然后刷新或重启浏览器重试。\n\n## 说明\n\n在首次点击 inspect 打开真机调试工具时可能需要科学上网，否则可能出现 404 错误。\n\n命令行执行失败时，请尝试使用管理员权限，或查看其官网说明。\n\n请勿使用较低版本的 Chrome 浏览器\n\n该例中使用了 Windows 10、Chrome 73.0.3683.75、iOS 12.1.4。\n\n其他系统下的安装和使用请查看 [remotedebug-ios-webkit-adapter gitHub 主页](https://github.com/RemoteDebug/remotedebug-ios-webkit-adapter)。\n","tags":["Tools"],"categories":["developer"]},{"title":"日记-下雨天","url":"/archives/29/","content":"\n\n写篇日记吧。\n\n今天是 3 月 7 号，这个城市难得的没下雨的日子。\n<!--more-->\n\n我曾喜欢淅淅沥沥的雨天，在那样的雨天走在大学空旷的校园，清爽而安静。工作后，我再不喜欢下雨天。雨天让道路变的泥泞，弄脏我的鞋子。雨天披着雨衣骑车也得格外小心。路上的行人、车辆都变得急躁。匆匆忙忙地上下班，再没时间和心情去体味那些雨天的情愫。\n\n如果只是一个孤独的男生每天默默地上班，静静地下班，在雨中出没，一言不发；在这个多雨的城市，透过床边的窗户，静静地望着窗外湿漉漉的夜色，在沉默中度过一个又一个平静的夜晚，不思过去，不虑将来，努力地回避着与这个世界的交集，波澜不惊。那也本该是一件正常甚至有点酷的事情。\n\n但在人的一生中，总会遇到那么一些人突然闯入你的世界，把你从雨天温暖的房间里叫出来，拉出来，拖出来；不顾雨水打湿衣服，弄脏鞋子，在雨水里蹦啊，跳啊，带你看雨天最绚丽多变的奇景。你看着，想着，手足无措……\n\n那些景色，你耿耿于心不能忘了。你觉得你不应该就这样呆在房间里默默观赏窗外的景色。你也要跑出来，淋淋雨，踩踩水；哪怕衣服湿了，鞋子脏了，淋湿了头发感冒了，你也不后悔。你只是觉得你不应该错过这场雨。你也要为自己淋一场雨。\n\n我决定要离开这个城市，离开舒适的房间。向窗外的，我曾在模糊的记忆中憧憬过，却未曾追逐过的景色出发。即使有一天，我湿漉漉的又回到这里，把流逝的时光都当作笑谈，我也不会后悔。我不会告诉他们窗外的路有多泥泞，也不会告诉他们窗外的景色有多迷人，我也一样不会把我在雨中奔跑、嬉戏、跌倒、开怀大笑的心情告诉他们。他们不会相信，不会理解，也体会不到。在那之后，我大概依旧会在每一个雨天呆坐在窗边，望着窗外淅淅沥沥的雨景，好像一切都没有变。\n","tags":["散文"],"categories":["life"]},{"title":"Nginx 配置前端 HTML5 History 路由","url":"/archives/16/","content":"\n由于 Vue、React 等现代前端框架的前端 History 路由，在服务端并没有实际对应的物理路径和文件，所以使用 Nginx 的默认配置直接访问路由或刷新路由时，会导致 404 错误。\n\n<!--more-->\n\n在 Nginx 中使用 `try_files` 配置对不存在的文件或路径进行处理，返回指定文件即可解决 History 路由 404 的问题。\n\n以下针对几种情况给出配置示例，并简单讲解相关配置。\n\n### 前端项目在 Nginx 服务根目录下\n\n服务端目录结构如下：\n\n```txt\n+-- html\n    +-- index.html\n    +-- bundle.js\n```\n\nnginx 配置如下：\n\n```nginx-config\n...\n\nlocation / {\n    root   html;\n    try_files $uri $uri/ index.html;\n    index  index.html index.htm;\n}\n\n...\n```\n\n`location` 配置对访问路径进行匹配:\n\n```nginx\nSyntax: location [ = | ~ | ~* | ^~ ] uri { ... }\n        location @name { ... }\nDefault: —\nContext: server, location\n```\n\n`root` 指定请求对应在服务器上对应的根目录：\n\n```nginx\nSyntax: root path;\nDefault: root html;\nContext: http, server, location, if in location\n```\n\n`try_files` 配置将依次查找后面的文件或路径，不存在时查找下一个，因此最后一个文件必须存在，否则将产生 500 错误。\n\n```nginx\nSyntax: try_files file ... uri;\n        try_files file ... =code;\nDefault: —\nContext: server, location\n```\n\n`index` 指定该请求路径的索引\n\n```nginx\nSyntax: index file ...;\nDefault: index index.html;\nContext: http, server, location\n```\n\n这里使用 `try_files` 配置将不存在的路径访问统一返回了 `index.html` 文件，这样就交由前端项目进行 History 路由的处理。\n\n需要注意的时，如此配置后将不会产生 404 访问，因此前端路由中应对不存在的路由进行 404 页面的处理。\n\n### 前端项目在 Nginx 服务子目录下\n\n服务端目录结构如下：\n\n```\n+-- html\n    +-- project1\n    |   +-- index.html\n    |   +-- bundle.js\n    +--- project2\n        + -- index.html\n        + -- bundle.js\n```\n\n分别为 `project1` 和 `project2` 配置 `try_files`:\n\n```nginx-config\n...\n\nlocation / {\n    root   html;\n    index  index.html index.htm;\n}\n\nlocation /project1 {\n    root html;\n    try_files $uri $uri/ /project1/index.html;\n    index index.html index.htm;\n}\n\nlocation /project2 {\n    root html;\n    try_files $uri $uri/ /project2/index.html;\n    index index.html index.htm;\n}\n\n...\n```\n\n### 前端项目在其他目录下\n\n目录结构如下：\n\n```\n+-- nginx\n    +-- html\n    |   +-- project1\n    |   |   +-- index.html\n    |   |   +-- bundle.js\n    +-- project2\n        + -- index.html\n        + -- bundle.js\n```\n\n`project1` 和 `project2` 使用前端路由的配置如下：\n\n```nginx-config\n...\n\nlocation / {\n    root   html;\n    index  index.html index.htm;\n}\n\nlocation /project1 {\n    root html;\n    try_files $uri $uri/ /project1/index.html;\n    index index.html index.htm;\n}\n\nlocation /project2 {\n    root ./;\n    try_files $uri $uri/ /project2/index.html;\n    index index.html index.htm;\n}\n\n...\n```\n","tags":["Server","Nginx"],"categories":["developer"]},{"title":"IndexedDB 中文教程（2）基本使用","url":"/archives/2/","content":"\n\n[IndexedDB 中文教程（1）介绍](https://www.hozen.site/archives/1/)\n\n[IndexedDB 中文教程（2）基本使用](https://www.hozen.site/archives/2/)\n<!--more-->\n\n************\n\n教程持续更新中……\n\n本文将基于一些代码实例对于 IndexedDB 的基本用法进行介，为了教程的连贯性，一些原理性的内容和容易有疑问的地方并未展开，在文末将会对这些疑问进行解释和说明。\n\n## 连接数据库\n\n使用 `indexedDB.open()` 方法打开本地数据库，如果该数据库不存在，则创建该数据库。该方法接受两个参数：数据库名、数据库版本（可选的）。\n\n```js\nvar openRequest = window.indexedDB.open('hozen.site');\nvar db;\nopenRequest.onsuccess = function(event) {\n    db = this.result; \n    // db = event.target.result;\n    // db = openRequest.result;\n    console.log(\"打开数据库成功\");\n}\nopenRequest.onupgradeneeded = function(event) {\n    var objStore = this.result.createObjectStore('blog', {keyPath: 'url'});\n    objStore.createIndex('category', 'category'); // 创建索引\n    console.log('创建对象仓库完成');\n}\nopenRequest.onerror = function(event) {\n    console.log('打开数据库失败', event);\n}\n```\n\n`open` 方法是异步的，当打开成功时触发 `onsuccess` 事件，失败时触发 `onerror` 事件。当数据库升级时，触发 `onupgradeneeded` 事件。升级是指该数据库首次被创建，或调用 `open()` 方法时指定的数据库的版本号高于本地已有的版本。\n\n`onupgradeneeded` 处理函数对于创建数据库和修改数据库结构是很重要的，因为 IndexedDB 只允许在该函数内创建和删除 `ObjectStore` 或创建删除索引。一旦错过这个机会就无法在当前版本数据库中对数据库结构进行修改了。\n\n`db` 变量保存了打开数据库请求的结果，当打开数据库成功时将获取一个对象。该对象是对 IndexedDB 进行数据操作的基础，因此要及时保存它，并保证在需要的地方能调用得到。\n\n`createObjectStore` 方法创建了一个对象仓库，该方法接受两个参数：仓库名、配置对象（可选的）。该例中，使用配置对象指定了 'url' 为对象仓库的**内键**，其作用类似关系型数据库中的主键，需具有唯一标识性。该方法返回新创建的对象仓库。\n\n## 添加一条数据\n\n```js\nvar data = {\n    title: 'IndexedDB 教程（1）简介',\n    url: 'https://www.hozen.site/archives/6/',\n    categories: 'clientScript',\n};\nvar transaction = db.transaction('blog', 'readwrite');\nvar objectStore = transaction.objectStore('blog');\nvar addReq = objectStore.add(data);\naddReq.onsuccess = function() {\n    console.log('添加数据成功', this.result);\n}\naddReq.onerror = function(event) {\n    console.log('添加数据失败', event)\n}\n```\n\n这里我们直接将一个 JavaScript 对象 `data` 未加任何处理的存入了数据库。在该例中由于我们使用了内键，因此我们只能存储 JavaScript 对象（或者是因为我们只会存储对象，所以才使用了内键），并且其 `url` 属性是必须且唯一的。\n\n首先，通过 `transaction()` 方法获取一个事务，该方法接受两个参数。第一个参数作为事务的**作用域**，表示该事务跨越的对象仓库；第二个参数表示事务权限，这里需要一个读写权限。该方法返回一个事务对象。\n\n`objectStore()` 方法获取指定对象仓库，该方法一次只能获取一个对象仓库。\n\n使用对象仓库的 `add()` 方法像数据库添加数据，这同样是一个异步方法，触发响应事件处理函数。\n\n## 取出一条数据\n\n```js\nvar transaction = db.transaction('blog');\nvar objectStore = transaction.objectStore('blog');\nvar getReq = objectStore.get('https://www.hozen.site/archives/6/');\ngetReq.onsuccess = function() {\n    console.log('读取数据成功: ', this.result);\n}\ngetReq.oerror = function(event) {\n    console.log('读取数据失败', event);\n}\n```\n\n类似的，我们启动一个事务，然后获取一个对象仓库，调用它的 `get()` 方法读取数据，然后对成功和失败的情况做处理。但这里稍有不同的是，我们只需要一个“只读”事务即可（最小权限原则不仅是优秀的代码习惯，在 IndexedDB 对于跨作用域的情况也是有积极作用的，见文末）。\n\n`get()` 方法接受数据的键（key）作为参数，从数据库中查询对应的数据。如果查询成功，其结果会返回至请求对象的 `result` 属性中。数据为空返回 `undefined`。\n\n## 修改一条数据\n\n```js\nvar dataNew = {\n    title: 'IndexedDB 教程（1）简介',\n    url: 'https://www.hozen.site/archives/6/',\n    categories: 'clientScript',\n    alias: 'indexDB introduction',\n};\nvar transaction = db.transaction('blog', 'readwrite');\nvar objectStore = transaction.objectStore('blog');\nvar addReq = objectStore.put(dataNew);\naddReq.onsuccess = function() {\n    console.log('修改数据成功', this.result);\n}\naddReq.onerror = function(event) {\n    console.log('修改数据失败', event)\n}\n```\n\n这里的代码基本上和添加数据的代码一致，只不过我们向数据中新增了一个 `alias` 字段。然后调用了 `put()` 方法而非 `add()` 方法向数据库插入数据。如果这里我们再次使用 `add()` 方法将修改后的数据插入数据库时，请求会失败，因为已经存在一个 `url` 相同的数据。而 `put()` 则是不关心数据库是否已存在该数据（具备相同键的数据），总是把数据插入数据库，进而覆盖掉以前的数据，达到更新数据的目的。\n\n因此，在 IndexedDB 中更新数据实际上相当于用一个新的数据覆盖掉原来的数据，所以当我们只更新部分数据时，会先从数据库中取出原来的数据，然后修改该数据的属性，最后将该数据“put”进数据库。这和关系型数据库中 `UPDATE` 语法不太一样。\n\n## 删除一条数据\n\n```js\nvar transaction = db.transaction('blog', 'readwrit');\nvar objectStore = transaction.objectStore('blog');\nvar delReq = objectStore.delete('https://www.hozen.site/archives/6/');\ndelReq.onsuccess = function() {\n    console.log('删除数据成功');\n}\ndelReq.onerror = function(event) {\n    console.log('删除数据失败', event);\n}\n```\n\n同样我们需要启动一个事务来进行删除操作，`delete` 方法接受一个参数来删除对应的数据，该参数可以是一条数据的键，也可以是一个代表键范围的对象 [IDBKeyRange](https://developer.mozilla.org/en-US/docs/Web/API/IDBKeyRange)。删除成功时触发 `onsuccess` 事件，删除一个不存在的数据时，同样也会成功。\n\n## 批量操作\n\n### 批量插入\n\n使用循环来批量插入数据：\n\n```js\nvar transaction = db.transaction('blog', 'readwrite');\nvar objectStore = transaction.objectStore('blog');\nvar dataSet = [\n    {\n        title: 'IndexedDB 中文教程（1）简介',\n        url: 'https://www.hozen.site/archives/6/',\n        category: 'clientScript',\n    }, {\n        title: 'IndexedDB 中文教程（2）基本用法',\n        url: 'https://www.hozen.site/archives/7/',\n        category: 'clientScript',\n    }, {\n  title: '《和解》—— React 差异化算法',\n        url: 'https://www.hozen.site/archives/1/',\n        catefory: 'React',\n    }, {\n        title: '[译]严格判定JavaScript对象是否为数组',\n        url: 'https://www.hozen.site/archives/2/',\n        category: 'ECMAScript',\n    }, {\n        title: 'JavaScript设计模式(1)——单例模式',\n        url: 'https://www.hozen.site/archives/17/',\n        category: 'ECMAScript',\n    }];\n    \ntransaction.oncomplete = function() {\n console.log('所有数据插入成功'); \n};\n\ntransaction.onerror = function(event) {\n console.log('插入数据失败：', event);\n}\n\ndataSet.forEach(function(data) {\n    objectStore.put(data);\n});\n```\n\n上例中使用了事务的 `oncomplete` 事件，当事务完成时会触发该事件。\n\n### 查询所有数据\n\n使用 `getAll()` 可以进行查询对象仓库所有数据：\n\n```js\nvar objectStore = db.transaction('blog').objectStore('blog');\nvar getAllReq = objectStore.getAll();\ngetAllReq.onsuccess = function() {\n    console.log('所有数据', this.result);\n};\ngetAllReq.onerror = function(evnt) {\n    console.log('获取数据失败', event);\n};\n```\n\n该方法有两个可选参数，第一个参数指定查询范围 [IDBKeyRange](https://developer.mozilla.org/en-US/docs/Web/API/IDBKeyRange)，第二个参数限制返回数据的数量。\n\n相应的 `getAllKeys()` 可以获取所有数据的键。\n\n### 清空对象仓库\n\n在删除数据小节里已经提到，传入一个 [IDBKeyRange](https://developer.mozilla.org/en-US/docs/Web/API/IDBKeyRange) 对象参数给 `delete()` 方法可以实现范围删除。如果需要清空对象仓库，有一个更简单的方法：`clear()`。\n\n```js\nvar objectStore = db.transaction('blog', 'readwrite').objectStore('blog');\nvar clearReq = objectStore.clear();\nclearReq.onsuccess = function() {\n    console.log('清空成功');\n}\nclearReq.onerror = function(event) {\n    console.log('清空失败', event);\n}\n```\n\n## 使用游标\n\n使用游标可以对对象仓库中的数据进行遍历：\n\n```js\nvar objectStore = db.transaction('blog').objectStore('blog');\ncursorReq.onsuccess = function() {\n    var cursor = this.result;\n    if (cursor) {\n        console.log(cursor.value.title);\n        cursor.continue();\n    } else {\n        console.log('遍历结束');\n    }\n}\n```\n\n`openCursor()` 方法有两个可选参数，第一个仍然是一个 IDBKeyRange 对象来指定遍历范围，第二个参数用来指定遍历方向。当查询成功时，`cursorReq` 的 `result` 属性指向一个游标对象，该对象的 `key` 和 `value` 分别保存了查询数据的键值。调用 `cursor` 的 `continue()` 方法使遍历继续吗，当遍历结束时 `result` 得到 `null`。\n\n使用 `getAll()` 获取所有所有数据，然后对结果进行遍历获取 `title` 属性，也可以达到上例的目的。但如果我们只想获取 `key` 的值时，使用游标要比使用 `getAll()` 高效得多。\n\n相应的 `openKeyCursor` 可以用来获取数据的键。\n\n## 使用索引\n\n本文中的例子使用了 `url` 作为对象仓库的内键以保证不会重复，但不会重复的键大多不易记忆和查询。IndexedDB 提供了索引机制。\n\n```js\nvar objectStore = db.transaction('blog').objectStore('blog');\nvar index = objectStore.index('category');\nvar indexReq = index.getAll();\nindexReq.onsuccess = function() {\n    console.log(this.result);\n}\nindexReq.onerror = function(event) {\n    console.log(event);\n}\n```\n\n## 可能存在的疑问\n\n以上是一些基本的 IndexedDB 的 API，尽量避免了一些可能稍微复杂的概念和原理，但如果想解决实践过程中遇到的一些问题，这些原理必须要掌握。\n\n比如，新学者在使用 IndexedDB 的过程中可能会遇到以下问题：\n\n* 事务终止，无法调用\n* 请求一直处于 `pending` 状态，无法进行数据的版本升级\n* 启用不必要的事务，浪费性能\n* 事务跨作用域失败\n* 选择不合适的对象仓库类型\n\n这些问题的排查和解决需要对 IndexedDB 的请求机制，事务生命周期等内容有全面的了解。\n","tags":["ClientScript","indexedDB"],"categories":["developer"]},{"title":"IndexedDB 中文教程（1）介绍","url":"/archives/1/","content":"\n\n[IndexedDB 中文教程（1）介绍](https://www.hozen.site/archives/1/)\n\n[IndexedDB 中文教程（2）基本使用](https://www.hozen.site/archives/2/)\n\n教程持续更新中……\n<!-- more -->\n\n**参考*\n\n[1] *[《IndexedDB》](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API) - <https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API>*\n\n*****************\n\n## 概述\n\nIndexedDB 是一种 web 浏览器中持久存储数据的方法，是一种“[NoSQL](https://en.wikipedia.org/wiki/Object_database)”数据库。IndexedDB 提供了高性能的接口，适用于大量数据的本地读写和持久存储，对于开发可离线 Web\n应用意义非凡。\n\nWeb 本地存储有很多方法可选，早期可选的方法可能只有 cookie。但 cookie 的初衷并非单纯用来做本地存储的，而是用来记录一些用户身份信息，便于网站标识访问者身份。因此 cookie 的可用大小有限，并且会被 HTTP 请求携带，造成了不必要的网络性能开销，尤其是在较差的网络环境中，这些开销将导致极差的体验。\n\n在新的 HTML 标准中提供了 [Web Storage API](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API)，包括 [sessionStorage](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/sessionStorage) 和 [localStorage](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage) 两种机制。新的 API 配合 Ajax 在很多场景中完全可以替代 cookie，并且存储容量限制大大提高。两个接口不同的生命周期机制也提供了一定的方便。\n\n虽然不同于 cookie 的字符串存储的方式，Web Storage API 提供了键值对的存储方式。但对于复杂数据来说，依然只能通过格式化后的字符串去存储数据，这就决定了 Web Storage API 在进行复杂数据的修改和查询时很不方便。更关键的是，Web Storage API 是同步接口，会同步阻断浏览器 JavaScript 进程。当数据量比较大，或操作比较复杂时，这两个缺陷将会带来致命的性能问题。\n\n随着移动互联网发展和技术进步，用户和开发者对 Web 应用的期望越来越高，Web 应用需要承担越来越多的任务。体现在可离线应用和数据持久化方面，对于本地化数据存储的要求也越来越高。浏览器本地数据库被设计和实现出来，关系型数据库 [WebSql](https://www.w3.org/TR/webdatabase/) 出现了，大量的数据存储和对 SQL 语句的支持，大大提高了浏览器本地数据存储能力。\n\n2010 年 W3C 组织废弃了 WebSql，key-value 数据库 [IndexedDB](https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API) 成为其替代品。\n\n## 例子\n\n为了方便介绍和观察 IndexedDB 的结构和特点，我们先创建一个 IndexedDB 的简单实例。\n\n复制以下代码到 Chrome 中并执行。该代码将创建一个 IndexedDB 数据库，并建立一个 `ObjectStore`（对象仓库），同时存储了一条数据到数据库中。\n\n*可以不必在意代码的实现细节，后续会详细介绍。*\n\n```js\n(function () {\n  if (!window.indexedDB) {\n    console.log('浏览器不支持 indexedDB');\n    return;\n  }\n\n  var delReq = window.indexedDB.deleteDatabase('hozen.site');\n  delReq.onsuccess = initDB;\n\n  function initDB() {\n    var openReq = window.indexedDB.open('hozen.site');\n    openReq.onupgradeneeded = function () {\n      openReq.result.createObjectStore('blog');\n    }\n    openReq.onsuccess = function () {\n      var db = openReq.result;\n      var store = db.transaction('blog', 'readwrite').objectStore('blog');\n      store.add({\n        name: 'indexDB',\n        author: 'hozen',\n      }, 1);\n    }\n    openReq.onerror = function (e) {\n      console.log('打开数据库失败', e);\n    }\n  }\n})();\n```\n\n代码执行成功后，打开 Chrome 的开发者工具，在 Application 面板中找到 IndexedDB 选项，打开就能查看一个最简单的 IndexedDB 的样例了。\n\n有了这个例子，我们可以分析一些 IndexedDB 的显著特点。\n\n## 特性\n\n### 面向对象数据库\n\nIndexedDB 是不需要 SQL 语句来操控的，是面向对象数据库。\n\n从例子中可以看出，IndexedDB 数据库并不具备类似关系数据库的表结构和固定的字段。在同一个源下，可以存在多个不同名的数据库，每个数据库下包含若干个对象仓库（Object Store），对象仓库是 Key-Value 结构的。你可以将数据（甚至是 JavaScript 对象）存储到对象仓库中，需要时通过键或索引快速的读出数据。\n\n这种面向对象的设计，允许直接对 JavaScript 对象进行存取，使得数据库的灵活性大大提高，读取存储数据的格式转化成本也大大下降。也规避了关系型数据库中需求变更时，需要对表结构进行修改甚至重新设计的风险。\n\n### key-value 数据库\n\n与传统的关系型数据库不同，IndexedDB 是 kye-value 数据库。value 可以是非常复杂的对象，key 可以是对象自身的属性。可以对对象的某个属性创建索引来实现快速查询和列举排序。并且，key 的数据类型几乎没有限制，甚至可以是二进制对象。\n\n### 事务模式数据库\n\n对于 IndexedDB 数据的操作都必须在一个**事务**中完成，因此 IndexedDB **基本**（对于持久性，IndexedDB 在实现中是有一个默认的 BUG 的，参见）保证了原子性、一致性、隔离性和持久性，减少了数据混乱的机会。\n\n### 异步\n\nIndexedDB API 基本上是异步的。当对 IndexedDB 数据库进行读写等操作时，会向数据库发送一个操作请求，当操作完成时数据库会通过事件通知我们。这类似 Ajax 请求，这样的好处在于程序不会阻塞在数据库操作过程，对于大量复杂数据的操作，这一点是很重要的。\n\nIndexedDB 标准中提供了同步接口，但这些同步接口只能用于 [Web Workers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API)。\n\n### 同源策略\n\nIndexedDB 同样遵循同源策略，即对于不同的应用层协议、域名、端口产生不同的“源”。在不同的“源”之间，数据是不会相互干扰和作用的，在同一个“源”内所有的数据库都有唯一的名称。\n\n容易理解，同源策略是为了数据安全考虑。\n\n## 局限性\n\nIndexedDB 是有一些局限性的，下面的内容只是指导性的，一些特性和原因后面的教程中会进行解释。\n\n!**以下情况不适合使用IndexedDB**\n\n* 全球多种语言混合存储。国际化支持不好。需要自己处理。\n* 和服务器端数据库同步。你得自己写同步代码。\n* 全文搜索。IndexedDB 接口没有类似 SQL 语句中 LIKE 的功能。\n\n!**注意，在以下情况下，数据库可能被清除:**\n\n* 用户请求清除数据。\n* 浏览器处于隐私模式。最后退出浏览器的时候，数据会被清除。\n* 硬盘等存储设备的容量到限。\n* 数据损坏。\n* 进行与特性不兼容的操作。\n","tags":["ClientScript","indexedDB"],"categories":["developer"]},{"title":"秋天的味道","url":"/archives/26/","content":"\n\n前一天有人问我“什么时候会让你感觉到夏天结束了”的时候，我还答不上来。第二天早晨，我从衣柜翻出外套将要穿在身上时，才突然醒悟，喃喃道：“这就是秋天的味道”。\n\n<!-- more -->\n  秋天的味道就是，突然有一天早晨，你不得不搓着胳膊把衣柜底还没来得及晾晒的外套翻出来，衣服透着的淡淡霉味。你摸着它，感到一丝凉意，你甚至怀疑它一直保留着上个冬天的温度，让你恍惚——我又度过了一个夏天吗。也许这本该是冬天的味道，或初春的味道，但经过一个夏天的酝酿，它实实在在变成了秋天的味道。就像高温给予了熵变充足的热量，夏天加速了所有事情的进度。一件事的开始和完结，一个人的成长和老去，仿佛都在夏天里慢慢的积累，偷偷的进行，然后在夏天结束时突然显现，等你发现时早已无从追究。\n\n  以前的我有很多新鲜的事去做，有很多新鲜的感受去体验，有很多目标和将来去期待，我来不及体会也不在意一个季节带给我的感受，所以我并不明确地了解一个季节。现在的我虽然丝毫不比以前清闲，很多人很多事围绕在我周边，让我应接不暇。但能带给我新鲜感的事物反而越来越少，最终变成了一朵云，一阵雨，一条路，一片荒野，一个季节。而那些忙忙碌碌的人啊，却让我觉得简单得还不如一阵风。他们日日夜夜地挣扎着、煞有介事地扮演着，无非为了吃饭，为了活下去。但对于一阵风，我却永远不知道它为何而起，将吹到哪去，曾为谁停留，又将为谁忽而消散。\n\n  秋天让我感到了温暖。与夏天的燥热和冬天的寒冷不同，秋天从泛着凉意的风中走进房间里，或是晚上脱掉衣服卧进床里，或是早上出门时裹上宽大的外套，都会让人感到无比的温暖和满足。这与夏天吃冰棍，冬天泡温泉不同，这种平淡的温暖感觉很少会被人刻意记起、被人惦念心底。这让我不禁地想，人们为什么总喜欢矫枉过正，享受在一个极端里寻求另一种极端的快乐呢？这是一种征服感和成就感吗......\n\n  当你去认真地去思考一件事为什么会让你感到快乐时，你就很难从这件事里感受到真正的快乐了。也许我不应该去想这么多事情，去追究这么多的原因，毕竟让我感到真正快乐的事已经越来越少了。并且，当我认真地去想一件事为什么会让我感到难过时，这件事就再也无法真正的伤害到我了。这是多么让人沮丧的一件事。\n\n  秋天是收获的季节。但现在不是了。我无法从一栋高楼，一间办公室，一盆常绿的盆栽里看到收获。城市里的人在春天工作，在夏天工作，在秋天工作，在冬天工作，在每个季节做着同样的事，季节于他们来说意义寥寥。\n\n  我下班的路穿过一片拆迁区旁的田野，有一天我下班经过那时，突然想到家乡村头的田野。就像我上中学时每次放假回家，在朦胧的夜色中，我经过那条路。路的两旁种满庄稼，有时是小麦，有时是玉米，有时是土豆......我在不同的季节遇到不同的生命。我感受到他们默默的生长，傍晚的路上很难遇到几个人，风吹过时，地里的庄稼一起发出沙沙的声音，我和它们一样在风中摇头晃脑。\n\n  我曾在这片土地上长大，但我却对它们了解甚少。我不知道如何播种，如何灌溉，如何施肥，如何收割；不知道在每一场大风过后，如何把地里成片歪倒的玉米一一扶正；不知道在果树成熟的时候，深夜在林间茅草屋里守护的究竟是什么；不知道每场大雨过后的清晨，地头伫立的乡邻父老究竟在沉默里眺望着什么。我终于想明白我为什么要离开家乡，奔赴一个个陌生又遥远的城市，把家乡土地浸染在我身体里的那些元素消耗殆尽，在孤独与迷茫里怀念那些我从未踏足外面世界的日子。\n\n  不是我抛弃了乡土，是因为我无法像坚韧的先辈们一样照看好一片土地。我竭尽全力能做到的，只是看管好我自己。\n","tags":["散文"],"categories":["life"]},{"title":"Web 开发中如何终止一个 Http 请求","url":"/archives/25/","content":"\n\n\n在前端开发中，终止一个已经开始的网路请求是有一定应用场景的。尤其是在 [SPA (Signal Page Web Application)](https://en.wikipedia.org/wiki/Single-page_application) 单页面 Web 应用中，路由的跳转或场景的切换并不会像多页面跳转一样终止之前未被响应的网络请求。此时就可能会发生数据请求发生时的场景已经不存在，而网络请求成功后，数据被不正确的渲染在新的场景中的问题。因此应确保这些网络请求在场景变化后被终止或不被处理，以避免数据的混乱，提升部分性能。\n\n<!-- more -->\n本文介绍如何终止一个 XHR、Fetch 或 [Axios](https://github.com/axios/axios) 请求。（Axios 是一个基于 XHR 和 Promise 封装的 HTTP 库，可用于 Web 和 Node.js，如果你不使用它，则不必关心 Axios 的部分。)\n\n本文的完整 Demo 代码见于 GitHub: [hooozen/web-demo](https://github.com/hooozen/web-demo)。\n\n## 终止一个 XHR 请求\n\n[XMLHttpRequest](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest) （本文中 XHR  为其简写）被浏览器广泛支持，功能完整，稳定性强，在 Ajax 中大量使用。\n\nXHR 终止一个请求的操作是非常简单的，只需要调用该 XHR 实例对象的 `abort` 方法即可阻断当前未被响应的请求。\n\n```js\n/**\n * 发送 XHR 请求\n */\nfunction sendXHRRequest() {\n  xhr.open('POST', url);\n  xhr.onreadystatechange = function()  {\n    if (xhr.readyState === 4 && xhr.status === 200) {\n      console.log('XHR: ', xhr.responseText);\n    }\n  }\n  xhr.send();\n}\n\n/**\n * 终止 XHR 请求\n */\nfunction abortXHRRequest() {\n  console.log('尝试终止 XHR 请求');\n  xhr.abort();\n}\n```\n\n   XMLHttpRequest 代理有 4 种状态，XHR 的当前状态由 `readyState` 属性记录。XHR 总处于下列状态之一：\n\n| 值  | 状态             | 描述                                              |\n| --- | ---------------- | ------------------------------------------------- |\n| 0   | UNSET            | 代理被创建，但尚未调用 `open()` 方法。            |\n| 1   | OPENED           | `open()` 方法已经被调用                           |\n| 2   | HEADERS_RECEIVED | send() 方法已经被调用，并且头部和状态已经可获得。 |\n| 3   | LOADING          | 下载中，responseText 属性已经包含部分数据。       |\n| 4   | DONE             | 下载操作已完成。                                  |\n\n当调用 `abort()` 方法时，`readyState` 会被置为 DONE，然后该请求被终止，状态变为 UNSET 状态。因此，在调用 `abort()` 方法后，再次调用 XHR 发送请求，仍然可以正常响应（除非再次调用了 `abort()` 方法终止了请求），这一点和 Fetch API 终止请求是不一样的。\n\n## 终止一个 Fetch 请求\n\nFetch 请求返回一个 Promise 对象，而 Promise 有一个缺点就是一旦被“许诺”，要么被 `resolve` 要么被 `reject`，不可被终止。所以一开始 Fetch 是不支持被终止的，所以开发者们不得不使用其他的方法来达到“终止”的效果。后来新的标准增加了 `AbortController` 接口，来终止 DOM 请求，但该接口目前仍处于“实验中”，不建议在生产中使用。\n\n  接下来分别介绍这两种方法：\n\n### 使用 AbortController 终止 Fetch 请求\n\n   AbortController 是一个实验中的标准接口，提供 `abort` 方法来终止指定的 DOM 请求。\n\n```js\n/**\n * 开始 fetch 请求\n */\nfunction startFetch() {\n  var options = {\n    method: 'POST',\n    signal,\n  }\n  fetch(url, options).then(function (res) {\n    res.text().then(function (text) {\n      console.log('Fetch: ', text);\n    });\n  }).catch(function (error) {\n    console.log(error);\n  });\n}\n\n/**\n * 终止 fetch 请求\n */\nfunction abortFetch() {\n  console.log('尝试终止 fetch 请求');\n  controller.abort();\n}\n```\n\n  AbortController 实例化对象提供一个 `signal` 标记，当创建 Fetch 请求时，把该标记作为参数传入 Fetch 方法，则可以调用该实例化对象的 `abort()` 方法来终止被“标记”的 Fetch 请求。\n\n  与 XHR 的 `abort()` 方法不同的是，AbortController.abort() 方法一旦被调用，则被标记的 Fetch 不可再次发起请求，这一点和 Axios 中终止请求的机制是一致的。\n\n### 使用 Promise.race() 封装一个可“终止”的 Fetch\n\n  因为 Promise 不能被终止，而 AbortController 接口稳定性和兼容性又很差，所以更多情况下需要采取其他方法来模拟“终止”Fetch请求。使用 `Promise.race()` 方法在需要时跳过对 Fetch 请求结果的处理来达到“终止”请求的效果。\n\n> [`Promise.race(iterable)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/race) 方法返回一个 promise，一旦迭代器中的某个 promise 解决或拒绝，返回的 promise 就会解决或拒绝。)\n\n  利用 `Promise.race` 的“竞速”特性，封装一个可以被“终止”的 _Fetch 接口：\n\n```js\n/**\n * 封装一个模拟 abort 的 fetch\n * @param {接口地址} url \n * @param {fetch 选项} options \n */\nfunction _fetch(url, options) {\n  var abort = null;\n  var abortPromise = new Promise(function(resolve, reject) {\n    abort = reject;\n  });\n  var fetchPromise = fetch(url, options);\n  var promise = Promise.race([abortPromise, fetchPromise]);\n  promise.abort = abort;\n  return promise;\n}\n\nvar fetchAPI;\n\n/**\n * 开始 fetch 请求\n */\nfunction _startFetch() {\n  fetchAPI = _fetch(url, { method: 'POST' });\n  fetchAPI.then(function(res) {\n    res.text().then(function(text) {\n      console.log('_fetch: ', text);\n    });\n  }).catch(function(e) {\n    console.log(e);\n  });\n}\n\n/**\n * 跳过请求处理\n */\nfunction _abortFetch() {\n  console.log('\"终止\"_fetch请求');\n  fetchAPI.abort('abort 竞速成功');\n}\n```\n\n  上面代码封装了一个 `_fetch` 方法来进行网络请求，在`_fetch().then()` 中对网络请求进行处理。`_fetch` 方法返回了一个 `Promise.race()` Promise，并在该 `race()` 中使用了一个 `abortPromise` Promse 来与 `fetch` Promise“竞速”。并将 `abortPromise` 的 `reject` 方法暴露出来。所以当调用被暴露出的 `reject` 方法时，如果此时 fetch 请求还没有完成（即没有被 resolve，或 reject），那么由于 `Promise.race()` 的“竞速”特性，`_fetch` 将返回 `abortPromise` 的 `reject`，fetch Promise 将被忽略。\n\n  需要明确的是，上述方法并没有真正意义上终止一个网络请求，实际上网络请求没有受到任何影响，只不过通过封装的方法“跳过”了对希望被终止的请求的处理。这一点是和 XHR 和 AbortController 的 `abort()` 方法不同的。\n\n## 终止一个 Axios 请求\n\n  Axios 提供了终止网络请求的方法，具体介绍可见官方文档中的 [cancellation](https://github.com/axios/axios/blob/master/README.md#cancellation) 部分，下面提供一个例子并对文档中未介绍的内容进行一些补充。\n\n```js\nvar CancelToken = axios.CancelToken;\nvar source = CancelToken.source();\n\n/**\n * 开始一个 Axios Post 请求\n */\nfunction axiosPost() {\n  axios.post(url, undefined, {\n    cancelToken: source.token,\n  }).then(function(res) {\n    console.log('Axios: ', res.data);\n  }).catch(e => {\n    console.log('Axios error: ', e);\n  });\n}\n\n/**\n * 终止一个 Axios 请求\n */\nfunction abortAxios() {\n  console.log('尝试终止 axios 请求');\n  source.cancel('axios 被终止');\n}\n```\n\n  Axios 的 `cancel()` 方法实现的效果类似于 AbortController 接口的 `abort()` 方法，即一旦该方法被调用，则该实例就不再被允许再次发送网络请求。但 Axios 网络请求是基于 XHR 实现的，终止网络请求的方法也是调用了 XHR 的 `abort()` 方法。之所以其效果和 `XHR.abort()` 终止后仍可再次请求的效果不一致，是因为 Axios 基于 Promise 进行了封装，一旦调用了 `cancel()` 方法，Promise 就会抛出异常，并且被记录。下次再次调用该实例进行请求时，会直接抛出异常，不会发起网络请求。具体实现方法请查阅 [Axios 源码](https://github.com/axios/axios)。\n","tags":["ClientScript","XHR","Fetch API","Axios"],"categories":["developer"]},{"title":"webpack4 打包“块”的分离","url":"/archives/24/","content":"\n\n当不使用外部插件时，webpack 会把 `webpack.config.js` 配置文件里每个入口打包一个 `[entry].js` 文件，这意味着单页面应用（单入口）最终只会打包生成一个 `js` 文件。而很多情况下，这种处理并不是最佳的处理方式。比如会造成单个 `js` 文件体积过大，并且每次项目迭代都会造成全量 `js` 的更新，不能充分利用缓存。所以我们需要按照一些规则，对打包输出的“块”进行拆分，已达到优化性能的目的。\n<!--more-->\n\nwebpack4 中 SplitChunksPlugin 插件提供了对打包文件进行拆分的功能。\n\n为了对打包后生成的所有文件有全面的了解，本文第一小节先讲解了 `runtimeChunk` 配置的作用。\n\n> Originally, chunks (and modules imported inside them) were connected by a parent-child relationship in the internal webpack graph. The CommonsChunkPlugin was used to avoid duplicated dependencies across them, but further optimizations were not possible\n\n以上为 [Webpack官方文档](https://webpack.js.org/plugins/split-chunks-plugin/) 对为什么在 webpack4 后移除了 `CommonsChunkPlugin` 而使用全新的 `splitChunksPlugin` 插件的解释。\n\n本文以 `webpack v4.16.2` 为例，一些配置选项在低版本中可能无效。\n\n## runtimeChunk\n\n设置 `optimization.runtimeChunk` 为 `true` 能为每一个入口添加一个额外的“块”，该块是应用“运行时”（runtime）依赖块。\n\n该配置有两个配置选项：\n\n* `single`：为所有的块创建一个共享的“运行时”（runtime）文件。\n* `multiple` 为通用的块创建多个运行时文件。\n\n默认值为 `false`，即每个入口块嵌入 runtime 依赖，而不是单独将它分离成一个独立的块。\n\n## SplitChunksPlugin\n\n### 默认配置\n\n若不加以配置，webpack4 会自动使用 `splitChunks` 对资源块进行拆分，默认拆分规则如下（来源 [Webpack 官方文档](https://webpack.js.org/plugins/split-chunks-plugin/#defaults)）：\n\n* 块被多处引用**或者**来自 `node_modules` 目录\n\n* 块大小大于 30kb（压缩前）\n\n* 按需加载的块并行请求数不能大于 5 个\n\n* 初始化加载的块并行请求数不能大于 3 个\n\n也就是说 splitChunks 只会拆分被多次引用的块，或者该块来自于 `node_modules` 目录；并且该块在压缩前的大小应大于 30kb，否则不拆离。同时，最后两个条件对并行请求数做出了限制，这就意味着为了满足后两个条件，可能会产生体积较大的块。\n\n### 默认配置的例子\n\n当不对 `optimization.splitChunks` 进行任何自定义配置，将`optimization.runtimeChunk` 设置为 `true` 时，对一个单页面多路由应用进行打包时，产生了如下 `js` 文件：\n\n```bash\ntotal 941\n 24 chunk.0.dec7f9a819944483d79d.js\n  4 chunk.1.eae64cbc2aa0f9e4e783.js\n  4 chunk.10.f8750d707c27b95bae13.js\n 24 chunk.11.2aef84c3ff12c183b072.js\n  4 chunk.2.21418087238bcf98e494.js\n  4 chunk.3.545ceaa63e410a4b2d59.js\n  4 chunk.4.8ca9fe6ed85d546daba4.js\n  8 chunk.5.1fa9e53fb286828383a7.js\n  4 chunk.6.50e9186b6024c98d9f30.js\n  1 chunk.7.a737ccfe76e044e4e6e7.js\n  8 chunk.8.af950ea9507f49c156e4.js\n  4 chunk.9.238ddb8be097a6200372.js\n800 chunk.app.7c6ddec2161a37416ecb.js\n 44 chunk.main.c54944c0d51e726f5c37.js\n  4 runtime.26028abb8f1fadc57c34.js\n```\n\n`css`文件：\n\n```bash\n  4 chunk.1.b853c7844b6e82e97c6b.css\n  4 chunk.10.ece96fde52d6f0024d0a.css\n  8 chunk.11.3917cb3b5334910b2ca9.css\n  1 chunk.2.e9364a9f3d011dd5312b.css\n  4 chunk.5.d93fa41defa698bc9435.css\n  4 chunk.6.e52a594a36b4ef3fe490.css\n  1 chunk.7.52ac776fd2423a0a7c72.css\n  8 chunk.8.04f1836d396f81ffec4c.css\n  4 chunk.9.52d5fcfb3d22a54ccf0b.css\n320 chunk.app.eea3b0fe4cd81c07d6d8.css\n 20 chunk.main.f451462a7e2cced31c33.css\n ```\n\n入口文件 `index.html` 如下：\n\n```html\n<!DOCTYPE html>\n<html lang=zh-CN>\n\n<head>\n  <meta charset=UTF-8>\n  <title>惠税-助手</title>\n  <meta name=viewport content=\"width=device-width,initial-scale=1\">\n  <script>window.SYART_TIME = new Date().getTime();</script>\n  <link href=./static/css/chunk.app.eea3b0fe4cd81c07d6d8.css rel=stylesheet>\n</head>\n\n<body>\n  <div id=app></div>\n  <script type=text/javascript src=./static/js/runtime.26028abb8f1fadc57c34.js></script>\n  <script type=text/javascript src=./static/js/chunk.app.7c6ddec2161a37416ecb.js></script>\n</body>\n<script>window.LOAD_TIME = Date.now() - window.startTime;</script>\n\n</html>\n```\n\n其中，`chunk.[number].[hash]` 文件是各个路由页面的块，他们将在需要时被按需加载。`chunk.app.[hash]` 块则是入口文件初始化加载所依赖的块，`chunk.main.[hash]` 是 splitChunks 将整个应用中被多次引用的公共内容分离出来，这样能避免相同的文件被多次请求。\n\n`runtime.[hash].js` 文件即是第一节中提到的“运行时”依赖块，当把 `optimization.runtimeChunk` 设置为 `false` 时则不会生成该块。\n\n### 小结\n\n> Default configuration was chosen to fit web performance best practices but the optimum strategy for your project might defer depending on the nature of it.\n\n官方文档中建议使用默认配置，认为默认配置是最佳实践。然而有些时候默认配置并不能完全满足项目需求，可能需要一些自定义的配置。\n\n### 自定义配置\n\n`splitChunksPlugin` 插件提供了配置参数，使得开发者能够对包进行自定义配置和拆分块。\n\n```js\nmodule.exports = {\n  //...\n  optimization: {\n    splitChunks: {\n      chunks: 'async',  // all async initial 选择对哪些块进行优化\n      minSize: 30000,  // 被拆分的最小大小（压缩前）\n      minChunks: 1,  // 被共享的最小次数\n      maxAsyncRequests: 5,  // 最大按需求并行请次数\n      maxInitialRequests: 3,  // 最大初始化并行请求数\n      automaticNameDelimiter: '~',  // 自动命名分隔符\n      name: true, // 自动为块命名\n      cacheGroups: {\n        vendors: {\n          test: /[\\\\/]node_modules[\\\\/]/,\n          priority: -10\n        },\n        default: {\n          minChunks: 2,\n          priority: -20,\n          reuseExistingChunk: true\n        }\n      }\n    }\n  }\n};\n```\n\n其中 `cacheGroups` 选项支持对块进行进一步的自定义分割，其中的配置默认继承于 `splitChunksPlugin.*` 配置，在内部进行配置将覆盖继承配置。其中 `test` `priority` 和 `reuseExistingChunk` 是 `cacheGroups` 特有的配置。\n\n`test` 选项对要打包的文件进行选择，一般是一个正则表达式。类似 `loaders` 配置里的 `test`。\n\n`priority` 设置该配置组的优先级。一个模块可能属于多个 `cacheGroups`，这时优先将其打包入高优先级的块中。\n\n`reuseExistingChunk` 如果该块已经从主块中分离出来了，则将直接重用该块，而不是重新生成，不过可能会影响块的命名。\n\n## 总结\n\n以上就是 Webpack4 中打包分离“块”的配置方法。之所以要进行“块”的分离，是因为一些代码可以被公用，将他们分离出来可以避免重复加载；同时，一些基本不会改动的基础支持被分离出来时，当项目迭代时，这些基础块可以从缓存中获取，减少流量费用。另外，适当的将较大的“块”拆成多个较小的“块”有利于发挥现代浏览器并行下载资源的优势，提高资源加载速度。\n\n除了适当的对“块”进行拆分，充分利用缓存、模块按需加载、开启 Web 服务器的 Gzip 压缩等方法也是提高 Web 应用加载和响应速度的常用方法。\n","tags":["Node.js","webpack4","splitChunksPlugin"],"categories":["developer"]},{"title":"Git 子模块 submodule 的使用","url":"/archives/23/","content":"\n\nGit 子模块具有一定的应用场景。\n\n比如在一个项目 P 中，该项目被分为两部分，由 A 和 B 两个团队并行开发。而 B 团队开发的内容属于公共支持类的项目，不止会被该项目使用，其他项目也可能会使用。因此 B 团队开发的内容不可能和团队 A 共用一个仓库。因为这样的话别人拉取该公共内容时会连带拉取不需要的内容。而 A 团队项目的开发又依赖于 B 团队所做的内容，并希望能随时获得团队 B 得最新成果。\n\n <!--more-->\n此时使用 Git 的子模块功能能较好的解决该问题。\n\nGit 得子模块功能允许把一个仓库作为另一个仓库得子目录。\n\n## 概述\n\n子模块常用得命令很简单，该文章完全学习于 Git 的官方文档[《Git 工具 - 子模块》](https://git-scm.com/book/zh/v1/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97)。本文对官方文档进行了提炼。\n\n## 常用命令\n\n### 添加一个子模块\n\n```bash\ngit submodule add <url> path\n```\n\n此时会在根目录下创建 `.gitmoudules` 文件，该文件保存了子模块的相关配置。如下：\n\n```bash\n[submodule \"themes/next\"]\n path = themes/next\n url = git@github.com:hooozen/hexo-theme-next.git\n```\n\n添加完毕后，即拥有了一个子模块。可以在子模块进行代码的修改和提交和拉取等操作。\n\n需要注意的是，当在上层仓库执行 `commit` 操作时，该仓库会记录子模块的提交记录，但也仅限于此。上层仓库并不会跟踪子模块里的文件。\n\n所有的 git 命令，在两个仓库里独立工作。\n\n### 克隆一个带子模块的项目\n\n`git clone <url>`\n\n将上层仓库克隆下来，子模块仅仅被拉取了一个文件夹，里面没有任何内容。接下来要执行两个命令：\n\n`git submodule init`\n\n初始化本地配置文件\n\n`git submodule update`\n\n拉取子目录所有数据，并检出上层仓库里所列的提交。\n\n之后每次需要更新子模块仓库时都需运行 `git submodules update`。子模块并不会随上层目录的更新而一起更新。\n\n### 需要注意的问题\n\n1. 上层仓库只保持对子模块的一个记录，而不会跟踪内部文件。\n\n    上层仓库（后简称 A 仓库）只会保留子模块（后简称 B 仓库）的一个提交记录（即 HEAD 指针值）。所以当在 A 仓库拉取更新时，B 仓库的内容并不会得到更新，而是只是更新了 B 仓库的 HEAD。当执行 `git submodule update` 命令时，B 仓库才会从远程仓库拉取所有数据，并根据 A 仓库中对 B 仓库的 HEAD 记录检出需要的文件内容。\n\n2. 子模块拉取失败的原因\n\n    有上文可知，A 仓库仅仅记录一个 HEAD 值。所以当一个开发者在本地的 B 仓库里做了代码的修改，并提交，但**未推送**到远程仓库。他随后在 A 仓库中进行了提交和**推送**，此时 A 仓库会记录 B 仓库在该开发者本地的一个 HEAD。当其他开发者尝试通过 `git submodule update` 更新 B 仓库时，会发生错误，因为此时 B 仓库的 HEAD 所指向的提交只存在于第一个开发者的本地。\n\n    此时，你只能查看是谁提交了本次更改，然后联系他，教育他一下。\n\n3. 在子模块里工作要格外小心\n\n    因为在上层仓库里进行 `git submodule update` 时会将子模块检出至一个游离的 HEAD，这可能导致你在子目录里提交但未在上层仓库提交的工作丢失。这种情况仍可以使用 `git reflog` 命令去查找出那个游离的 HEAD。但仍要避免这种失误出现。\n","tags":["Tools","Git"],"categories":["developer"]},{"title":"大学毕业","url":"/archives/58/","content":"\n<!--more-->\n\n![长安](/assets/images/58-1.jpg)\n\n![软件一班](/assets/images/58-2.jpg)\n\n> 清风拂渭水，明月满长安。\n","categories":["timeline"]},{"title":"别君去兮何时还","url":"/archives/22/","content":"\n\n一\n\n我要毕业了。\n\n从这个学期还没开始，我就因这件事的逼近而惶惶不可终日。我从未对毕业有过如此惶恐的感觉。\n<!--more-->\n\n当几个月前我只身一人前往南方陌生城市实习时，这种惶恐感便愈演愈烈了。\n\n出发当天的情形还历历在目。\n\n破旧的夹层候车室里挤满了形形色色的人，唯独没有像我一样的年轻人。他们拖着行李麻袋，各自说着晦涩的家乡话，眼神疲劳而戒备。我开始感到不安，我不知道铁路的另一头那个完全陌生的城市等着我的会有什么，或者没有什么。\n\n开始检票时，人群涌向检票口，检票员很敷衍，我努力从对侧口袋拿出车票在她眼前晃了晃，她并不理会。人群推着我向前走，我很快融入了他们之中。久违的茫然若失感涌上心头。\n\n我在读高中时放假的夜晚常常有这种感觉。高中住宿，半月回家一次，有时贪玩打球到天黑才离开校园。当我走出校门，住在附近的同学纷纷归家，欢声笑语顷刻消失，清冷和孤寂迅速将我包围。我看着车水马龙，灯光霓彩的城市，不知道还能不能搭上归家的末班车——那时的我总有一种感觉：出了学校的大门我便什么都没有，什么都不是了——这个我上了五六年学的城市其实从未真正感受到过我的存在......\n\n火车的汽笛声将我从那些清冷的夜晚扯回，我才发现，原来那种孤单无依的感觉从未从我的心底消散，它一直潜伏在那里，在许多年后当我以为自己已经百炼成钢时突施冷箭，令我猝不及防、踉跄中伤，却又给我种老友重逢的欣慰。\n\n就这样，我陷入对寂冷往事的回忆中踏上了人生中第一次驶往南方的火车。\n\n二\n\n在南方的第一个晚上，我并没有感受到“人人尽说江南好，游人只合江南老”的自在惬意，相反辛弃疾“落日楼头，断鸿声里，江南游子.....”的词句在我脑海里久久徘徊，挥之不去。同样二十出头的年纪，同样是齐鲁子弟，同样的“江南游子”，让我不得不想起辛弃疾，想起他“看试手，补天裂”的英雄气概，也想起他“无人会，登临意”的落寞孤寂。\n\n> 同为弱冠年，离乡入江南。\n>\n> 未有家国恨，何故戚戚然?\n\n突然只身奔赴千里之外，从简单宁静的校园进入热烈喧嚣的城市，今后的路当如何走？我终究会成为什么样的人？我没有任何答案。\n\n三\n\n几经折腾，租到了一间公寓里的小单间，置办好起居用品，终能于偌大城市中得一隅安静和舒适，也算是一些慰藉和安定吧。\n\n但就在刚得一些安定感的晚上，一切收拾妥当，洗漱完毕准备睡觉时，我不小心把自己锁在了房门外，手机行李钱包证件外套全在房间内，房门的密码我还没来得及重置，如果不能联系到中介我是进不去了。我低头看了看身上的牛仔裤暗自庆幸——幸亏我还穿着裤子。于是我穿着单薄的衣服出了门，当我终于赶到中介门面时，他们早已经下班打烊了。在杭州湿冷的冬天里，我再次驻足在灯光霓彩的城市街头，为回家而忧虑。不一样的是，这次我连一件能御寒的外套都没有......\n\n当我端着一纸杯热水，披着旅店老板的外套，打着颤向旅店老板娘讲述我的遭遇时，老板娘和店里两个清洁工笑得竟然比我抖得还厉害。我趁着身体还在打颤赶紧跟着笑了起来——那个深夜里，要不是他们帮了我，我大概只能在收容所度过一晚了。\n\n在杭州实习的那几个月，我感受到许多从前从未留意的东西。其中最多的便是对家乡，对家人的眷恋。独自一人在陌生的城市，一切都要格外小心，一切都会颇费周折。流感发高烧自己去医院排五个小时的队，晚上顶着灼烫的嗓子不停的起床烧开水；食物中毒两眼金星也要自己搜索附近的医院下楼叫车。\n\n我不是一个不能吃苦的人，也是一个乐意独处的人，但当下班后，从完全没有个体意识的紧张集体工作突然进入完全自我的状态，那种感觉正如几年前那些朋友们顷刻散去后的夜晚。而如今，这种状态可能会持续一周、一个月甚至更久都不会被打破。在这些完全独处的长久时间里，你被迫不停地观察自己，审视自己，任凭一些感触在心中郁郁累积，不得消遣。此时你会想念那些和家人坐在一起吃晚饭，看电视的场景；想念和街邻坐在家乡傍晚的路旁吹着晚风，看星空的时光。在这些光景里，即便不说话你也能感受到那来自人与人之间温暖的默契在彼此销蚀着苦难生活中的郁结。\n\n四\n\n当有过孤身一人奔赴一个举目无亲的陌生城市的生活经历后，我才渐渐发现原来人的一生一直都是一场孤单的旅行。每个人有自己不同的轨迹，过去和你并肩过的人不会出现在你的未来，未来遇到的人又无法了解你的过去。终其一生，只有自己才是自己最忠实的旅伴。\n\n然而人总要向前走，无论是踌躇满志的积极前行，还是不知不觉的随波逐流，甚至是并不情愿的被推着向前。在这过程中总要失去些东西，也总会收获点东西，这是自然而然，无需纠缠的。回顾大学这几年，我着实前进了很多，多到以至于我回忆起几年前的自己都有些氤氲不清而难以在记忆里捉摸了。在这途中经历了生离，也经历了死别；经历了初识，也经历了重逢；痛苦和快乐参杂着，越来越多的是平淡和释然。\n\n这一路走来，难免有极不情愿的被推着走的时候，难免有被迫丢掉的东西，但终归都是自己选择的结果。选择了坚韧便丢失了一些勇气，选择了沉稳便放弃了一些机会，选择了简单就少了一些快乐，选择了收敛就少了一些光芒，选择了孤独就少了一些温暖。\n\n来不及停留，下一站便赫然眼前——毕业如期而至，纵使我曾惶恐不安，曾依依不舍，曾怅惘反侧。我终究要告别我的学生时代，告别轻松自在的岁月，告别单纯赤诚的自己。\n\n既别君兮不思还。\n","tags":["散文"],"categories":["life"]},{"title":"我们为什么构建React","url":"/archives/19/","content":"\n\n现在已经存在很多 JavaScript MVC 框架了，为什么我们还要创建 React 并且你为什么会去用它？\n<!--more-->\n\n## React 并不是一个 MVC 框架\n\nReact 是一个构建合成式用户界面的库。它鼓励创建可重用的 UI 组件，这些组件能跟随数据变化进行展示。\n\n## React 不使用模板\n\n通常，Web 应用使用模板或 HTML 指令来构建用户界面。这些模板主导了所用你可以用来构建用户界面的抽象集合。\n\nReact 允许通过把用户界面拆分成**组件**来进行构建。这意味着 React 使用了真正的、全功能的编程语言来渲染视图，这样一来相对模板语言具有一定优势，原因如下：\n\n- **JavaScript 是一个灵活的，强大的具有抽象能力的编程语言**。这在大型应用中非常重要。\n\n- 通过统一你的标记和它所对应的视图逻辑，React 实际上可以使视图**更容易扩展和维护**。\n\n- 通过将标记和内容解释成 JavaScript，这里就**没有手动的字符串插入**，因此降低了 XSS 漏洞的暴露面积。\n\n我们同样提供了 JSX，一个可选的语法扩展，如果你喜欢使用 HTML 的易读性来书写原生 JavaScript。\n\n## 即时更新非常简单\n\n当数据随着时间更新时，React 会跟随着变化。\n\n在一个传统的 JavaScript 应用中，你需要去监控什么数据发生了改变，然后立刻操作 DOM 节点来确保视图和数据保持一致。即使 AngularJS，也需要通过指令和数据绑定提供一个声明式的接口[需要绑定一个函数来手动更新 DOM 节点](https://code.angularjs.org/1.0.8/docs/guide/directive#reasonsbehindthecompilelinkseparation)。\n\nReact 采用不用的方法\n\n当你的组件第一次初始化，`render` 方法被调用，生成轻量级表现形式的视图。通过这个表现形式，标签字符串被生成，然后插入到文档中。当数据发生变化时，`render` 方法再次被调用。为了确保更新的高效性，我们将上次和本次 `render` 方法的返回值进行比较，然后生成最小的变化来应用到 DOM 结构中。\n\n> `render` 方法的返回值既不是字符串也不是 DOM 节点 —— 它是一种对 DOM 结构轻量级的表述方法。\n\n我们把这个过程叫做**和解**。通过[这个 jsFiddle](http://jsfiddle.net/2h6th4ju/)可以查看一个关于**和解**如何进行的实例。\n\n因为重新渲染是如此的快速（大概 1 毫秒），开发者无需去明确的声明数据绑定。我们已经证实该方法使得构建 APP 变得简单。\n\n## HTML 仅仅只是开始\n\n因为 React 拥有对文档独有的轻量级表述方式，我可以利用它做一些非常酷的事情：\n\n- Facebook 有许多渲染在 `<canvas>` 而不是 HTML 上的动态图表。\n- Instagram 是一个完全由 React 和 `Backbone.Router` 构建的“单页” web 应用。设计者定期使用 JSX 语法贡献 React 代码。\n- 我们已经有了一个内部项目原型，该项目使用 Objective-C 作为桥接，使得 React 应用可以运行在一个 web 工作环境中，并使用 React 去驱动**原生 IOS 视图**。\n- 你可以[在服务端](https://github.com/petehunt/react-server-rendering-example)运行 React 来做 SEO、性能优化、代码分享等很多灵活性的内容。\n- 在所有浏览器中（包括 IE 8）具有统一的、标准的、兼容的行为表现，并且自动使用了[事件委托](http://davidwalsh.name/event-delegate)。\n\n请浏览[https://reactjs.org](https://reactjs.org)来了解我们构建了哪些东西。我们的文档是面向如何使用框架一步步构建应用的，但如果你对其中的实现原理感兴趣，请[联系](https://reactjs.org/community/support.html)我们！\n\n感谢阅读!\n\n### 译者按\n\n该文翻译自 [React 官方博客](https://reactjs.org/blog/all.html)中的[Why did we build React?](https://reactjs.org/blog/2013/06/05/why-react.html)，发布于 2013 年 6 月 5 日，作者为[Pete Hunt](https://twitter.com/floydophone)。\n","tags":["转载","React"],"categories":["developer"]},{"title":"捕梦 - 尼尔·盖曼","url":"/archives/18/","content":"\n\n有个和尚独居在山腰上的寺庙旁。庙很小，和尚很年轻，这山也算不上日本的名山峻峰。\n\n和尚打理着寺庙，生活宁静安闲。直到有一天，一个狐狸和一只狸猫从庙旁经过，看到和尚正耕种着他赖以为生的一小块山药地。\n\n狸猫看着和尚和寺庙，开口道：“让我们打个赌。我们中要是有谁能把这和尚从庙里赶走，就可以据此为家；已经很多年没有香客旅人到庙里来了，这地方总比狐穴狸巢要好。”\n\n<!--more-->\n\n狐狸绿眸一眨，展颜一笑，露出了尖牙；她甩甩毛茸茸的尾巴，从山上望下去，看了看这庙，还有这和尚；然后她望着狸猫说：“好啊，就说定了。”\n\n“我们轮流来，”狸猫说，“我先去。”\n\n在那块小小的菜园中，和尚犁完了山药地，又跪下身为野葱、生姜和一小片药圃清理杂草。\n\n接着，他掸净手和膝盖上的泥土，走回寺庙后厢的居所，准备晚课。\n\n那晚，夜空的颜色好像熟透的车子；满月高悬好似银盘。和尚听到门外一阵喧嚣。\n\n院子里站了五个人，一个个鲜衣怒马，须发膨张。\n\n为首的擎着一口大刀。\n\n“谁是此间住持？”他高声断喝，有如惊雷，“速速出来见我！”\n\n和尚走上前去，来到月光之下，深施一礼，“贫僧无德，正是此地守护，”他淡然说。\n\n“好个瘦小枯干的和尚，”为首的喝道，“但又有谁能参透神佛的宏旨？诚如斯言，追名逐利者实乃捕风捉影；淡泊世事之人，倒常有鸿福在门外鸣锣。”\n\n和尚对这番话未置一语，只是略略抬头，望向月光下的大汉。\n\n什么事都逃不过这双炯炯有神的眼睛。\n\n“那好，你可想知道自己运势何在？”\n\n“自然，”和尚言道。\n\n“那就听好，差我们来找你的并非旁人，正是天皇陛下。你须即刻启程，赶往皇宫，天皇要与你面谈，好确定你是不是星官卜者对他讲起的那个人。如果没搞错的话，你便就此飞黄腾达，官及宰丞——一个足以赢得富贵荣华、广厦豪宅的地位。”\n\n“但你也要记得，若是猴年的次日，你还没有赶到皇宫，运势就会由盛转衰、恕我直言，天皇必会处你极刑。故而不要耽搁，黎明前就动身。不然若是犯了圣怒，谁也救不了你。”\n\n说话间，五匹战马在满月银辉下踩响了蹄子。\n\n和尚又施一礼。\n\n“我这就动身，”他说。\n\n那五个骑士咧嘴笑了起来，月光照亮了他们的眼睛和牙齿，也照亮了战马的铁辔鞍髻。\n\n“但在我动身前，还有一事相询。”\n\n“还有何事？”为首的问道，声如虎啸山林。\n\n“为何天皇要派一只狸猫来宣我进殿，”和尚问道。\n\n虽然前四匹骏马的尾巴毫无异状，但他早巳看出最后那匹却长着一条狸猫的尾巴。话音未落，和尚就大笑起来。他随即走回庙里，开始自己的晚课。\n\n院子里一阵蹄声响过，大汉们拔马而逃。山坡上传来了桀，桀，桀，的声音，那是一只狐狸幸灾乐祸的尖啸。\n\n次日，正午未至，黑沉沉的浓云已经遮蔽山颠。所以落雨时，和尚一点都不吃惊。\n\n这场瓢泼大雨打弯了竹子，压倒了新长出的山药苗。\n\n和尚早巳习惯山上变幻无常的天气。尽管白炽的闪电眩人眼目，喑哑的雷鸣仿佛自山腹滚出，但他丝毫不为所动，继续着自己的颂课。雨势更大，犹如敲响上百面小鼓。\n\n在这滂沱雨声中，和尚几乎听不到抽噎声，但他确实感觉有人在哭泣。\n\n和尚走出寺庙，院中的土地被大雨浇成了泥汤。一名少女躺在那里，她精美的丝袍早被雨水浸透，湿漉漉得贴在身上，就像第二层皮肤。和尚察觉到少女的玲珑曲线、曼妙身姿，心中忐忑。他搀扶着女子走进寺庙，那里堪可避雨。\n\n“我是山城大名的独生女，”她站在小小的火炉旁，拧着自己的衣袍和乌黑的长发，“我本是由一群侍从、婢女陪着要来这座寺庙，但途中遇上了匪人。我一个人逃了出来。另外我偷听到他们说等雨停了，就要到山上来把寺庙付之一炬，还要杀光这里的每个人。”\n\n她说话间吃了和尚的一碗米饭，和一小碟山药。她吃起饭来狼吞虎咽，同时还用明亮的绿眸盯着和尚看。\n\n“故而，”她说，“趁匪人没来，我们赶快跑吧，永远也别回来。如果我们待在这儿，终究难逃一死。要是我们在路上走散了，那你就到山城去找我父亲，他是那里的大名，住在城里最奢华的宅邸中。他会给你重赏的。多谢你的米饭，很好吃，可惜山药有点干了。”\n\n“那我们可要赶紧上路了，”和尚嘴角漫出一丝温柔的笑意，“但我还有一事相询。”\n\n“还有何事？”女孩问道。\n\n“请告诉我，为何山城大名的女儿是一只狐狸，”和尚说，“我可从没在凡人脸上见过这样的双眸。”\n\n话音未落，女孩就从火炉上跃了过去。她落地时已不再是女子，而是一只狐狸。皮毛顺滑，尾巴高竖，它非常轻蔑地瞥了和尚一眼，随即跳上石墙，顺着它跃上一株虬结老松，在那里驻足片刻，便消失在暴雨之中。\n\n下午晚些时候，太阳爬出浓云，和尚绕着寺庙拣拾起落叶残枝，修茸着暴雨造成的损伤。正是此时，他辨识出一个符记。所以过了几天，当太阳落山后，一群妖魔晃晃悠悠地穿过树林，围住小庙时，他也并不吃惊。\n\n这些妖魔中，有些顶着死人的头颅，有些长着怪兽的脑袋，黄牙巨角，两眼放光；它们发出的吵嚷呼啸声，你肯定未曾听闻。\n\n“俺们闻到了人味！”它们高喊道，“俺们嗅到了新鲜的人肉！把那人带出来，俺们要吃了他——烤了他的五脏六腑，还有脑仁；大嚼他的眼珠、脸蛋和口条；吞了他的肝脏、肥肉和阳物！把他带出来！”\n\n说话间，有几个妖魔开始把和尚收集起来的残枝败叶高高堆起，将自己灼热的呼息吹在上面，直到枝条冒烟，开始燃烧。\n\n“要是我不出去呢？”和尚喊道。\n\n“那俺们每天日落后都要回来，”一个妖魔啸道，它的脑袋好像剥了皮的蝙蝠，“吵得你不得安生，等俺们不耐烦了，就烧了你这座小庙，再从灰堆中扒出你焦黑的尸首，用俺们的尖牙把它咬碎！”\n\n“快滚吧！”另一个妖魔嚷道，它的脸是个溺毙的死人，肌肤囊肿，双目白似珍珠，“离开这地方，永远别再回来！”\n\n但和尚没有跑。他反而走进院子，从火堆中捡起一根燃烧的树枝。“我不会离开寺庙，”他说，“而且我已经厌倦了这些鬼把戏。好了，无论你是狐狸还是狸猫，尝尝这个！还有这个！”他说着挥舞起火棍。\n\n转眼之间，那群妖魔所站的地方，就仅剩下一只衰老痴肥的公狸猫，它跌跌撞撞地开始逃跑。和尚把燃烧的树枝扔向狸猫，打中了它的背，烧掉了它尾巴上的毛，还烤焦了它的屁股。狸猫哀嚎一声，消失在夜色之中。\n\n黎明时分，和尚在半睡半醒间听到背后传来一阵低语。\n\n“我要向你道歉，”这声音说道，“是狸猫和我打了个赌。”\n\n和尚沉默不语。\n\n“狸猫已经跑到别的藩国去了，它的尾巴被烧掉了，颜面扫地，”女孩的声音说，“如果你有意的话，我也会离开。我的洞穴就在瀑布上面，一株虬结老松旁边。我在那儿住了很久，离开它难免让我难过。”\n\n“那就留下吧，”和尚说，\n\n“只要你别再和我耍那些愚蠢的狐技淫巧。”\n\n“当然，”女孩的低语声从和尚身后传来，过了片刻他又坠入梦乡。\n\n半个时辰后，和尚徐徐醒转，发现屋中的草席上有狐狸的脚印。和尚不时能在矮树丛间看到狐狸，她的身影总会让他会心一笑。\n\n但和尚并不知道，狐狸已经深深地爱上了他。\n\n那是在她来道歉时，也许更早些，是在和尚将她从泥泞的庭院中挽进庙宇，用炉火帮她烤干时。但无论自何时而起，狐狸无疑是爱上了这名年轻的和尚。这就是日后诸般祸事的缘由。\n\n那将是一段奇妙的故事，让人心碎神伤。\n\n彼时，在人间行走之物，如今我们鲜少见闻。\n\n鬼魅、妖魔，和诸多灵体；大神、小神，还有兽神；各种觉识、存在，魂灵和生物。有善亦有恶。\n\n夜阑人静，月过中天，狐狸正在山腰捕猎。\n\n她忽然看到，在一株被雷打过的松树旁，有几点蓝光闪烁。\n\n她向这些光点窜了过去，迅疾如影，一尘不惊。\n\n当她靠近后，蓝光化作奇异的生灵。它们非生非死，浑身上下都裹在闪耀的蓝色妖气中。\n\n这些生灵正在低声私语。\n\n“我们已然领命，”为首的说道，蓝光在它裸露的肌肤上跃动不休，“和尚注定要死。”\n\n狐狸驻足潜踪，隐身在一丛灌木之后。\n\n“正是，”第二个说道，它的牙齿像一把把锋利的小刀，“我主是身具大能的阴阳师，他通过观察星相风水，已经看出，在下一次月盈之时，他与和尚之间，注定要死一个。如果和尚不死，那厄运就要落在我主头上。”\n\n“但，他怎可能会死？”第三个说道，\n\n蓝色火光在它的眼中升腾，“嘘！是不是有什么东西在偷听我们说话？我觉得有人在看我。”\n\n狐狸屏住呼吸，矮身趴在地上，静静地躺着。\n\n这三个妖灵飞上天空，俯瞰着黑暗的树林。\n\n“除了只死狐狸，什么都没有。”为首的说道。\n\n一只苍蝇落到狐狸的额头上，漫慢爬上她的鼻尖。\n\n狐狸压抑住咬它的冲动，仍旧躺在那里一动不动，眼神涣散空茫，像个死物。\n\n“我主打算如此这般，”为首的说，“连续三夜，和尚都会发噩梦。第一晚，他会梦见一个匣子。第二晚，他会梦到一枚黑匙。第三晚，他会梦到用黑匙拧开匣子上的锁。这时，在梦中，他将打开匣子，随即丧失与现世的一切羁绊。无食无水，死期不远也。我主不会为他的死而负疚，”它又环顾四周，“你确定没人偷听吗？”\n\n苍蝇爬上了狐狸的眼珠。尽管她觉得奇痒难忍，但却一眨不眨。\n\n“谁能听见我们说话？”第二个生灵问道，“狐狸的尸体？”它说着大笑起来，这声音高亢辽远。\n\n“有人听见也无妨，”为首的说，“即便真有人听到，若他把我们这番话说给旁人，不等第一个字出口，他的心就会在胸中爆裂。”\n\n一股冷风吹过山颠。东方的天空泛起鱼肚白。\n\n“但和尚真没法子逃过这一劫吗？”第三个生灵问道。\n\n“只有一个办法，”第二个说。\n\n狐狸全神贯注倾听着接下来的词句，但此后再无话音传来，多一个字都没有。她只能听见山风卷起落叶时的私语，树木在风中摇曳吐纳时的叹息，还有远处小庙中风打锺铃发出的叮吟。\n\n狐狸像一段残枝，僵直地躺在原地。\n\n直到日上三竿，她才甩甩尾巴，舔落爬上脚掌的蚂蚁，一路跑下山坡，来到她的洞穴。\n\n这里清冷黑漆，充满泥土气息，洞中藏着她最珍贵的宝物。\n\n狐狸是在几年前找到它的。\n\n那时，它缠在一株参天古树的根须中。\n\n她又挖又咬，用了几天的工夫，才把它完全刨出地面。\n\n狐狸用粉舌将它舔净，用绒毛将它磨光，带回了自己的洞穴。\n\n在这里，狐狸敬奉它，保养它，把它视作珍宝。\n\n这件器物古老非凡，来自遥远的国度。\n\n这是个龙形玉饰，双眼镶着细小红石。\n\n这件龙饰为她带来安宁。它红色的眼珠在洞穴微光中闪烁，散发出一股暖意。\n\n狐狸用嘴拾起她的珍宝，轻柔地叼着它，就像叼着一只自己的幼崽。\n\n她把玉饰咬在嘴里，走了很远的路，来到一座海边的悬崖旁。\n\n她能听到海鸥在头顶呜叫，也能听到身下的冷涛拍打岩石，还能嗅出空中飘荡的盐味。\n\n“这是我最珍贵的宝物，”她暗自想道，“现在我把它献出，献给大海，只求知道如何拯救和尚的性命。因为如果我置身事外，他就会梦到一个匣子，接着是一枚钥匙，然后是用钥匙打开匣子，最终他将死去。”\n\n狐狸用鼻尖将玉饰轻轻推落，看着它在空中翻滚，落下百尺高崖，落入波涛汹涌的海中。\n\n她轻叹一声，因为这小小的龙饰曾为她的洞穴带来平静与安宁。\n\n狐狸又走了很远回到自己的洞穴，她感到疲惫不堪，很快就沉沉睡去。\n\n以下是狐狸的梦境。\n\n她站在一处贫瘠荒原，到处都是灰褐色的岩石，寸草不生。\n\n天空同样是灰蒙蒙的，既不明亮，也不昏暗。\n\n在她面前的一块巨石上，蹲着一只硕大的狐狸，从头至尾都如墨玉漆黑，只有尾尖上生有一簇白毛，好像在白漆桶里浸过一样。他大愈猛虎，大愈战马，大愈狐狸见过的任何生灵。\n\n他蹲坐在岩石上，好像在等待着什么。\n\n他的双眼就像两个黑洞，遥远的星辰在其中闪烁、燃烧。\n\n狐狸在岩石间跳跃穿梭，来到梦之狐的面前。\n\n她俯下去，翻过身，将自己的喉咙显露给他。\n\n起身，巨狐说道。起身，莫怕。你为梦到此梦，已付出良多。\n\n狐狸站了起来。尽管她的恐惧超过了任何小狐狸的经历，但在梦中，她没有颤抖。\n\n“我的龙，”她问，“是属于您的吗，陛下？”\n\n不，他说。但它是一位我称之为友的故人，在很久很久以前遗失的。那还是在真龙离开尘世，翱翔天宇之前。我友弄丢了这件宝物，整天忧心仲仲。\n\n现在大海将玉饰冲还给他，他将在巨渊之底，他的族其之中，睡得更加安稳，直到下个纪元来临。\n\n“有幸为尊友效劳，实乃无上荣光，”狐狸说。\n\n小狐狸和黑巨狐，在梦疆中静静地矗立了几瞬。\n\n小狐狸看了看四周的岩石荒原。\n\n“那些是什么动物？”她问道。\n\n那群动物体型如狮，正在岩石上爬行，将它们的长鼻子深进贫瘠的土地嗅探。\n\n名字是貘，巨狐说。它们是食梦兽。\n\n小狐狸听说过貘。\n\n如果一个人从蕴藏恶兆或是恐怖之物的梦中醒来，他可以尝试唤来貘，寄希望于这种幻兽会吃掉迷梦，将它和它所彰显的征兆一起带走。\n\n她注视着在梦疆的岩石荒野上游走的貘。\n\n“如果有人能在貘吃掉一个梦之后将它抓住，”狐狸问，“那会怎样？”\n\n巨狐一时无语。远星在它空茫的眼眸中闪烁。\n\n貘很难捉，更难控制。它们是灵巧矫捷的动物。\n\n“我是只狐狸，”她谦卑地说道，一点没有吹嘘的意思，“我也是灵巧的动物。”\n\n巨狐点点头，垂眼望向她。\n\n狐狸觉得他能将自己看透，能看到她所有的梦境、期冀和感怀。\n\n他只是个人，巨狐说，而你是孤狸。这种事少有善终。\n\n狐狸本想敞开心扉，告诉他自己的想法。\n\n但巨狐一甩长尾，从岩石上跳到下面的荒原。\n\n在小狐狸眼中，他愈长愈大，直到充斥天宇。\n\n此刻，巨狐便是这夜，星辰在他的黑玉皮毛上闪烁，白色的尾尖变成了一轮残月，挂在夜空之中。\n\n“我很灵巧，”小狐狸对夜说，“我会鼓起勇气，会为他而死。”\n\n狐狸觉得头顶传来一句几近温柔的话语。那就去捕它的梦吧，孩子！接着，他转醒过来。午后艳阳像个熔金光球，擦亮了整个世界。\n\n狐狸钻进树丛，朝小庙走去，只在溪水旁停留了片刻，三口两口便连皮带骨吞下一只大青蛙。\n\n然后她又如饥以渴地舔饮了些清凉洁净的山泉。\n\n当她来到小庙时，和尚正在为他的火炉砍劈柴。\n\n和尚的斧子很快，所以小狐狸和他保持着适当的距离，开口说道：“愿你这几天都有美梦，梦到吉兆和好运。”\n\n和尚冲狐狸笑笑。“多谢你的祝福，”他说，“但我可说不清自己能不能梦到吉兆。”\n\n狐狸用她的绿眸凝视着和尚。“要是你需要我的话，”她最后说道，“我就在附近。”\n\n年轻的和尚从劈柴堆上抬起目光，但狐狸已经悄然无踪。\n\n小城位于遥远的西南方，阴阳师的宅邸就在此间。\n\n他坐在家中，燃起几案上的油灯。桌面铺了一方彩绘丝巾，上面摆着一个漆匣和一枚黑木钥匙。\n\n五个小磁盘，按照东西南北中五方基位码好。\n\n其中三个放个某种粉末，另一个盛有一滴液珠，最后的碟子则空无一物。\n\n阴阳师位高权重，富可敌国。请他占卜或是求他帮忙的人络绎不绝。很多藩国的大名都坚信，是阴阳师的影响力和算术让自己获得了如今的财富与权势，将他敬若上宾。就连大相国和左右大臣都对他言听计从。\n\n但阴阳师不是个快乐的人。\n\n阴阳师有位妻子，就住在庭院的北厢。她可谓贤良淑德，对阴阳师百依百顺，把家中大大小小的事务都打理得很好。\n\n阴阳师还有个刚满十七岁的小妄，她美貌绝伦，双唇艳若桃李，肌肤白胜凝脂。他的妻子和小妾同住在一个屋檐下，却相敬如宾，从不争吵。但阴阳师不是个快乐的人。\n\n人们都说他所住的宅院华美恢宏，在京城里可排第十七位。\n\n妖鬼和天狗，这些风界的精怪，都遵从他的号令，任他差遣。阴阳师能记起前两世的经历。\n\n当他还是个年轻人时，就不远万里到中国去修行。\n\n他回来后须发皆灰，但满腹阴阳之术已无人能及。\n\n他被高位者敬重，被下位者惧怕。\n\n但尽管如此，阴阳师不是个快乐的人。\n\n这皆因为他存恐惧。\n\n从他还是个黄毛小儿，刚能记事时起，就心存恐惧。\n\n他所学的每样本领，所获得的每分力量，都是因为想用来赶走恐惧。但恐惧依然，附在他背后，藏在他心里。入睡时，恐惧伴他而眠：醒来后，恐惧正等着向他请安。\n\n无论在饮酒时，沐浴时，还是同房时，恐惧都如影随形，不离不弃。\n\n这恐惧并非对死亡的惧怕，因为在他心中，死亡也许正是解脱。他过去也曾动过这样的念头：若是凭借法术屠尽这世上的男女老少，也许能得以安宁：但他还是觉得，即使绝世孤立，恐惧仍要纠缠在他心头。\n\n是恐惧在驱使他，是恐惧将他推进黑暗之中。\n\n阴阳师曾向荒冢秽灵求教，也曾在晨昏之际与畸形的怪物相会，随它们的步调起舞，分食它们的飨席。\n\n京城的郊外，贱民集聚，盗匪横行。\n\n阴阳师在此处置有一处废宅，里面住着三个女人：一名年老，一名年轻，还有一名既不年老也不年轻。\n\n她们平时靠向走霉运的村妇出售药草为生。\n\n乡野传言说，那些晚上在此间借宿的无知旅人，日后都无人得见。\n\n可想而知，谁也不知道阴阳师和这三个女人的瓜葛，更不会知道在那些月黑风高的夜晚，他常造访此地。\n\n从阴阳师的心底来看，他并非奸任恶人。\n\n他只是被吓坏了。恐惧带走了幸福与骄傲带来的每丝快乐，吮尽了生命中的欢愉。\n\n故事发生的几旬前。一夜，月正黑沉，阴阳师来到废宅，向三个女人讨教最让他烦扰的问题。\n\n寒风吹进破窗，在残损的屋檐间呼啸。\n\n“我如何能找到安宁？”他向最老的女人发问。\n\n“冢中自有安宁，”她说道，“欣赏日落美景时，也有片刻心安。”\n\n她赤身裸体，乳房像两个空口袋一样垂在胸前，脸上绘着妖魔的面容。\n\n阴阳师眉头紧锁，满面怒容，焦躁不安地在掌中敲打着折扇。\n\n“为何我总不得安宁？”他向最小的女人发问。\n\n“因为你还活着，”词句自她冰冷的双唇吐出。\n\n三个人中，他最怕这少女，因为阴阳师觉得她是个死物。\n\n少女很美，但却寒若霜雪。每次她用冰冷的手指碰触阴阳师时，都会让他颤栗。\n\n“我在哪能找到安宁？”他向中年女子发问。\n\n她并未赤身，但衣袍宽解，胸前挺着两排乳房，如同母猪雌鼠，乳头黑硬像块块炭石。\n\n她自齿间深吸一口气，屏息凝神，许久之后才慢慢吐出。\n\n接着女人说道：“东北方的美浓，从这儿走要用很多很多天。那里的某座山上有个寺，庙小地偏鲜有人知，只有一个和尚在打理照看。他生来无所畏惧，自有你渴望的安宁。现在我可以织成一方丝巾。如此一来，等他死后你就能得到他的力量，再也无须畏惧。但自我织就时算起，到下一次月盈之前，你必须将和尚置于死敌。而且他不能死于刀剑血光，也不能有丝毫痛楚，否则织巾就会失效。”\n\n阴阳师满足地咕哝一声，亲手喂她吃了几件精致美食，抚摸着她的长发，告诉她如此安排他很满意。\n\n三个女人退到这座倾颓屋舍的另一个房间，她们回来时已是晨曦将至，天空开始放亮。\n\n她们给了阴阳师一方白如月光的丝帕。\n\n那上面绘着阴阳师和月亮，还有那名年轻的僧人。\n\n阴阳师点点头，感到心满意足。他本要向女人们道谢，但却明白凡人决不能向这等生灵致谢，所以他只是将报酬放在房子的草席上，在拂晓前快步赶回家中。\n\n他通晓很多杀人千里的法门，但其中大部分虽说并不直接涉及刀兵血灾，却也必会带来苦楚。\n\n阴阳师查阅了他的卷宗，接着差遣手下魔物到和尚所住的山中，为他取来和尚碰过的器物。\n\n（狐狸就是在那时听到了它们的谈话。）而此时此刻，阴阳师坐在几案前，油灯、漆匣和钥匙就摆在上面。\n\n一个接着一个，他把五个磁盘中的东西一撮撮加到灯火上。\n\n这些磁盘盛着的物事都不相同。\n\n最后加入的是魔物从和尚身上偷来的东西：它就盛在那空无一物的碟子里——魔物偷来的，是和尚的一片影子。\n\n阴阳师每在灯火中加上一撮，它就燃烧地更高更亮；当他把最后一点和尚的影子加进去时，焰火升腾，光亮充盈着整个房间。片刻之后，火光褪去，屋里只剩黑暗。\n\n阴阳师点起灯，欣喜地看到铺在桌上的方巾多了一块难看的污点，就像某种死物趴在年轻和尚的脸上。\n\n他满意地观赏片刻，随即走回床榻，安稳地睡了一夜，没有恐惧。这一晚，他很满足。\n\n是夜，在梦中，和尚站在他父亲的宅邸里。\n\n这似乎还是在他父亲获罪失势，丢掉这宅邸和所有财物之前——他的父亲有很多位高权重的敌人。\n\n父亲向他深深一躬。\n\n在梦里，和尚记起父亲早巳自尽身亡，同样也记得自己尚在人世。\n\n和尚试图把这些都告诉父亲，\n\n但他父亲却无言地示意自己听不到儿子对他说得任何言语。\n\n接着，他从袍服中取出一个小漆盒，递给自己的儿子。\n\n和尚接过彩饰漆匣后，父亲已经消失不见。\n\n但他没有多想，因为这漆匣占据了他的全副心神（不过，在梦中，他似乎瞥见一扇敞开的房门后面狐尾一闪）。\n\n他知道盒子里有些重要的东西，一些他必须要看的对象。\n\n但他想尽办法，也打不开这匣子：越是努力，就越感挫败。\n\n和尚醒来时，觉得心绪烦乱惴惴不安，不禁揣测这梦境是不是某种预兆或警示。\n\n“如果这是场噩梦，”和尚说，“希望貘能把它带走。”\n\n他随即起身，出去打水，开始一天的生活。\n\n第二天夜里，和尚梦见祖父来找他。\n\n可是很多年前，他的祖父就在吃米饼——一种糯米糕点时噎死了，那时的和尚还在襁褓之中。\n\n他们站在海中一座小岛上，这岛黑黢黢的，比一块岩石大不了多少。他的祖父睁着一双盲眼，眺望人海。飞沫泼溅，海风呼号，海鸟在空中悲鸣。\n\n祖父张开一只苍老的手，展示出一枚小小的黑匙。\n\n他将手递出，动作缓慢得好像一件机械玩具。\n\n和尚从祖父手中接下钥匙。\n\n一只海鸥悲呜三声，渐飞渐远。\n\n和尚本想问问祖父这是什么意思，但老人已然消失。\n\n和尚紧紧握着钥匙。\n\n他环顾四周想找个和黑匙匹配的东西，但这座岛荒芜贫瘠，空无一物。\n\n和尚慢慢踱过小岛，什么也没找到。\n\n这时，在梦中，和尚觉得自己正被窥视。\n\n他四下张望，可梦中寂寥无人，只有在天空翱翔的海鸥，还有遥远悬崖上的一个纤细身形，和尚觉得那可能是只狐狸。\n\n他醒来时，手里握着一枚并不存在的钥匙，被狐狸注视的感觉仍挥之不去。\n\n这场梦如此逼真。这天晚些时候，凉风将枫树上第一批或橙或红的叶片吹落到寺庙的窄小菜园中，和尚正在那里照料着或黄或白的葫芦。\n\n他忽然发觉自己正环视四周寻找那枚钥匙，这才慢慢想起，在尘世中，自己从没碰过或是见过它。\n\n那天夜里，和尚等待着另一场黑沉迷梦。\n\n他闭上眼睛时，听到屋外有些响动，没过多久便睡了过去。\n\n上半夜，他什么也没梦到。\n\n而后半夜他梦见自己站在一座小桥上，看着两尾鲤鱼在一汪池塘中惬意嬉游。\n\n其中一尾纯白如银，另一尾橙黄若金。\n\n和尚看着它们，觉得心绪安宁。\n\n和尚醒来后，揣度这梦是个吉兆，也相信前几日的黑梦就此告终。\n\n他展开笑颜，兴高采烈地从睡席上爬了起来。\n\n和尚的好心情一直保留到他被狐狸绊到。\n\n小狐双目紧闭，就趴在寺庙的门坎上。\n\n起初，和尚以为她死了。\n\n他蹲下身后，却发现狐狸还一息尚存，很浅很慢，几乎看不出是否在呼吸。但毕竟她还活着。\n\n和尚把狐狸抱进小庙，放在火炉旁让她取暖。\n\n接着他向佛陀默祷，为狐狸的性命祈福。\n\n“她虽是个野物，”和尚想道，“但心地良善，我不能眼看着她死。”\n\n和尚抚摸着狐狸如蓟花冠绒般柔软的皮毛，感受着她微弱的心跳。\n\n“我还是个孩子时，”和尚对昏迷中的狐狸说，“那是在我父失势之前。我常瞒着奶妈和师长，偷偷跑到集市上去。那里有很多活物在卖：我在那些竹笼里见过各种各样的动物。有狐狸、狗和熊，有小猴子、红脸猕猴。野兔和鳄鱼，有蛇。野猪和鹿，有苍鹭、白鹤，还有小熊崽。我喜爱动物，所以看到它们时，心里很是快活。但这也让人难过，它们被关在笼子里的样子，令我心痛不已。”\n\n“一天，当商人们收摊离去后，我发现了一个破损的笼子，里面有只刚出生不久的小猴，它瘦得皮包骨头，已经死了，连个水罐都换不来——至少某些人是这么想的。但我发现它还活着，就把它藏在衣服里，一路跑回家。”\n\n“我把猴子养在卧房，从自己的食物中省下些羹饭喂它。我的小猴子就这样慢慢长大，最后个头几乎和我一样高。它是我的朋友。它会坐在我们屋外的柿子树上等我回家。父亲容下了这只猴子，一向平安无事，直到有一天，一位大名来家里找我父亲。”\n\n“猴子好像发了疯一样。它不肯让大名靠近我的父亲。它跳下树，挡在那人面前，吡着牙，露出胸膛，就好像他是来自另一个猴群的敌人。”\n\n“大名向一位随从示意。尽管我苦苦哀求，那人还是拉开弓，一箭射穿了猴子的胸膛。我将猴子抱出宅院，它注视着我的双眼，就这样死去了。”\n\n“后来，我父的失势，就是出于这位大名的阴谋。有时我在想，也许那只猴子并不是猴子，而是阿弥陀佛派来保佑我们的守护灵，但只有当我们学会聆听和观察，它才能真正行使护卫之责。这是很久以前的事了，小狐狸，在我出家之前，那段我已弃绝的生命之中。但人总要吸取教训。”\n\n“也许，你玩弄的那些狐技淫巧，只是想要保护我。”\n\n和尚说完，开始向阿弥陀佛颂经祷告；然后又向鬼子母神祷告，她在遇到佛陀前是个夜叉，如今却是女子与孩童的守护神；他还向大日如来祈求：最后，和尚向宾头卢尊者咏诵了一篇简短经文，他是佛陀的弟子，罗汉首座，被佛陀禁止涅盘往生。\n\n他向所有这些神佛祷告，为了小狐狸，祈求他们的看护与悲泯。\n\n诵经已毕，狐狸还是软塌塌地躺在草席上，一动不动，像个死物。\n\n山脚下有个小村，大概半天的路程。\n\n“也许，”和尚想，“村子里会有医师抑或智妇，可以救狐狸的命。”他未加多想，抱起瘫软的狐狸，开始向山下的村庄走去。\n\n天气清冷，和尚在轻薄的僧袍中瑟瑟颤抖。\n\n晚秋的苍蝇，是一年中最后、最老、最大也是最讨厌的苍蝇，它们围着和尚嗡嗡乱转，跟着他一路飞下山去，让他烦扰不已。\n\n路程过半，山间的溪流汇成小河，水面上横着座木桥。\n\n和尚走过去，看到桥上走来一位老者。他有一部银白长髯，还有很长很长的眉毛。他走路时拄着一根弯曲的长拐棍，眉宇间充满智慧与祥和，但又有一丝顽劣，至少和尚这么觉得。\n\n老人在桥上驻足，等和尚走近。\n\n“此季的枫树很美，”他说，“斑斓多彩，稍纵即逝。有时我觉得秋和春一样美。”\n\n和尚颔首赞同。\n\n“你抱的是什么东西？”老人问道，“看着像条死狗。对僧人来说，这不是秽物吗？”\n\n“这是只狐狸，”和尚说，“而且她还没死。”\n\n“你准备杀了她？”老人不耐烦地说。\n\n“我要带她求医，”和尚说道。\n\n老者面色凝沈，他举起手里的拐杖，打了和尚两下——一记在头侧，一记在肩膀之间。\n\n“这下！是因为你离弃庙宇，”老人打下第一杖时说道，“而这下！是因为你搀和狐灵鬼魂。”\n\n和尚低下头。“也许您责罚得对，”他说，“正如您所言，我没有看护寺庙，而且还抱着一只狐狸。\n\n可我相信带她求医，也是遵循正道。”\n\n“正道？正道？”老人又用拐杖戳着和尚的胸膛，“为什么，你这个蠢货，你这个没脑子的东西。你若是遵循正道，就该带着狐狸回你的庙里去，然后把夜梦之君的信物枕在头下，睡上一觉。你的小母狐正是被困在梦境中。”\n\n“我可否免受杖责，再多问一句，”和尚小心翼翼地说，“在哪能找到夜梦之君的信物呢？”\n\n老人瞪着年轻的和尚，又看了看手里的弯拐棍。\n\n接着，他长叹一声，这口气长得就像个耄耋之人想要吹凉面前的热汤。\n\n老人伸手从袖子里拿出一片写有字迹的纸条，按在和尚手中。\n\n“给你，”老人咕哝道，“但你到底还足个蠢货。不是狐狸死，就是你死；不管你是否心思纯良，尘世仙乡皆无一物能改变此事。”\n\n和尚本想争辩几句，问问老人为何要给他这没有好处的信物。\n\n但当他反应过来时，桥上已不见人影，整个山麓间就只有他一个人形影相吊。\n\n“这老人一定是宾头卢尊者，”和尚想，因为传说中宾头卢尊者经常化作长眉白须的老者；他始终在凡间修善积德，等待佛祖把他超度。\n\n但和尚还是想不通，为何宾头卢尊者要帮他这么个卑微小民；他记起尊者是因为妄自显圣，被罚不能西方往生，但这并不令人宽慰。\n\n下山时，狐狸几乎轻如鸿毛，但当和尚踏上归路，却发现她的身体越来越重。一笼薄雾降下山坡，将万物虚化。和尚向山上走去，只觉得举步维艰。\n\n他心中暗自思量，救助狐狸到底是不是正道。\n\n他想不清楚，但却知道自己不能弃她不顾。\n\n无论如何，也要试上一试。\n\n和尚是早上离开寺庙的，下午晚些时候他才走了回来。\n\n秋雾挂在山间，有如蛛网蚕丝，而那渐低渐近的暮霭更让世间如坠梦境。\n\n和尚走进小庙，就连这住了八年的地方，都让他觉得朦胧缥缈，仿佛一方幻土。\n\n炉火几乎已经冷透，和尚添了点炭薪，开始煮米饭，又烤了些切得很薄的葫芦片佐餐。\n\n饭后他开始做晚课，但却不如平日那般专注虔诚。\n\n祷告是一回事；向某些神佛祷告就是另一回事了，他们不仅会倾听，而且会在路上把你找出来，被你冒犯时还会用拐杖打你脑袋。\n\n在炉火辉光中，和尚产生了一种诡异的幻想。\n\n他觉得自己的影子似乎缺了一片，就像被撕掉了似的。\n\n狐狸睡得像个死物。\n\n她那么小。和尚抚过狐狸柔滑的皮毛，又看了看宾头卢尊者给他的符纸。\n\n和尚不懂上面写了什么，当他看去时，那些文字仿佛在扭动闪烁，就像梦中的符记。\n\n和尚把狐狸放在他的僧袍上，用自己的体温为她保暖，也许还能为她保住性命。他躺在睡榻上，将纸片放在枕下。来回一趟山路已经让和尚精疲力尽，他很快就坠入梦乡。\n\n起初，是黑暗。\n\n黑暗中闪出一点荧光。接着又一点，再一点。光亮开始游弋。\n\n它们是萤火虫。先是几只，继而聚起一群，最后成百上千的萤虫在黑暗中闪耀着它们的冷光。\n\n这让和尚想起星辰之河，或是一座星桥，或是一条在黑暗中缠绕萦转的锦带，灿灿生辉，亦幻亦真。\n\n和尚沿着锦带行走。\n\n那张信物就握在他手中，纸上溢出的光芒，比萤火更盛。\n\n他走了片刻，一些明昧不休的萤虫开始陨落，像山茶花一样翩然而坠。\n\n和尚同它们一起下坠。他发现自己并非自萤火虫间掉落，而是落过银河，那穿越夜空的众神之河。\n\n他轻轻落在一片孔雀石般盈绿的碎石荒原。\n\n和尚爬起身，行走在琉璃绿色的平原上。\n\n在梦中，他足踏高木屐。这种鞋人们在雨季才会穿，好让自己远离泥泞的地面。行走间，木屐渐渐磨损消逝，没过多久，和尚就只得赤足而行。\n\n片片碎石像无数锋利的小刀，鲜血从他脚上的伤口汩汩而出，在身后留下一串血红的足迹。\n\n他走过一片怪骨嶙峋的平原，那些非人的尸骨早巳破碎，锋利尖锐。\n\n他走过一片湿热逼人的沼泽。空中充满咬人的蚊虫，体型之小肉眼难辨。这些飞虫趴上他的皮肤和眼角，叮刺咬噬，留下点点伤痕。片刻之后，苍穹已被满天的蚊蠓染黑。\n\n纸条辉光更盛，和尚将它高举在身前，继续赶路。\n\n他最终穿过沼泽，从喉咙里啐出最后一口黑蠓，又将它们从眼角抹净。\n\n和尚走过一个向他私语的花园。它建议和尚回头，告诉他梦之君不是随随便便就能找到的，还说他应该留在花园里，漫步在它的小径上，闲坐在它的甜水旁。但和尚始终不知道，花园为何能对他说话。\n\n他恋恋不舍地离开花园，继续前行。\n\n和尚在两栋比邻的房舍前驻足。\n\n有两个人正坐在其中一间的缘侧，面对廊下的池塘持杆垂钓。\n\n“我要找夜梦之君，”和尚喊道，“这条路对吗？”\n\n“每条路都通向他的疆土，”第一个人问道，“你又怎能走错？”\n\n第二个人身材丰腴，面带愁容。他一句话也没说。\n\n和尚向他们展开信物。如果说之前还有些许疑虑的话，此刻他已确信自己是在梦中。因为他竟能读懂纸上的字。\n\n那是些很简单的文字，简单到和尚很奇怪先前怎么会读不懂。\n\n这些文字书写着一个人，他可以从混沌或虚无中塑造、制造、铸造，将无形无相之物化作幻梦，但离了这幻梦，任何真实都将失去意义。\n\n第二个人轻哼一声，引来和尚的注意。\n\n他仿佛是不经意间，指了指一座山峰。\n\n和尚施礼致谢，向那座山走去。\n\n他来到山脚下，回头看去，发现胖男人面朝下飘在鱼池中。\n\n而凶手正从房子的露台上俯瞰着他的尸身。\n\n和尚走到半山腰，又回头张望。\n\n房子，连同那人和鱼池，都巳消失。它们方才的所在只剩一片荒冢。\n\n在他前方，矗立着一座宏伟的建筑，与周围的景致浑然一体。\n\n它是神殿，是城堡，也是住所。它有水瀑和花圃，有彩绘屏风和华美的拱顶。和尚说不清这是一座房舍，还是一百座。他能看到诸多院落、果园和树木；在那些奇异的花圃中，比邻的树木上，春华、秋叶与夏实竟相生长。\n\n艳丽的鸣鸟在树上歌唱；它们的羽色或红或蓝，美艳鲜活宛若飞翔的花朵。那歌声也同样奇异莫名。\n\n和尚从没见过这样的所在。\n\n房前是一道拱门，由金色的木材造就，上面刻着奇禽异兽。\n\n和尚走到门前，敲响了挂在那里的一面小锣。\n\n锣鸣无声，但他确信，那些应当知道他在门前的人，已然知晓。\n\n大门打开，继而变化，一个绚丽多彩的生灵立在他面前。\n\n这是只怪鸟，头颅如狮，尖牙蛇尾，巨翼蔽天。\n\n竟是巨大无朋的时及乌，神话中的生灵。\n\n“鸣锣所为何事，”时及鸟说，“你又是何人，为甚打搅我主？”\n\n“这里真美，”和尚说，“等我醒来，世上再无这般景致，因为它们均非此地。如此想来，更让这宫殿平添几分美色。”\n\n“我是否真的站在梦之君的宫殿花园里？”他的话语轻柔至极，但却蕴含着对守门者的叱责。\n\n即便是神话中的生灵，也应晓得礼数。\n\n“此地正是梦之宫，”时及鸟咆哮道，“告诉我你想干什么，不然我就把你吃了。”\n\n和尚伸出手，将宾头卢尊者给他的纸片展示在时及鸟面前。\n\n它绽出光华万千。巨鸟低下头喃喃私语。\n\n“我没料到，”它说，“我以为你不过是个梦者。”\n\n和尚发觉有什么东西正从一棵黑松上俯视着他。\n\n那是只渡鸦，体型颇大，毛色黑且暗。\n\n它察觉到和尚的视线，扑愣愣飞扑而下，落在他面前的步道上。\n\n“跟我来，”渡鸦的声音好似两块岩石在磨擦。\n\n“你会带我去见梦之君吗？”和尚问。\n\n“你不会向一首诗发问，不会向一片飘零落叶，或是山颠雾色发问，”渡鸦说，“你又为何要向我发问？”\n\n房舍像一座迷宫，和尚跟着渡鸦穿过蜿蜒曲折的走廊和奇异肃穆的亭台；走过平静的池塘和峻秀的山石，穿行在屏风隔成的通道中。\n\n他始终跟着黑乌前行。\n\n“从你的回话判断，”和尚说，“我猜你是个诗人。”\n\n“我侍奉夜梦之君，”黑乌说，“听他的差遣。”\n\n它拍打翅膀，鼓翼而翔，落在一扇同和尚差不多高的屏风上。\n\n“但你说的也没错。我曾是个诗人，而且像所有诗人一样，我在梦之国逗留得太久。”\n\n渡鸦让和尚走进一间彩绘屏风隔成的屋子。\n\n房间的一端有座高台，台子上放了张镶有珠母的木椅。\n\n这是张完美的座椅，木工古朴，样式离奇。\n\n和尚知道这一定是梦之君的王座。\n\n“在这里等着，”渡鸦说完仰首阔步走出房间，就像个傲慢的老侍臣。\n\n和尚手足无措地站在觐见室，等待着梦之君的驾临。\n\n在和尚的想象中，梦之君是个老人，有着长长的胡须和指甲，接着他变得好似宾头卢尊者一般，最后又化作半人半龙的妖魔。\n\n和尚的目光被环绕房间的屏风所吸引。\n\n只要他注视着屏风，那些彩绘图案就静止不动；但他稍一分神，上面就会变化出前所未见的景象。\n\n他转开目光，屏风上的生物便会游移。\n\n传说落幕，新的传说，悄然登场。\n\n他独自站在觐见室中，看着彩绘屏风。\n\n不知从何时起，和尚不再是孤身一人，因为梦之君已坐在高台上的王座中。\n\n和尚深施一礼。\n\n梦之君的肌肤似以冬月，长发黑如鸦翼，双眸宛若倒映夜空的池水，远星在其中闪耀燃烧。\n\n他的袍色若夜，诸般火焰和面孔在底纹上浮现又消失。\n\n他开口说话，声音轻柔如丝，坚韧如丝。\n\n有朋自远方来，不亦乐乎，和尚听到一个声音从脑中响起，但你不该来。\n\n“我擅自登门”和尚说，“只求您救下一只狐狸的性命。她身在尘世，魂迷梦土。倘若您袖手旁观，狐狸迟早命丧此地。”\n\n也许她，夜梦之君言道，只求迷失梦乡。她所行之事，必有舍己的道理，而这道理你知之甚少。更不消说她是只狐狸。她的性命又与你何干？\n\n和尚踌躇片刻，开口说道：“佛祖教诲我等，对万生万灵，都要爱要敬。狐狸从没害过我。”\n\n梦之君上上下下打量着和尚。仅此而已？他不动声色地说。你离弃庙宇，来梦土寻我，只为此事？只因你对万生万灵，都有爱有敬？\n\n“万物于我皆有责，”和尚说，“既削发为僧，我便已舍弃诸般欲念，隔断尘世羁连。”\n\n梦之君沉默不语，像是在等待什么。\n\n和尚低下头说：“但她化作少女时，那肌肤的触感，我始终难以忘怀。这段记忆将伴我走到此生尽头，乃至尽头之后。何况，最难斩断是情丝。”\n\n我明白，梦之君说。他站起身，走下高台。\n\n如果把他当作人来看的话，梦之君的身量很高。\n\n随我来，他说。\n\n水瀑自宫殿的一面墙壁上倾泻而下。\n\n两人穿行过去，涓流在他们身上冲刷吹拂，却没打湿分毫。\n\n水瀑的另一侧有座避暑小筑。梦之君带着和尚向那里走去。\n\n你的孤狸也来找过我，祈求一件礼物，梦之君说，她对心中的爱恋比你坦诚得多。\n\n孤狸梦你之梦，与你一道做了前两个梦，又替你梦到最后的结局，用黑匙打开漆匣。\n\n“她在哪？”和尚说，“我如何带她回去？”\n\n你为何要带她回去？梦之君说。这非她所愿，对你也没有好处。\n\n和尚不发一语。\n\n君王指了指小筑里的桌子。那上面放着一个漆匣，和尚曾在梦中见过。\n\n钥匙就插在锁孔里。\n\n她就在这儿。如果你主意已定，就去找她吧。\n\n和尚俯下身，慢慢打开匣子。盒子张开，张大，张满天地。\n\n他走了进去，毫不迟疑。\n\n起初，和尚觉得漆匣里像个似曾相识，却又早已被忘却的地方一一也许是他幼年时的房间，或是庙里尚未被发现的密室。\n\n这个房间空无一物，只有角落里放着面镜子。\n\n镜面散发淡淡微光，宛若落日前最后一缕残阳。\n\n和尚捡起它。\n\n镜子背后有幅画，上面画着两个人：一个是傲慢暴躁的男人，目光如矩，须发灰白；另一个虽然沾满污垢霉腐，但很容易看出就是和尚自己。\n\n他把镜子翻过来，向镜面看去。\n\n和尚看到一个绿眸少女，光晕勾勒出她的玲珑倩影。\n\n少女觉察到和尚的目光，慢慢低下头。\n\n“你为何要来？”她语带忧伤，轻声说道，“我把自己的性命都给了你。”\n\n“你睡在寺庙的门坎上，”和尚对她说，“我唤不醒你。”\n\n她猛地仰起头。“我跟着貘，”她对和尚说，“一路跟着它们，看它们吞食梦境。你进入梦乡，我也跟了进去。你父亲给你那个漆匣时，我就在那儿，你醒来后，我将漆匣留下。你祖父给了你钥匙，你醒来后，我也把钥匙取走了。”\n\n“第三天，我从早到晚一直跟着你，夜幕降临时，我在你的门，躺下。梦在找到你之前，肯定要从大门路过。我沉沉睡去，看到梦滑出黑暗，就扑了上去，把它抢为已有。我在梦中用钥匙打开匣子。它张开后，大如苍穹，我无从选择，只能进去。”\n\n“我很害怕，因为我迷失在这个盒子里，找不到出去的路，也找不到回到身体的路。我被吓坏了，心情沮丧，但又非常骄傲，因为我知道我救了你的命。”\n\n“你为何要救我？”和尚问道。但他清楚自己早已知道答案。\n\n狐女的魂魄嫣然一笑。“你为何要来找我？”她问，“为何要来这儿？”\n\n“因为我在乎你，”他说。\n\n少女垂下目光。“那——你已经来了，已经知道了真相——你肯定也知道现在该离开了。我已救下你的命。与你为敌的阴阳师会代你而死，你可以回到庙里去，继续种你的南瓜和难吃的干山药。若是得闲，也请为我颂篇往生经。”\n\n“我是来救你的，”和尚说，“这是我的使命。”\n\n“你怎么救我？”女孩苦涩地说，“你能打破镜子的铁框吗？”\n\n“不，”和尚说，“我不能。”\n\n他拿出宾头卢尊者在桥上给他的信物，念出那上面写着的名讳。梦之君出现在他身旁。\n\n那么，君王说，你准备离开此地了吗？\n\n“陛下，”和尚说，“我是个僧人。除了食钵一无所有。但狐狸梦到的梦，本该属于我。我求您把它还给我。”\n\n但，君王说，如果我把梦还给你，你就要替她而死。\n\n“我知道，”和尚说，“但这是我的梦。我不会让狐狸做我的替死鬼。”\n\n梦之君点点头。他的脸色毫无变化。\n\n但和尚觉得自己的决断让王者伤悲，也让他欣喜。\n\n年轻的和尚知道他索求的是正道。\n\n君王一挥手，空茫的镜子躺倒在地板上。\n\n黑暗中，狐灵站在和尚身旁。\n\n你以身相殉，秉持正道，君王对和尚说，现在轮到我帮你一个小忙。你会有一点时间与孤狸告别。\n\n狐灵扑倒在君王脚下。\n\n“但你发誓要帮我！”她愤怒地说。\n\n我帮了你。\n\n“这不公平，”狐狸说。\n\n是的，君王颔首，这不公平。说完，他悄然而去，留下两人独处。\n\n传说中只记叙这些：他留两人独处，让他们告别。\n\n也许他们笨拙地说出别离之辞。他们之间的阻隔——弃世的和尚与狐灵之间的阻隔——如鸿沟天堑，不可逾越。\n\n这很可能。\n\n但有人记得他们为彼此所作的一切，现在回想起来，她可能觉得，在那段时间里两人曾共赴巫山，或者说梦到了那一番云雨。\n\n这也可能。\n\n他们道别已毕，梦之君又再度出现。\n\n诸事重回其轨，他说。和尚发现自己正从镜子里看着狐狸。\n\n“我会把命给你，”她悲声轻语道。\n\n“活下去，”和尚说。\n\n“我会为你复仇，”狐狸说，“对你下毒手的阴阳师，会学到拿走狐狸所爱意味着什么。”\n\n和尚从镜子里注视着狐狸。\n\n“莫寻仇，且寻佛，”他对少女说。接着和尚转身走向镜子深处，翩然远逝。\n\n小狐坐在岩石荒野中，身边是皮毛若夜、身形如宇的梦之狐。\n\n“我所做的一切，”她说，“我努力去做的每件事，都没有意义。”\n\n没有一件事会没有意义，梦之狐说。没有一事会是徒劳。你年岁增添，你做出了抉择，你已经不是昨天的狐狸。记住学到的东西，活下去。\n\n“他在哪？”小狐问道。\n\n他的身睡在寺庙的草席上。他的魂会去该去的地方。\n\n“他会死，”小狐说。\n\n会，梦之狐说。\n\n“他告诉我不要寻仇，而去寻佛，”狐灵悲声说道。\n\n诚乃良言，梦之狐说。复仇是条不归路。你应明智地避开它。那么……\n\n“我会寻佛，”狐狸猛地仰起头说，“但我要先寻仇。”\n\n如你所愿，梦之狐说。\n\n小狐不知道它是高兴还是忧伤，是满意还是恼怒。\n\n巨狐一甩尾巴，跳过梦疆，把小狐独自留在前所未有的孤独中。\n\n狐狸在山腰的小庙中醒来，和尚就在她身旁。他双目紧闭，气若游丝，皮肤泛起海沫的颜色。\n\n已经向他道别，却还看着他躺在这里，很痛。\n\n但小狐还是待在他身边，照料着他的身躯。\n\n第二天，和尚平静地死去。\n\n狐狸在小庙中为他操办了葬仪。和尚被埋在山腰，与往昔无数岁月中照料过这座小庙的僧人们为伴。\n\n满月升起又落下，残月高高爬上天际，阴阳师还活着。\n\n不仅如此，他能感到心中的恐惧正逐渐枯萎。\n\n他拿过漆匣、黑匙，和那些小磁盘，把它们裹在方巾里（现在方巾上只有他的脸，另一个人物已经连点污迹的残影都不剩了）。\n\n在黑夜死寂中，阴阳师把它们埋在一棵树下，这树很久以前曾遭雷齑，枝桠扭曲得让人心悸。\n\n他为自己还活着而宽心。他比过去任何时候都快乐。\n\n阴阳师的好日子到了。\n\n皎月在空中再度圆满时，一位出身高贵的少女来拜访他，向他求卜吉日良辰。那天雾气浓沉，挂满天地，条条卷须缠绕在阴阳师的府第中。\n\n女子用金币和最甘美的大米答谢他的智慧。\n\n这些钱币如此古老，已经看不出币面的图案。\n\n随后，她坐上一辆华美绝伦的牛车，离开了阴阳师的宅邸。\n\n阴阳师让仆人骑马跟上，去搞清少女家住何方，姓甚名谁。\n\n几个时辰后，仆人回来禀报说，少女住在京城北方几里外一栋古老而恢宏的宅院里。他将那个地方描述给阴阳师。\n\n日子一天天过去。阴阳师无法把少女的面容从心中抹去；还有她走路时的窈袅身姿，高贵又充满诱惑。\n\n他想象着如何得到她，抚摸她，占有她。\n\n每个夜晚，他一闭上眼，少女就会出现：她的头发，长且黑：她的眼睛，好像春日暖阳下舒展的绿叶；她的纤足，碎步翩翩；她的声音，如梦中仙乐；还有她持扇的柔荑。\n\n他去和宠姬行房，却发现自己毫无兴致，便回到书房，写下一首诗，将他对少女的思慕比作池水被秋风吹皱，又慢慢平息。阴阳师让仆人把它送给少女。\n\n仆人带来了她的回音，在这首诗中，少女提到水面上的月光被风吹乱的情景。阴阳师吟咏着诗句，心驰神往，少女飘逸秀美的书法也让他赞叹不已。\n\n他向废屋中的三个女人问起少女的事。老妇只是狂笑不止，什么也没说，笑声之烈，阴阳师觉得她会就此死去。\n\n双手如冰的年轻女人说，“她所爱的人已经死了。”\n\n“正好，”阴阳师说，“我何时拜访她最为合宜？”\n\n但三个女人只是叽叽咯咯地笑，好像在嘲讽他，阴阳师愤然离开了她们的破屋。\n\n第二天夜里，他来到少女的府第。\n\n阴阳师求少女恕他不告而来之罪，自陈是情非得以。\n\n说他通过卜算术得知自己必须离家赶往吉位，也就是北方。而且他必须在北方逗留一夜，早上再回城。\n\n少女邀他共进晚膳。\n\n这栋房子宏伟华丽。他和少女单独用饭，她的仆人们不断送上阴阳师从没尝过的珍馐佳肴。\n\n“我从没吃过这么美味的东西！”他咬了一口沾了冷酱汁的奇异肉食。\n\n“想想吧，”少女说，“如果我不在这里，您也许只能坐在摇摇欲坠的老旧空屋里，和鼠豸蛛虫一起用饭。”\n\n用罢晚膳，阴阳师坦言自己渴求与她床第相欢。\n\n少女倒上两盅米酒，告诉他这是无稽之谈。\n\n“我怎会甘为姬妄？”她问道，“您有妻子，还有个小妾。那我算什么？”\n\n“我是你的，是你一个人的，”阴阳师对她说。\n\n“您现在是这么说，”她说，“但云收雨住，您的妻妾又会变得娇媚诱人，我只能独守空房。我想您今夜不该留在此间。您的牛车会带您到另一处房舍过夜。如果您真的爱我，只爱我一个，那就日后再来。”\n\n“我今日便是为此而来！”阴阳师说。\n\n“但若您还有自己的家，”她说，“我就永远不会属于您。我要您来这里，和我一起住在我的府邸、我的宅院会属于您，永远属于您。但如果您另有住所，早晚会想念它，总有一天您会把我撇下。”\n\n她微微挪动身子。阴阳师觉得自己似乎瞥到一眼，少女袍服下白润柔滑的酥胸。\n\n“我会处理掉我的家，”阴阳师感到欲火在胸中灼烧。\n\n“还有件事，”少女碧绿的眸子燃进他的双眼，“就是您的阴阳术。我知道您能号令天狗、妖鬼。要是我让您不悦，您就可以用那些卷轴上的法术随手把我变成一只飞乌。我怎能做您的爱人，您的妻子呢？”\n\n少女又为他倒上一盅米酒。这令她的袍服稍稍滑开了几分，阴阳师看到了一握柔白的酥胸，乳头粉艳得好像日出。\n\n阴阳师扑过去想要抓住她，少女似乎根本没注意到阴阳师的失礼，只是灵巧地向后一退，避开他的双手，缓缓起身向他道辞。\n\n阴阳师意识到良宵已尽，不禁大声叹息，犹如世间所有门轴同时呻吟。就在此刻，疯狂攫住了他，至少人们是这么说的。\n\n第二天，京城起了两处火头。先烧起来的是阴阳师的府邸，全城排第十七的庭院。\n\n阴阳师早上把所有卷轴法器高高堆满一辆牛车，赶车离开了家，所以没人怀疑到他身上。这是一场惨烈的火事，烧起来时，他的妻子、小妾和所有仆人都还在安睡，这火夺走了他们的性命。\n\n第二处是城郊的一座破屋，它在附近向来名头险恶。\n\n这座房子里住了三个女人，据说是巫妇药师。没人知道起火时，她们在不在家。因为在废墟残灰中，人们只找到了婴儿和稚童的尸骨头颅。\n\n晚上，阴阳师来到让他心醉神驰的少女门前。\n\n“我的家已付之一炬，”他说，“我的女人都死了。除了你我再无人可爱，除了这里也无处可去。”\n\n少女冲他笑了笑，这一笑的嫣然，让他觉得好像金乌跃空，光芒都早在他一人身上。\n\n“还有这辆车，”他说，“我把所有法术都带来了。所有卷轴，所有法器。所有饰物、术杖和真名，我号令妖魔灵鬼、算后世今生的法力，都得自它们。所有这些，我都带来放在你的脚下。”\n\n少女点点头，几个仆人拉过牛车，搬下器物，取走他带来的所有器物。\n\n“好了，”阴阳师说，“如今我是你的了，再无一物可以阻隔我们。”\n\n“还有一件，”少女对他说，“您的袍子。脱下来，让我看看您。”\n\n阴阳师的血脉中搀满了疯狂和欲望。他脱下长袍，赤身裸体站在暮雾之中。少女捡起他的长袍，拿在手里。\n\n他张开双臂，抱向少女。\n\n少女靠上他的身子。“如今，”她低语道，“您无家、无妻，无妄，无术力，无衣袍。您舍弃了一切。现在轮到我送您点东西了。”\n\n她伸手捧住他的头，拉到唇边，仿佛要吻他，吻他的眼睛。\n\n“但我会留下你的命，”她说，“因为他不想让我杀你。”\n\n狐狸的牙是很尖的。\n\n第二天，人们发现阴阳师出现在一座二十年前就废弃了的院落中。\n\n它过去的主人早巳失势。有人说这是报应，因为十五年前，正是阴阳师当时侍奉的大名，令这个家族衰败凋零。\n\n他赤身裸体，窘迫羞惭，行事疯疯癫癫。\n\n有人说是因为失去了妻子和宅院，把他愁疯的。\n\n也有人说是因为失去了眼晴。而那些笃信鬼狐仙怪的人，则私下里传言，说这是中了狐术。\n\n之后的日子里，他过去的亲朋好友看到他沿街乞讨，都有意避开。他身上只有碎布遮体，其中一条缠在脑袋上，挡住脸上的伤痕。\n\n他活在贫苦、卑贱和疯狂中，一直到死。此生再无丝毫欢愉，只有在梦中才得片刻喘息。\n\n不过，他到底是怎么活的，又是怎么死的，传说中都没有提及。\n\n“但这到底有什么好处？”渡鸦说。\n\n好处？夜梦之君问道。\n\n“嗯，”渡鸦说，“和尚本会死，他确实死了。狐狸想要救他，没能救成。而阴阳师丧失了一切。你答应狐狸的请求，到底有什么好处？”君王看着远方的地平线。在他的眼中，一颗孤星一闪而没。\n\n领悟，白帝说。一切都是随他们的步调进行的。我的心思没有被浪费了。\n\n“领悟？”渡鸦高扬起黑色的头颅，竖起颈翎。“你是说谁？”\n\n所有人。尤其是和尚。\n\n渡鸦从喉咙里挤出一阵嘶哑的叫声，从一只爪子跳到另一只，像是在捕捉词句。\n\n黑瞳的王者耐心地看着它。\n\n“但他死了，”过了半晌，渡鸦说道。\n\n说到这个，你也一样啊，我的黑鸦。这次你也将有所领悟。\n\n“那你呢？”曾是个诗人的渡鸦问道。\n\n但白帝始终裹在寂静里，看着地平线，没有做答。\n\n过了一阵，渡鸦重重拍打了几下翅膀，飞上梦的天空，把君王独自留下。\n\n这就是狐狸与和尚的所有传说。\n\n几乎是所有。因为据说那些梦到遥远国度的人，有时会看到两个身影，在远方走过，像是一个僧人和一只狐狸。也可能是一个女人和一个男人。\n\n也有人说这不可能，因为即使是在梦境、在冥府，和尚与狐狸都属于不同的世界，就像他们在凡间一样。\n\n而且，他们将永远待在这不同的世界。\n\n但梦是很离奇的东西，除了夜梦之君谁也不敢说它们是真是假，谁也不知道它们又会讲述什么漫漫光阴中的故事。\n","tags":["摘抄","小说","奇幻"],"categories":["life"]},{"title":"JavaScript设计模式(1)——单例模式","url":"/archives/17/","content":"\n在 JavaScript 中单例模式的应用场景还是比较多的，实现起来也比较简单。大体思路无非就是，第一次调用构造函数时，实例化示例并保存起来。再次调用时直接将第一次实例化的对象返回即可。\n\n<!--more-->\n## 实现\n\n### 一个极简的实现方式\n\n```js\nvar __instance;\nfunction Single() {\n    if (__instance) {\n        return __instance;\n    }\n    this.name = 'single';\n    this.time = Date.now();\n    __instance = this;\n    return this;\n}\n// 验证\nvar obj1 = new Single();\nvar obj2 = new Single();\nobj1 === obj2 // true\n```\n\n  上面使用 `__instance` 存储第一次调用构造函数时实例化的对象，以后每次调用构造函数都直接返回该对象。实现了单例。\n\n  但上例有一个明显的缺点，就是容易造成全局变量的污染，使得 `__instance` 这个变量并不安全，很容易被外部修改。\n\n  **当然**，如果使用了模块化开发则不用担心该问题，完全可以使用上面的实现方法，简单有效。\n\n#### 一个改进的实现方法\n\n  针对全局变量污染的问题，我们有很多办法解决这个问题。比如使用不同的命名空间或决定好命名规则，来避免变量被意外修改。除此之外，我们还可以使用**闭包**来解决这问题：\n\n```js\nfunction Single() {\n    this.name = 'single';\n    this.time = Date.now();\n    var instance = this;\n    Single = function() {\n        return instance;\n    }\n}\n```\n\n  上面的写法，通过第一次调用构造函数时改写构造函数来来实现单例。利用了函数闭包的特性，将示例保护起来，不会被外部访问和改写。\n\n  在更严格的情况下，我们仍可以对上述例子进行近一步的优化。\n\n```js\nfunction Single() {\n    this.name = 'single';\n    this.time = Date.now();\n    \n    var instance;\n    Single = function() {\n        return instance;\n    }\n    \n    Single.prototype = this.__proto__;\n    Single.prototype.consctructor = Single;\n    \n    instance = this;\n    \n    return this;\n}\n```\n\n  上面的优化在于，保证能够在实例化后再次为添加类方法时能够得到继承，同时能够保证每次返回的实例化对象的构造函数指向同一个函数。一般情况下可以不用做次考虑。\n\n## 总结\n\n  在大多数情况下实现单例模式时很简单的。尤其是使用了模块化时，只需使用一个变量将第一次实例化的对象保存起来，再次调用直接返回即可。\n","tags":["ECMAScript","设计模式","单例模式"],"categories":["developer"]},{"title":"requestAnimationFrame——HTML5动画利器","url":"/archives/15/","content":"\n`requestAnimationFrame` 是 `window` 对象中的一个新方法，是专门为了网页动画而生的。\n\n<!--more-->\n\n## 优点\n\n  在该方法没有实现之前，在操作 DOM 动画时，几乎只能通过 `setInterval` 定时器来实现。而 `setInterval` 方法实现动画的缺点是显而易见的：\n\n1. 时间计算不精准。由于 `setInterval` 处于 `JavaScript` 的异步执行阶段，基于 `JavaScript`单线程的特点，为其设定执行时间无法保证准确。\n2. 性能浪费。使用 `setInterval` 方法，我们需要考虑为其设定合适的间隔值，以保证动画流畅。而过低的间隔将造成事件频繁的触发降低代码性能。\n3. 不合预期的表现。使用 `setInterval` 设置动画时，当用户切换至其他页面或最小化时，`setInterval` 会暂时进入“休眠”状态,但是并不是不执行程序,它会把需要执行的操作放在队列中 ，等到下次窗口一打开的一瞬间把队列里面的全部执行。这样就造成了动画效果混乱，不合预期。\n\n  而 `requestAnimationFrame` 则很好的避免了以上几点：\n\n1. 动画的调用时间是浏览器通过系统时间设定，是浏览器级别的操作，保证了时间的精确。\n2. 该方法只接受一个回掉函数作为参数，由浏览器设置合适的时间间隔（浏览器厂商根据屏幕刷新率来设定，通常为`1/60`秒）。同时浏览器会把该时刻所有的 DOM 操作集中起来完成（优化），在一次重绘或回流中完成。在复杂动画情况下，性能极大提升。并且该方法会忽略不可见元素的动画操作。\n3. 如果页面不处于激活状态，会自动暂停动画的执行。\n\n## 语法\n\n  `requestAnimationFrame` 方法的语法非常简单，只需要传入一个回调函数即可：\n\n```js\nwindow.requestAnimationFrame(callback);\nfunction callback() {\n    /* some animation code */\n}\n```\n\n  该方法返回一个 long 非零整数，请求 ID ，也是回调列表中唯一的标识。\n\n  需要注意的是，该方法的使用和 `setTimeout` 的时候略有不同。[MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame) 中对该方法的解释如下：\n>window.requestAnimationFrame() 方法告诉浏览器您希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画。该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。\n\n  也就是说，传入的回调函数只会在下一次重绘中被调用，仅此一次，而不是像 `setTimeout` 一次设置，循环调用。所以 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame) 中给出了这样的提示：\n>注意：若您想要在下次重绘时产生另一个动画画面，您的回调例程必须调用 requestAnimationFrame()。\n\n  另外需要注意，该方法会为 `callback` 方法传入一个默认参数，该参数是一个时间戳，用以计算该动画从开始到该次回调之间的毫秒数。如果不注意，当需要对回调函数绑定参数并且参数缺省时可能会产生误解。\n\n## 例子\n\n<iframe height='600' scrolling='no' title='自由落体小球' src='//codepen.io/Hozen/embed/jZrpWE/?height=265&theme-id=0&default-tab=result&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>\n</iframe>\n\n```js\nconst ball = document.getElementById('ball');\n\nlet x = 5;  // 初始高度\nlet t = 1;  // 时间间隔\nlet a = 0.5  // 加速度\nlet v = 0;  // 初速度\nlet maxX = 400;  // 最大位移（反弹位置）\n\nfunction drop() {\n  ball.style.top = Math.floor(x) + 'px';\n  if (x > maxX){\n    v = -v;\n  } else {\n    v += a *t;\n  }\nx += v* t;\n  window.requestAnimationFrame(drop);\n}\nwindow.requestAnimationFrame(drop);\n//drop();\n\n```\n\n  上面的例子模拟了一个小球的无能量损耗的自由落体及反弹运动（HTML 和 CSS 代码未给出）。其中动画函数是 `drop`，在该函数中计算小球的位移并复制给小球 DOM 的 `top` 属性。\n\n  我们希望动画循环执行，至调用一次 `window.requestAnimationFrame(drop)` 是不行的，因为这只会**在下一次重绘时**更新。所以我们在 `drop` 函数末尾再次调用 `window.requestAnimation(drop)` 保证每次都有下一次，即实现了动画循环。\n\n  如果希望动画在特定条件下停止，在函数中调用 `window.requestAnimationFrame` 前 `return` 即可。\n","tags":["ClientScript","HTML5","requestAnimationFrame"]},{"title":"为DOM2级事件函数传参——bind的应用","url":"/archives/14/","content":"\n在复杂的 web 开发中，我们应采用 DOM 2 级事件来绑定和移除函数。即使用 `addEventListener` 和 `removeEventListener` 方法为 DOM 节点绑定和解绑函数。因为 DOM 1 级事件不支持多个函数的绑定。这意味着，当你使用 DOM 1 级为 DOM 绑定新函数时，旧的函数会被取代。这在很多情况下是不被希望看到的。\n<!--more-->\n\n例如，我们经常会在 `document` 对象上绑定多个鼠标事件，使用 DOM 2 级事件既不会取消之前的函数，也不用担心对项目组其他成员编写的事件绑定造成影响。\n\n## 一个问题\n\n一个常见的 DOM 2 级事件绑定和解绑如下：\n\n```js\nconst fn = () => {\n    console.log('in function');\n}\n\n// 绑定\nelement.addEventListener('cilck', fn);\n\n// 解绑\nelement.removeEventListener('click', fn);\n```\n\n如上，由于一个 DOM 2 级事件可以被绑定多个函数，所以当我们解绑函数时，需指明要解绑的函数名。这意味着，如果在 DOM 2 级事件上绑定了一个匿名函数，那么是难以解绑改函数的。所以应尽量避免绑定匿名函数。\n\n但通常，绑定的函数并不是完全孤立的，我们需要传入一些参数。新手常会犯的一个错误就是企图通过以下语句传参：\n\n```js\nelement.addEventListener('click', fn(params));\n```\n\n然而，上面的写法会直接执行 `fn` 函数，而不是等待点击事件的触发时才执行。给 `click` 绑定的也是 `fn(params)` 的返回值，而非 `fn` 函数。\n\n## 实例\n\n下面是一个例子。该实例实现点击小球时可以拖拽小球，当松开鼠标时停止拖拽。考虑到要在 `document` 上绑定事件，我们使用 DOM 2 级事件。\n<iframe height='265' scrolling='no' title='bind' src='//codepen.io/Hozen/embed/yKRxRO/?height=265&theme-id=0&default-tab=result&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>See the Pen <a href='https://codepen.io/Hozen/pen/yKRxRO/'>bind</a> by Hozen (<a href='https://codepen.io/Hozen'>@Hozen</a>) on <a href='https://codepen.io'>CodePen</a>.\n</iframe>\n\n通常，实现拖拽效果时，大体思路是：\n\n* 点击目标对象时，为 `document` 绑定 `mousemove` 事件，当鼠标移动时，根据鼠标位置设置目标对象的位置。\n\n* 当鼠标弹起时，解绑 `document` 的 `mousemove` 事件。\n\n  这样需要监听目标对象的 `mousedown` 事件， `document` 的 `mousemove` 和 `mouseup` 事件。\n\n  当鼠标在目标对象上按下时，我们需要计算出此时目标对象的位置，然后将位置信息作为参数，传入 `mousemove` 事件函数中。这就涉及了 DOM 2 级事件的传参问题。\n\n  该例中的实现代码如下：\n\n```js\n// 主函数\nconst main = () => {\n  const ball = document.getElementById('ball');\n  \n  let isDraging = false; // 记录是否在拖动中\n  \n  let dragWithParams; // 绑定参数的拖动方法\n  \n  const drag = (params, e) => {\n    let x = e.clientX - params.offsetLeft;\n    let y = e.clientY - params.offsetTop;\n    \n    // 避免小球移出视口\n    if (x < 0) {\n      x = 0;\n    } else if (x > document.documentElement.clientWidth - ball.offsetWidth) {\n      x = document.documentElement.clientWidth - ball.offsetWidth\n    }\n    if (y < 0) {\n      y = 0;\n    } else if (y > document.documentElement.clientHeight - ball.offsetHeight) {\n      y = document.documentElement.clientHeight - ball.offsetHeight;\n    }\n    \n    ball.style.left = x + 'px';\n    ball.style.top = y + 'px';\n  }\n  \n  // 当鼠标弹起时判断是否移除 mousemove 事件\n  document.addEventListener('mouseup', () => {\n    if (isDraging) {\n      console.log('up');\n      document.removeEventListener('mousemove', dragWithParams);\n      isDraging = false;\n    }\n  })\n  \n  // 点击球时为 document 绑定 mousemove 事件\n  ball.addEventListener('mousedown', e => {\n    const offsetLeft = e.clientX - ball.offsetLeft;\n    const offsetTop = e.clientY - ball.offsetTop;\n    \n    isDraging = true;\n    \n    // 绑定参数\n    dragWithParams = drag.bind(null, {\n      offsetLeft,\n      offsetTop,\n    })\n    \n    document.addEventListener('mousemove', dragWithParams);\n   });\n  \n}\n\ndocument.addEventListener('DOMContentLoaded', main);\n```\n\n### 代码分析\n\n上例中利用了 `bind` 方法可以绑定参数的特点来为事件函数绑定参数。[点击查看 `bind` 详情](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind)。\n\n同样需要注意的是，代码中为绑定参数后的 `drag` 函数赋予了新的引用 `dragWithParams`。这是因为 `bind` 方法返回的是原函数的拷贝而非原函数。所以，如果我们不赋予它引用名，该函数就变成了匿名函数，我们依然无法解绑。例如，下面的例子中，是无法解绑的。\n\n```js\nconst fn = (params) => {\n    console.log(params);\n}\n\nconst params = 'some params';\n\n// 此处相当于绑定了一个匿名函数\ndocument.addEventListener('mousemove', fn.bind(null, params));\n\n// 无法解绑事件，因为该事件绑定的不是 fn 函数，而是它的一个拷贝。\ndocument.remvoeEventListener('mousemove', fn);\n\n```\n\n`bind` 方法第一个参数指定函数中 `this` 的指向，其余的参数会被作为绑定的参数传入新的函数，并且会出现在传入参数的前面位置。所以在示例代码 `drag` 函数中，将 event 对象参数放在了 `params` 后面接收。\n","tags":["ClientScript","DOM事件"],"categories":["developer"]},{"title":"我与明二","url":"/archives/13/","content":"\n\n一\n\n  我与明二初见是一年多之前的事情了，那时候我刚刚上大学，还未成年。这很关键，未成年使得我和明二早早相遇。\n<!--more-->\n\n  那是军训后的一个小假期，我和室友百无聊赖，商量着去上网，但我们中几人还未成年，怕去网吧被赶出来。其实我早该料到，到哪里的网吧都一样会有“临时卡”。但初到一个陌生的地方，总是分外谨慎和局促。\n\n  于是我们决定去学校机房。从明远一区教学楼门前走过，穿过宁静优雅的明远湖。那是我第一次见到明二。她背对着宽广的修远湖，第一眼感觉明二普普通通，但却有一种独特的宁静气质。没多打量，我便急匆匆地进了机房。明二自然也不会在三五人群中注意到我。后来见明二的次数渐渐多了，但她总是一言不发，我也无意攀谈。\n\n  后来我加入了学生组织，每周有两次值班，我得以在宁静无人的清晨与明二相遇在明远湖畔，我想这是她第一次注意到我。我在办公室安安静静地值一个上午的班。等教学楼里人渐渐多起来，我背起书包离去，不知道此时明二会不会在熙攘的人群中注意到我。\n\n  后来独自去自习的次数多了，总是能在幽静的清晨或夜晚与明二相遇或分别。尤其是周末，一整天明远湖旁别无他人，我和明二就静静地独处一天，相顾无言却也相看不厌。明二高冷，除了晚上会时不时弄出奇怪的动静惊吓我外，始终一言不发。明二并不高，普普通通的个头，不过确是冷了些。\n\n  但明二还是比我高多了，我值班的时候总要丈量一遍他的高度。明二是一栋教学楼，我喜欢在它楼顶无人的办公室值班或自习。\n\n  明二的脖颈处有几棵铁树，长势甚好，比明远一区、三区的要茂盛高大得多。由于明二是机房重地，所以不同于其他教学楼的一楼半侧开放，明二是全封闭的。四合院一样，抬头只能看到一小块方方的天。阳光很难照进来，风也难得吹进来，有些阴冷。\n\n  因为明二的全封闭，我几次晚上被关在里面。去叫楼管大爷为我开门是一件极其困难和无奈的事情，那大爷脾气暴躁，每次总要隔着他房间的门歇斯底里责骂半天，我在外面卑躬屈膝，洗耳恭听，连声唱喏。等他骂得差不多了，便开口请他老人家网开一面，降恩与我。大爷绝不亲自出来，而是着大妈拿钥匙出门，奉旨放行。像西天取经倒换通关文牒，每次都颇费周折。\n\n  大学通过几次宵，有几次是在黉门客。我很喜欢这个名字，“黉门客”，第一次听到这个名字时我就赞叹不已，如此文质彬彬的名字绝对不可能是网吧之类的低俗场所。另有两次通宵就是在明二了。\n\n  第一次是通宵做汇编语言的课程设计，一夜没睡，毫无困意。五楼是有风的，风从天台涌进来，吹进全封闭的教学楼，四处乱撞，走投无路，终于从犄角旮旯的大小缝隙钻出去，发出困兽出笼般的低啸声。\n\n  风声敲着我的门。我把数据一遍遍入栈出栈，循环调用，用最基本的语言和逻辑演绎编程之美。终于在天亮之前完成了任务，像是完成了“命运交响曲”一般骄傲，不由发出如释重负的赞叹声。我看了下天气预报，拿出手机定位，查了下经纬度，粗略计算了下日出时间，定了个闹钟，小憩片刻。\n\n  还未深眠，手机就跳动着将我扯醒。天还是黑的，走出办公室，一阵寒意。明二夏末的清晨真冷。我走到天台伸了几个懒腰，听到久违的鸟儿叽喳的声音，让我终于把昨天和今天分隔开来。\n\n  东方泛白，我第一次看到了太阳从城市边缘林立的高楼中升起，莫名感动涌上心头。我拍下照片传到社交网络，点赞数可观，朋友们羡慕不已。\n\n  于是没过多久又来通宵了一次，这一次有几个朋友还有朋友的女朋友，好不热闹。我很早就睡着了，本来就是强行被他们叫来体验所谓的“长大夜生活”，可我觉着睡觉才是对夜生活最好的体验。中间被他们扯醒：“几点日出？”我头也不抬：“什么啊？明天阴天，没有日出……”一阵“卧槽”此起彼伏……\n\n  等我醒来，天已大亮，只还剩下一个嗜睡的同学还在做着日出美梦。其他人都走光了，只留下他们吃剩下的零食包装袋，我抖了抖连渣都没剩，饮料倒是剩了好几个半瓶，我咽了咽口水把它们抛进垃圾桶。拍了拍手：“鄂俊言，来来来，起床看日出了。”\n\n二\n\n  下雪的明二更安静，我本以为明二的铁树会风雪无侵，可雪却偏偏能安安静静的落在铁树上，从五层向下看去，落出一片片巨大的雪花。我在窗前写东西，雪从窗外慢慢落下，用余光就能感觉到雪花的飘落，让我有点不能静下心来，但也不觉得孤单了。\n\n  早晨在床上听到室友说下雪了，我就再睡不着，起床飞速的洗漱吃饭，准备着与明二的雪中邂逅。\n\n  一路上好多同学拿出手机记录下今年西安的第一场雪，我不为所动。因为我知道明二在等我，明二是属于我的。果真，下雪的明二更是无人光顾，楼内一片肃然，我一度听到了雪落的声音。\n\n  每个冬天我都能想起高中学过的一篇课文——刘亮程的《寒风吹彻》，把它反复的读几遍，赞叹不已。高中的时候，我读不懂的文章都会被我无知地认为故作高深。《寒风吹彻》是个例外，预习这篇课文的时候，我就已经完完全全被作者的语言和逻辑所吸引。我反复的读，却终究还是不能体会这些质朴平静而又意味深长的文字后面隐藏着作者怎样的心境。老师说这篇文章讲了作者经历的苦难，高考不考，其他的再不多说。\n\n>经历过许多个冬天后，我才渐渐明白自己再躲不过雪，无论我残缩在屋子里，还是远在冬天的另一个地方，纷纷扬扬的雪，都会落在我正经历的一段岁月里。当一个人的岁月像荒野一样敞开时，他便再也无法照管好自己……\n\n  再读这篇文章，我终于开始有了不一样的体会。《一个人的村庄》并非只有苦难，更多的是孤独。\n\n  我似乎理解了作者为什么一直在絮絮叨地说那根冻坏的骨头——心知再也暖不热却一直努力想暖热的骨头。我摸摸我的骨头，我大概一直是作者笔下那个“以往的我”吧：\n\n>每逢第一场雪，都会怀着莫名的兴奋。站在屋檐下观看好一阵，或光着头钻进大雪中，好像有意要让雪知道世上有我这样一个人，却不知道寒冷早已盯住了自己活蹦乱跳的年轻生命。\n\n  我突然摸到了那根骨头，开始发现，当冬天来临，无论做了怎样的准备，都不可避免的要被冻伤。\n\n>从那个夜晚我懂得了隐藏温暖——在凛冽的寒风中，身体中那点温暖正一步步退守到一个隐秘的有时连我自己都难以找的深远处……”\n\n  也许我还年轻，还能再经受一些风雪，还能从冰雪里笑着爬起，靠自己打颤攫取身体深处的温暖。我的人生还长，也许我不该早早把我的温暖挥霍一空。\n\n  落在一个人一生中的雪，我们不能全部看见。\n\n  2016年1月于长安大明二五楼 雪\n","tags":["散文","校园"],"categories":["life"]},{"title":"排序算法（二）——交换排序（冒泡排序+快速排序）","url":"/archives/12/","content":"\n\n## 冒泡排序\n\n### 算法分析\n\n  冒泡排序可能是排序算法中最简单最好理解的算法了。\n<!--more-->\n\n  以正序排序为例，该算法从序列头部开始，每次将当前元素与下一个元素进行比较，若下一个元素小于该元素，则交换位置。依次递增迭代指针，直至序列尾部。这“一趟”操作过后，序列中最大的值就冒到了序列尾部。\n\n  以下列序列为例：\n\n```txt\n50 13 55 97 27 38 49 65\n```\n\n  从下标为 0 的元素 `50` 开始，与 `13` 进行比较，`13 < 50 == true`，则交换位置。序列变为：\n\n```txt\n13 50 55 97 27 38 49 65\n```\n\n  下标加 1，继续上述操作：`55 < 13 == false`，则不执行交换操作。下标加 1，重复上述操作，直至序列尾部，则完成“一趟”冒泡。序列变为：\n\n```txt\n13 50 55 27 38 49 65 97\n```\n\n  继续从头进行冒泡操作，每次都将剩余元素中最大的元素冒泡到尾部。直至一趟下来未发生位置交换，则说明序列已有序。\n\n### 代码示例\n\n```javascript\nconst bubbleSort = array => {\n    // 使用 exchange 记录发生交换的位置\n    let exchange = array.length - 1;\n\n    // 若上一趟未发生交换，则说明序列已有序，算法结束\n    while (exchange !== 0) {\n        // 暂存上次交换位置，交换位置之后的序列已经有序，则跳过比较。\n        let end = exchange;\n        exchange = 0;\n\n        for (let j = 0; j < end; j++) {\n            if (array[j] > array[j + 1]) {\n                [array[j], array[j + 1]] = [array[j + 1], array[j]];  // 交换位置\n                exchange = j; // 记录交换位置\n            }\n        }\n    }\n}\n```\n\n  上述代码对冒泡算法的基本算法进行了一些优化。使用一个变量记录上一趟冒泡的最后交换位置，该位置之后的元素未发生交换，即说明该位置之后的序列已经有序。则在此趟冒泡中不需要对后面有序的子序列进行操作了。当上一躺未发生交换时，则说明序列已经有序，结束循环。\n\n## 快速排序\n\n### 算法分析\n\n  快速排序（快排）着眼于解决冒泡排序位置交换次数太多的问题。希望通过一次进行长距离的交换从而减少交换次数。\n\n  快排又称为分区交换排序，其基本思想是：首先选一个轴值（pivot，即比较的基准值），每次都将序列划分为两部分，左侧记录的关键码均小于基准值，右侧记录的关键码均大于基准值。然后对左右两部分分别重复上述划分操作，直至序列整体有序。\n\n  显然快排是一个递归的过程。\n\n### 一次划分算法\n\n  由于快排是一个递归过程，我们先分析对序列进行一次划分的一种算法思路。\n\n  该示例算法，选取序列第一个元素为基准值。从序列两侧交替与该基准值比较，进行相应的位置移动。直至所有的值都移动到了合适的位置（小于基准值的移动到基准值左侧，反之右侧）。\n\n  以下面序列为例，具体解释一下算法过程。\n\n  **23** 13 49 6 31 19 28\n\n  首先选取第一个元素 `23` 作为基准值。先从右侧进行比较，令右侧指针为 `j = 6`，`28 > 23 == true` 且该值处于基准值右侧，则无序移动。`j--`，继续比较下一个值。`19 > 23 == false`，则将该值与基准值交换，使得该值位于基准值的左侧，且同时保证了基准值的右侧都是大于基准值的元素。此时，序列变为：\n\n  19 13 49 6 31 **23** 28\n\n  基准值被移动到右侧，进行进行左侧元素的比较。令左侧指针为 `i = 0`，`19 < 23 == true`，且位于基准值左侧，无需操作。`i++`，`13 < 23 == true`，无需操作。继续比较下一个值，`49 < 23 == false`，则将 `49` 与基准值交换，使得该值位于基准值的右侧，且保证了基准值左侧都是小于基准值的元素。此实，序列变为：\n\n  19 13 **23** 6 31 49 28\n\n  交替进行右侧扫描，上次 `j = 5`，则对 `j = 4` 的元素进行比较，`31 > 23 == true`，无需操作。`j--`，`6 > 23 == false`，则交换位置，序列变为：\n\n  19 13 6 **23** 31 49 28\n\n  此时，基准值左侧的值均小于基准值，右侧的值均大于基准值，完成一次划分。\n\n#### 一次划分示例代码\n\n```js\nconst partition = (arr, first, end) => {\n    let i = first\n    let j = end\n    while (i < j) {\n        while (i < j && arr[i] <= arr[j]) j--\n        if (i < j) {\n            [arr[i], arr[j]] = [arr[j], arr[i]]\n            i++\n        }\n        while (i < j && arr[i] <= arr[j]) i++\n        if (i < j) {\n            [arr[i], arr[j]] = [arr[j], arr[i]]\n            j--\n        }\n    }\n    return i;\n}\n```\n\n  该示例代码，左右依次与基准值进行比较并交换位置，以保证每次交换后都能使得操作过的值处于合适的位置。同时当左右指针指向同一个值时，说明循环结束。\n\n### 快速排序算法\n\n  快排算法是一个递归的过程。首先将序列进行一次划分，然后分别对左右子序列进行递归的划分。直到子序列被划分为最小的长度，则所有的子序列都有序，则整个序列有序。\n\n```js\nconst quickSort = (arr, first, end) => {\n    first = first === undefined ? 0 : first\n    end = end === undefined ? arr.length - 1 : end\n\n    if (first < end) {\n        let pivot = partition(arr, first, end)\n        quickSort(arr, first, pivot - 1)\n        quickSort(arr, pivot + 1, end)\n    }\n}\n```\n\n## 总结\n\n  冒泡排序的时间复杂度为 O(n)，是稳定的排序方法。\n\n  快速排序的时间复杂度为 O(nlog2n)，是不稳定的排序方法。\n\n  正如其名，快排是迄今为止所有内排序算法中最好的一种，尤其适用于待排序记录个数很大且原始记录随机排列的情况。快排算法得到广泛应用，如 UNIX 系统的库函数中的 `qsort` 函数。\n","tags":["Algorithm","冒泡排序","排序算法","快速排序"],"categories":["developer"]},{"title":"排序算法（一）——插入排序（直接插入+希尔排序）","url":"/archives/11/","content":"\n\n## 思路\n\n  插入排序的基本思路是，每次将一个待排序的记录按照其关键码的大小插入到已经排好序的有序序列中，直到记录全部有序。\n<!--more-->\n## 直接排序\n\n  直接排序是思路最简单直接的插入排序，类似我们玩扑克牌时整理纸牌的过程。\n\n  比如我们按大小顺序排列以下纸牌（数字）\n\n```txt\nK 10 J 2 4 A 4 3 5 Q 2\n```\n\n  首先，我们以第一张牌为一个有序序列，然后将第二张牌插入到该有序序列的合适位置：\n\n```txt\n10 K J 2 4 A 4 3 5 Q 2\n```\n\n  这样就完成了第一次插入。此时，有序序列变为 `10 K`。我们继续将下一张牌插入到该有序序列中。这对于纸牌玩家来说，顺理成章，直接将 `J` 插到 `10` 和 `K` 之间。但对于计算机来说，可能需要进行以下过程：\n\n* 首先将 `J` 和 `K` 比较，`K` > `J`，所以将 `K` 的位置往后移动一位（数组索引加 1）。\n* 继续往前比较，发现 `10` < `J`，所以将 `J` 放在 `10` 后面（将 `10` 元素索引 + 1 的位置赋值为 `J`）。\n* 完成该次插入，有序序列变为 `10 J K`。\n\n  依照上述思路，不停的将接下来的元素插入到前面的有序序列中去，直至数组的结尾。\n\n### 算法分析\n\n  从上面的例子我们大概可得直接插入的大体算法为：\n\n* 以第一个元素为有序序列\n* 将有序序列的后一个元素插入到有序序列中去，构成新的有序序列。\n* 继续插入下一个元素，直至数组结尾。\n\n  从上面的思路，我们需要注意的是“插入”的操作。\n\n  首先我们需要找到插入的合适位置，因为该算法从有序序列的后面往前查找。所以每当遇到元素大于带插入元素时，就把该元素向后移动一位，以便为插入元素“空”出位置。直到遇到小于带插入元素的元素时，合适的位置被找到，将元素插入即完成此次插入操作。\n\n### 代码示例\n\n```js\nconst insertionSort = arr => {\n    for (let i = 1; i < arr.length; i++) {\n        let tmp = arr[i]  // 暂存该元素，因为在移动操作时会覆盖掉该位置的值\n        let j = i - 1 // 从有序序列的后面向前查找插入位置\n        \n        // 把有序序列中所有大于待插入的元素向后移动一位。\n        for (; a[j] > tmp; j--) {\n            arr[j + 1] = arr[j]\n        }\n        \n        // 循环结束，插入位置被找到，插入该值，完成该次插入\n        arr[j + 1] = tmp\n    }\n}\n```\n\n## 希尔排序\n\n  直接插入排序算法面临一个问题，当待排序数组基本无序，且长度比较长时，要进行大量的位置移动操作。性能较低。\n\n  希尔排序试图解决上述问题。\n\n  希尔排序首先将数组分割为若干个序列，首先将每个序列进行直接插入排序。然后重新分割序列，减少序列的个数，再次对每个序列分别进行直接插入排序。然后再次减少序列的个数，分别进行直接插入排序，直至序列被减少为一个，对整个数组进行一个直接插入排序即可。\n\n  通过以上算法，开始每个序列的长度很小，位置移动对性能的影响。随着序列个数的减少，序列长度的增加的同时，序列开始慢慢变得有序，使得插入插入操作减少。提高了性能。\n\n### 算法分析\n\n  关于如何划分序列，尚未有人求得一个最好的方案。希尔最早提出的方案是，开始每隔 `length / 2` 构成一个子序列。然后每次将间隔缩小一倍，构成新的子序列，对这些子序列进行直接插入排序。直至最后间隔变为 `1` 则子序列变为整个序列。\n\n  任然一上面的序列为例：\n\n```txt\nK 10 J 2 4 A 4 3 5 Q 2\n```\n\n* 第一次每隔 `5` 构成一个子序列，则有 5 个子序列，分别为：\n\n```txt\nA  2  K\n10 4\nJ  3\n2  5\n4  Q\n```\n\n  对上面子序列进行插入排序，则序列变为：\n\n```txt\nA  2  K\n4  10\n3  J\n2  5\n4  Q\n```\n\n  则第一次对子序列进行插入排序后，原序列变为：\n\n```txt\nA 4 3 2 4 2 10 J 5 Q K\n```\n\n* 然后将间隔缩小为 `5 / 2 = 2` ，则子序列变为：\n\n```txt\nA 3 4 10 5 K\n4 2 2 J Q\n```\n\n  分别对子序列直接插入排序后，原序列变为：\n\n```txt\nA 2 3 2 4 4 5 J 10 Q K\n```\n\n* 最后一次间隔缩小为 `1`，则子序列就变为序列本身，此时序列基本有序，直接进行直接插入排序完成排序。\n\n### 代码示例\n\n```js\nconst shellSort = arr => {\n    // 初始间隔为 length / 2，每次缩小一倍，直到间隔变为 1\n    for (let d = Math.floor(arr.length / 2); d >= 1; d = Math.floor(d / 2)) {\n    \n        // 对子序列进行直接插入排序\n        for (let i = d; i < arr.length; i++) {\n            let tmp = arr[i]\n            let j = i - d\n            for (; j >=0 && arr[j] > tmp; j -= d) {\n                arr[j + d] = arr[j]\n            }\n            arr[j + d] = tmp\n        }\n        \n    }\n}\n```\n\n## 总结\n\n  直接插入排序时间复杂为 O(n^2)，是稳定的排序算法。\n\n  希尔排序的时间复杂度在 O(n^2) 和 O(nlog2n)，约为 O(n^1.3)，是不稳定的排序算法。\n","tags":["Algorithm","排序算法","希尔排序"],"categories":["developer"]},{"title":"CentOS 下使用 certbot 配置 Let's Encrypt SSL证书","url":"/archives/10/","content":"\n[certbot](https://certbot.eff.org/) 是一个提供命令行来自动配置网站 SSL 证书的工具。访问其[官网](https://certbot.eff.org/)可以获得不同操作系统以及不同 Web 服务器下的使用教程。\n<!--more-->\n\n  [Let's Encrypt](https://letsencrypt.org/) 是一个提供免费 SSL 证书认证服务的非营利性项目。旨在加速网页由 HTTP 协议到 HTTPS 的转变。\n\n  该教程以 CentOS 7.4 和 Apache 2.4 为例。最后更新时间：2018年3月24日。\n\n## 安装 certbot\n\n* 首先开启 EPEL 源\n\n```bash\nsudo yum -y install yum-utils\nsudo yum-config-manager --enable rhui-REGION-rhel-server-extras rhui-REGION-rhel-server-optional\n```\n\n* 安装 certbot-apache\n\n```bash\nsudo yum install certbot-apache\n```\n\n## 安装证书\n\n  如果你想直接自动安装自签名的证书，直接运行：\n\n```bash\nsudo certbot --apache\n```\n\n  根据提示操作即可。\n\n## 安装 Let's Encrypt 证书\n\n  但一般个人自签名证书是无法被浏览器认可的。所以我们需要安装 [Let's Encrypt](https://letsencrypt.org/) 提供的证书。\n\n  步骤如下：\n\n### 安装 DNS 插件\n\n  certbot 提供了 [一些DNS 插件](https://certbot.eff.org/docs/using.html#dns-plugins) 帮助我们自动配置证书服务。根据域名的 DNS 服务商安装对应的 certbot 插件。\n\n  这里以 [CloudXNS](https://www.cloudxns.net/) 为例。[CloudXNS](https://www.cloudxns.net/) 提供免费的域名托管服务。\n\n```bash\n# 安装 certbot-dns-cloudxns 插件\nsudo yum install python2-certbot-dns-cloudxns\n```\n\n### 准备 DNS 配置文件\n\n  在下面的安装证书的过程中需要一个配置文件来确认域名。\n\n  首先通过 CloudXNS 提供的 [API](https://www.cloudxns.net/en/AccountManage/apimanage.html) 获取认证信息，然后以下列格式保存该认证信息：\n\n```bash\n# CloudXNS API credentials used by Certbot\ndns_cloudxns_api_key = 1234567890abcdef1234567890abcdef\ndns_cloudxns_secret_key = 1122334455667788\n```\n\n### 安装\n\n  使用 certbot 自动安装证书。（注意替换下面命令中的域名）\n\n```bash\nsudo certbot -a dns-cloudxns -i apache -d \"*.example.com\" -d example.com --server https://acme-v02.api.letsencrypt.org/directory\n```\n\n  根据提示输入上文中准备好的 DNS 配置文件路径。然后继续按提示操作即可。\n\n### 可能遇到的问题\n\nQ: 找不到 DNS 服务商对应的 certbot dns 插件\n\n  A: 手动配置或更换 DNS 服务商\n\nQ: 提示 openSSL 版本过低\n\n  A: 卸载重装，具体步骤百度可得\n\nQ: 执行安装证书命令时提示缺少 python 库\n\n  A: 根据报错信息安装对应的库。StackOverflow 有类似问题的解决方案。\n\n~~其他问题请留言。~~\n","tags":["Server","SSL","HTTPS"],"categories":["developer"]},{"title":"为 CentOS 添加回收站功能","url":"/archives/9/","content":"\n在 centos 中删除文件时会使用 `rm -rf` 命令，然而该命令往往造成不可挽回的后果，比如手抖删错目录然后过段时间再想恢复几乎时不可能的。在很多桌面发行版本中已经有了回收站功能，在服务器端的 centos 中这个功能更为重要。\n\n<!--more-->\n  接下来就是一个经典的添加“回收站功能”的教程。\n\n## 编写 Shell 脚本\n\n  教程原理即是使用 `bash` 脚本中 `alias` 命令重写 `rm` 命令，将其修改为移动到指定回收站目录。\n\n  脚本内容如下：\n\n```bash\n#!/bin/bash\nmkdir -p ~/.trash\nalias rm=trash\nalias r=trash\nalias rl='ls ~/.trash'\nalias ur=undelfile\nundelfile() {\n   mv -i ~/.trash/$@ ./\n}\ntrash() {\n    mv $@ ~/.trash/\n}\n\n```\n\n  脚本很简单，即使没有任何 `bash` 编程基础也看得出大概意思。\n\n  首先在用户根目录下新建隐藏目录 `.trash` 作为回收站目录。然后重写 `rm` 命令。其中 `$@` 为获取输入的所有参数。所以重写命令后不需要使用 `-r` 参数，因为 `mv` 命令没有该参数。\n\n## 应用脚本\n\n  将上面的脚本追加到 `/etc/profile` 尾部，使用 `source /etc/profile` 应用改变，则所有的用户都会应用改变（第一次切换用户时记得 `source /etc/profile`）。如果想仅对某用户添加回收站功能，则修改用户目录下的 `.bashrc` 文件，追加上面的脚本，然后 `source ~/.bashrc` 即可。\n\n## 进阶版回收站\n\n  下面的回收站会根据删除时间分类并自动清理回收站。转载至[《CentOS实现回收站机制》](https://www.linuxidc.com/Linux/2016-01/127765.htm)。\n\n```bash\n#!/bin/bash\nmonth=`date \"+%m\"`    #获取当前月份\nday=`date \"+%d\"`    #获取当前日期　\n\nlast_day=`date -d \"-1 day\" \"+%d\"`    #获取前天月份\nlast_day_m=`date -d \"-1 day\" \"+%m\"`    #获取前天日期\n\ndel_day=`date -d \"-5 day\" \"+%d\"`    #获取五天前月份\ndel_day_m=`date -d \"-5 day\" \"+%m\"`    #获取五天前日期\n\nTrash_dir=\"/tmp/del_bak\"    #回收站总目录\ntmp_dir=\"/tmp/del_bak/tmp\"    #每天删除文件存放目录\n\n#下面是创建相应目录，并赋予777权限15 \nif [ ! -d $Trash_dir ]\nthen\n    /bin/mkdir -p $Trash_dir\n    /bin/chmod 777 $Trash_dir\nfi\n\nif [ ! -d $tmp_dir ]\nthen\n    /bin/mkdir -p $tmp_dir\n    /bin/chmod 777 $tmp_dir\nfi\n\nif [ ! -d /tmp/del_bak/$month ]\nthen\n    /bin/mkdir /tmp/del_bak/$month\n    /bin/chmod 777 /tmp/del_bak/$month\nfi\n\nif [ ! -d /tmp/del_bak/$month/$day ]\nthen\n    /bin/mkdir /tmp/del_bak/$month/$day\n    /bin/chmod 777 /tmp/del_bak/$month/$day\nfi\n\nTrash_file=`/bin/ls -A $tmp_dir`\n\n#这是定时在每天凌晨将昨天删除的文件放到已月份和日期分类的目录下\n#保证/tmp/del_bak/tmp目录下只存放当天删除的文件\nif [ \"$Trash_file\" != \"\" ]\nthen\n    cd $tmp_dir\n    if [ ! -d /tmp/del_bak/$last_day_m/$last_day/ ]\n    then\n      /bin/mkdir -p /tmp/del_bak/$last_day_m/$last_day/\n    fi\n    /bin/mv $tmp_dir/* /tmp/del_bak/$last_day_m/$last_day/\nfi\n\nif [ -d $Trash_dir/$del_day_m/$del_day/ ]    #清理五天前删除的文件\nthen\n    cd $Trash_dir/$del_day_m/$del_day/ && {\n        /bin/rm -rf $Trash_dir/$del_day_m/$del_day/\n    }\nfi\n```\n\n```bash\n#!/bin/bash\nUSER=`/usr/bin/whoami`    #获取当前用户\nTOOLS=\"/usr/local/tools\"    #存放Trash_mkdir.sh定时任务脚本的路径，可根据个人自行修改\nHOME_DIR=`/bin/grep \"$USER\" /etc/passwd|awk -F \":\" '{print $6}'`    #获取当前用户家目录\nCONF=$HOME_DIR\"/.bashrc\"    #拼接当前用户的配置文件路径\nTrash=`/bin/grep \"del\" $CONF`    #判断是否已经配置了回收站机制\n\nif [ \"$Trash\" = \"\" ]    #添加回收站别名del\nthen\n    echo \"alias del='mv -t /tmp/del_bak/tmp/ --backup=t'\" >>$CONF\nfi\n\nif [ ! -d $TOOLS ]\nthen\n    /bin/mkdir -p $TOOLS\nfi\n\n/bin/cp Trash_mkdir.sh $TOOLS    #拷贝定时任务脚本到指定目录\n/bin/chmod +x $TOOLS/Trash_mkdir.sh\n\nif [ -z \"`grep 'Trash_mkdir.sh' /var/spool/cron/root`\" ]    #判断定时任务crontab里是否已经加了回收站脚本\nthen\n    echo \"10 0 * * * $TOOLS/Trash_mkdir.sh\" >>/var/spool/cron/root\nfi\n\n/bin/sh $TOOLS/Trash_mkdir.sh　\n```\n\n### 部署说明\n\n1. 将两个脚本放在同一目录下\n\n2. 使用需要启用回收站功能的用户去执行install_Trash.sh脚本即可一键安装\n","tags":["Server","CentOS","bash"],"categories":["developer"]},{"title":"谨以此文祭奠我的前博客","url":"/archives/8/","content":"\n当我在云服务器控制台重装了 CentOS，部署完崭新的博客系统，在网站首页再次写下“积跬步以至千里，积小流以成江海”这句话时，我知道我兢兢业业积累了六个多月，近百篇涉猎甚广的博客已经一去不返了。\n<!--more-->\n\n  写博客不是一件轻松的事，初衷本是积累记录以便以后查阅。但又怕有需要的访客看到时由于内容太过笼统而不明所以，所以我力求把每篇博客写的清晰且正确。每一句话都斟酌是否准确，求证是否正确，并标注权威引用链接。语言难以描述清楚的内容便自己 PS 作图，或者附上可访问展示的 Demo。可以说是颇费苦心了。\n\n  创造一个美好东西的过程通常是复杂和困难的，但毁灭它往往要简单得多。有时只不过就是一句 `rm -rf` ，整个过程不会超过两秒，很安静。\n\n## 反思\n\n  我从来不害怕犯错，我只怕重复犯错。所以关于这次 `rm -rf` 误删系统关键文件导致博客丢失，我很快进行了反思，并在新部署的博客系统上进行了改进。总结如下：\n\n### 系统多用户管理\n\n  root 用户的权利太大了，使用 root 用户操作 Linux 系统无疑是一件刀尖舔血的艺术行为。做得好是艺高胆大，做不好便万劫不复。\n\n  应对不同的功能开设不同的用户。比如为服务器的网站管理开设专门的用户，分配其有限的权限。使其无法威胁到系统本身的正常运行。\n\n### 数据库多用户管理\n\n  同理，数据库也应开设不同用户，限制其危险操作的权限。\n\n### 开启回收站功能\n\n  CentOS 默认是没有回收站功能的，一旦 `rm -rf` 命令操作成功，想要找回数据往往不是一件简单的事，尤其是当服务器还在进行高频的数据 IO。\n\n  所以我们应该自己实现一个回收站的功能，其实很简单，即重写系统的 `rm` 命令为 `mv` 命令。将想要删除的文件转移到指定目录，并定期清理即可。关于具体的实现过程，我会尽快整理发布。\n\n### 更改 Web 服务器默认路径\n\n  以 Apache 为例，默认网站更目录是在 `/var/` 下。这是这次误删事件的直接原因，我本想删除某子目录下的 `var` 目录，结果手抖多打了 `/` 就把 `/var/` 目录全删了，数据库文件也在里面。\n\n  所以如果 Web 服务器的网站更目录在系统关键目录下，应该将他转到网站管理员用户目录下。降低误操作带来的风险。\n\n### 数据备份\n\n  其实在这次误删系统文件前我有备份过博客数据，不过时间比较久了，但仍能找回部分博客内容。可见有一个定期备份数据的好习惯是多么重要。\n","tags":["Server","运维"],"categories":["developer"]},{"title":"CSS 实现水平垂直居中布局","url":"/archives/27/","content":"\n\n>居中的实现是 CSS 布局中很典型（poster child）的问题。本文试图从不同的应用场景（水平居中、垂直居中、水平垂直居中）入手，尽可能列举常见的解决方案。\n\n<!-- more -->\n\n[参考]\n\n[《Centering in CSS: A Complete Guide》](https://css-tricks.com/centering-css-complete-guide/)\n\n[《Absolute Horizontal And Vertical Centering In CSS》](https://www.smashingmagazine.com/2013/08/absolute-horizontal-vertical-centering-css/)\n\n## 1 水平居中\n\n### 1.1 行内元素的水平居中\n\n**行内元素（包括 `inline-block`）**的水平居中很容易实现，只需要在其父级 `block` 元素中添加 `text-align: cneter` 属性即可：\n\n```css\n.father-block {\n  text-align: center;\n}\n```\n\n<iframe height='265' scrolling='no' title='单行行内元素水平居中' src='//codepen.io/Hozen/embed/PQgmGP/?height=265&theme-id=light&default-tab=result&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>\n</iframe>\n  \n当父级元素设置了以上属性后，所有行内子元素都会居中，即使有**多个行内子元素**。\n\n### 1.2 块级元素的水平居中\n\n块级元素的水平居中只需要给该元素的 `margin-left` 和 `margin-right` 属性的值设置为 `auto`。当然此时该**元素需要设置宽度**，不然默认是占满整行的不需要水平居中处理。通常使用简写方式：\n\n```css\n.center-block {\n  width: 20%;\n  margin: 0 auto;\n}\n```\n\n### 1.3 多个块级元素的居中\n\n当有多个块级元素排布在一行或多行，需要水平居中时。可以将这些块级元素设置为行内元素 `display: inline-block`，然后在父元素中设置 `text-align: center`：\n\n<iframe height='400' scrolling='no' title='GQLmWJ' src='//codepen.io/Hozen/embed/GQLmWJ/?height=265&theme-id=light&default-tab=result&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>\n</iframe>\n  \n可以看到这三个子元素水平居中了。由于它们的高度不同，我们可以看出行内元素默认是底部对齐的。我们可以通过设置子元素 `vertical-align: middle` 使得三个子元素在垂直方向以中线对齐。\n  \n使用 **flex 弹性布局**是个更好的选择：\n\n<iframe height='400' scrolling='no' title='GQLmEp' src='//codepen.io/Hozen/embed/GQLmEp/?height=265&theme-id=light&default-tab=result&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>\n</iframe>\n\n使用 flex 布局子元素的高度被统一。\n\n## 2. 垂直居中\n\n垂直居中的实现相对水平居中要复杂一些。我们依旧分类讨论:\n\n### 2.1 行内元素的垂直居中\n\n#### 2.1.1 单行\n\n如果需要垂直居中的元素排布在一行上，可以通过设置父元素的 `padding-top` 和 `padding-bottom` 属性的值相等来使它的子元素垂直居中（其实上面水平居中的例子中，我们已经使用了这种方式使得子元素垂直居中了）。当然这种情况只能适用于**父元素的高度未显式指定而是自动适应的**。\n  \n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"Centering text with Padding\" src=\"https://codepen.io/Hozen/embed/vYvqdRY?default-tab=result\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/Hozen/pen/vYvqdRY\">\n  Centering text with Padding</a> by Hozen (<a href=\"https://codepen.io/Hozen\">@Hozen</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n\n如果父元素的 `height` 被指定且大于子元素的高度时，上面的方法是不起作用的。这时可以通过设置父元素的 `line-height` 属性的值使它等于自身的 `height` 达到垂直居中的效果。\n\n<iframe height='460' scrolling='no' title='YeMVEz' src='//codepen.io/Hozen/embed/YeMVEz/?height=265&theme-id=light&default-tab=result&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>\n</iframe>\n\n#### 2.1.2 多行\n\n通过上面的例子我们可以发现，当行内元素仅仅是单行显示的话，可以很简单的设置父元素 `line-height` 等于父元素的高以及上下 `padding` 值相等的方法使子元素垂直居中。\n\n在子元素包含多行文本时，通过设置父元素上下 `padding` 值相等的方法依然能够生效，不过还是会有同样的限制条件。不过设置子元素 `line-height` 的方法就行不通了。\n\n这时我们可以使用 table 布局或通过 CSS 模拟 table 布局实现垂直居中：\n\ntable 布局实现垂直居中:\n\n<iframe height='460' scrolling='no' title='EQJmeM' src='//codepen.io/Hozen/embed/EQJmeM/?height=265&theme-id=light&default-tab=result&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>\n</iframe>\n\n通过 CSS 模拟设置父元素 display 为 table，设置子元素为 table-cell，那么子元素中的元素将垂直居中。不过这种方法的一个缺点是需要用到三层嵌套。\n\n<iframe height='460' scrolling='no' title='YeMVEz' src='//codepen.io/Hozen/embed/YeMVEz/?height=265&theme-id=light&default-tab=result&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>\n</iframe>\n  \ntable 布局已经不常用了，取而代之的是 flex 布局，在能使用 flex 的时候，flex 大概是最好的选择了。\n\n<iframe height='460' scrolling='no' title='aqxVgB' src='//codepen.io/Hozen/embed/aqxVgB/?height=265&theme-id=light&default-tab=result&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>\n</iframe>\n  \n除了 table 布局和 flex 布局，还可以使用“ghost element”技术，给父元素添加一个全高度的伪元素 `:before`，使内部的文本与它垂直中线对齐。\n\n<iframe height='460' scrolling='no' title='ghost element 垂直居中' src='//codepen.io/Hozen/embed/RQOxRB/?height=265&theme-id=light&default-tab=result&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>\n</iframe>\n  \n### 2.2 块级元素的垂直居中\n\n#### 2.2.1 已知高度块级元素垂直居中\n\n如果子元素的高度是固定的，或可预知的，则可以使用绝对定位 + 负外边距的方法实现垂直居中：\n\n```css\n.parent{\n  position: relative;\n}\n.child{\n  position: absolute;\n  top: 50%;\n  height: 100px;\n  margin-top: -50px; /* account for padding and border if not using box-sizing: border-box; */\n}\n```\n\n这种情况很好理解，不再举例。\n\n#### 2.2.2 未知高度块级元素垂直居中\n\n使用绝对定位 + 2D变换（Y轴平移）的方法在未知高度的情况下也可以正常工作。\n\n```css\n.parent {\n  position: relative;\n}\n.child {\n  position: absolute;\n  top: 50%;\n  transform: translateY(-50%);\n}\n```\n\n<iframe height='460' scrolling='no' title='translate 垂直水平居中' src='//codepen.io/Hozen/embed/ddLJNm/?height=265&theme-id=light&default-tab=result&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>\n</iframe>\n\n### 2.3 flex 布局垂直居中\n\n毫无疑问像之前一样我们可以使用 flex 布局解决这个问题：\n\n```css\n.parent{\n  display: flex;\n  align-items: center;\n}\n```\n\n## 3 水平垂直居中\n\n将上面分别实现水平和垂直居中的方法相结合就能同时实现水平和垂直居中了，其实在上面的例子中已经这么做了，所以下面简单总结，不再举例。\n\n### 3.1 固定宽高的居中\n\n固定宽高的情况，我们可以直接使用绝对定位 + 负外边距修正的方式实现水平垂直居中。\n\n```css\n.father {\n  position: relative;\n}\n\n.child {\n  height: 200px;\n  width: 400px;\n\n  position: absolute;\n  top: 50%;\n  left: 50%;\n\n  margin-top: -100px;\n  margin-left: -200px;\n}\n```\n\n### 3.2 自适应宽高的居中\n\n与实现块级元素的垂直居中思路一致，当元素宽高不固定时，可以使用位置变换修正绝对定位的位置。\n\n```css\n.father {\n  position: relative;\n}\n.child {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n}\n```\n\n### 3.3 flex 布局\n\nflex 布局总能轻松地解决各种情形下的居中问题。\n\n另外，需要注意的是 flex 中 `align-items` 和 `align-content` 属性的不同效果。\n\n```css\n.father {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n```\n\n### 3.3 table布局实现居中\n\n像通过 table 布局实现垂直居中一样，我们可以在此基础上通过 `margin: 0 auto` 等手段再使得元素水平居中即可。\n  \n### 3.4 伪元素实现居中\n\n首先我们将需要居中的元素设置为 `inline-block`，然后给父元素添加满高伪元素，通过 `vertical-align: center` 的方法使元素垂直居中。只需要再在父元素总添加 `text-align: center` 属性即可实现水平居中。\n\n### 3.5 grid布局实现居中\n\ngrid 布局在兼容性允许下好像是一个完美的布局方案，请参照 MDN 官方文档。\n\n### Absolute Centering\n\n这个一个基于绝对定位的居中处理方案，并且适用于宽高未知（百分比）的情况，可以实现多种常见布局，具有不错的兼容性。这里只简单介绍如果使用该技术实现垂直水平居中，更多应用场景和详细介绍请查看[《Absolute Horizontal And Vertical Centering In CSS》](https://www.smashingmagazine.com/2013/08/absolute-horizontal-vertical-centering-css/)\n\n<iframe height='460' scrolling='no' title='absolute centering' src='//codepen.io/Hozen/embed/RQOQGb/?height=265&theme-id=light&default-tab=result&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>\n</iframe>\n\n其实，这个布局的关键在于设置局对定位后，将 `top` `right` `bottom` `left` 的值全设置为0，在指定宽高后，同时设置 `margin: auto`，（不可设置为0）后就可以实现了水平垂直居中。\n\n## 总结\n\n我们可以看到实现水平居中往往是一件简单的事情，可以使用 `margin: 0 auto`，和行内元素的 `text-align: center` 设置实现水平居中。\n\n垂直居中通常是一件麻烦的事，我们往往需要根据应用场景来选择合适的方法。我们将垂直居中和垂直水平居中的实现一起总结：\n\n当元素的高度是固定值时，可以通过绝对定位 + 负外边距修正的方法实现垂直居中，然后通过 `margin: 0 auto` 再将元素水平居中。甚至当父元素的宽高也固定，我们可以直接计算子元素的居中定位的坐标即可，但实际开发中这种情况很少见。\n\n元素高度不定时，可以通过绝对定位 + translate 的方法实现居中，思路和负外边距一致。在不知道元素宽高时，可以通过 `translate` 的百分比值自动获取元素宽高的一半。而 `margin` 的百分比值是根据父元素的 width 值计算的，我们无法获取子元素的宽高的一半，这就是这里为什么不能通过指定 `margin-top: -50%; margin-left: -50%` 实现修正的原因。\n\n元素高度不定时，table 布局也是一个不错的解决方法，它利用了 `table-cell` 元素会沾满 `table` 父元素，并且可以使用 `vertical-align: middle` 使内部元素垂直居中对齐的特点。不过这种方法需要嵌套三层盒子。\n\n伪元素居中方法，该方法给父元素设置一个满高的伪元素，子元素设置为 `inline-block`。设置伪元素 `vertical-align: middle` 使得子元素与伪元素中线对齐，实现垂直居中。设置父元素 `text-align: center`，实现水平居中。不过这种情况可能需要给伪元素一个负的外边距，因为伪元素占了一定的宽度，导致子元素并非真正的水平居中。同时，子元素的宽度不能太宽（达到100%），不然可能使得子元素与伪元素分列两行。\n\n当高度不是固定（通过百分比指定）的时候，我们还可以采用绝对定位 + margin: auto 的方法实现垂直水平居中。详见最后一个实例。\n","tags":["CSS","CSS 布局"],"categories":["developer"]},{"title":"CSS3 制作常见几何图形","url":"/archives/28/","content":"\n\n  通过 CSS3 提供一些新的属性和标准，可以实现一些常见的几何图形。避免使用贴图等其他手段，减少网络请求和资源大小，同时自适应和缩放效果会更好。\n\n<!-- more -->\n## CSS 的边框\n\n  因为 HTML 的元素一般是占据矩形空间，或者由矩形拼接的空间（如由于内容过长而换行的行内元素）。所以除了矩形之外的几何图形实现一般要借助 `border` 属性来完成。现在来了解一下 CSS 的 `border` 属性。\n\n  `border` 相关的属性只有 `border-width` `border-style` `border-color` 和 `border-radius` 等，同时可以在 `border` 后添加 `top` `bottom` `left` 或 `right` 来指定单边边框。如，`border-top-width: 10px`，仅指定上边框的宽度为 `10 px`。\n\n  `border-style` 可选的值有 `dotted` `dashed` `solid` `double` `groove` `ridge` `inset` `outset` `none`，可以通过下面的例子大概区分一下：\n\n```html\n<style>\n    .child {\n      display: inline-block;\n      width: 200px;\n      height: 200px;\n      border-width: 10px;\n      border-color: #e3e3e3;\n    }\n    .border1 {\n      border-style: solid double dotted dashed;\n      margin-right: 20px;\n    }\n    .border2 {\n      border-style: groove ridge inset outset;\n    }\n</style>\n<div id='border1'></div>\n<div id='border2'></div>\n```\n\n<iframe height='280' scrolling='no' title='border-style' src='//codepen.io/Hozen/embed/mzgWOZ/?height=265&theme-id=light&default-tab=result' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>\n</iframe>\n  \n  `border-width` 和 `border-color` 属性很简单，指定宽度和颜色。颜色可以使用所有 `CSS3` 的颜色格式，可以通过指定 `transparent` 使边框透明，在利用边框绘制多边形时，经常会用到透明边框。\n\n  `border-radius` 是 `CSS3` 的新属性，为边框指定圆角的半径。可以通过 `broder-top-left-radius: 2px` 的格式指定特定的角。在使用 `CSS3` 绘制圆形或椭圆形相关的图形时经常用到。\n\n```html\n<style>\n    div {\n        background: #0aaaa0;\n        border-radius: 50%;  /*等价于 border-radius: 150px / 100px; */\n        width: 300px;\n        height: 200px;\n    }\n</style>\n<div></div>\n```\n\n<iframe height='322' scrolling='no' title='border-radius' src='//codepen.io/Hozen/embed/gBymXb/?height=322&theme-id=light&default-tab=result' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>See the Pen <a href='https://codepen.io/Hozen/pen/gBymXb/'>border-radius</a> by Hozen (<a href='https://codepen.io/Hozen'>@Hozen</a>) on <a href='https://codepen.io'>CodePen</a>.\n</iframe>\n\n## 椭圆形\n\n  上例中已经给出了绘制椭圆形的例子，只需给一个长方形的 `border-radius 的值设为 50%` 即可绘制椭圆形，而给一个正方形的 `border-radius` 设置为 `50%` 时，即为圆形。效果等同于使用 `/` 设置边角的横向和纵向的半径分别为宽和长的一半。\n\n  绘制半个椭圆：\n\n```html\n<style>\n    div {\n       background: #0aaaa0;\n       border-top-left-radius: 100px 150px;\n       border-top-right-radius: 100px 150px;\n       width: 200px;\n       height: 150px;\n    }\n</style>\n<div></div>\n```\n\n<iframe height='277' scrolling='no' title='border-radius' src='//codepen.io/Hozen/embed/XxQMZq/?height=277&theme-id=light&default-tab=css,result' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>\n</iframe>\n\n## 三角形\n\n  我们可以为一个矩形设置不同的边框颜色来查看边框的表现形式：\n\n```html\n<style>\n    .item {\n      display: inline-block;\n      width: 100px;\n      height: 100px;\n      border-style: solid;\n      border-width: 40px;\n      border-color: #f6666f #0aaaa0 yellow #aa00ff;\n    }\n    .two {\n      margin-left: 50px;\n      border-right: none;\n    }\n</style>\n<div class=\"item\"></div>\n<div class=\"item two\"></div>\n```\n\n<iframe height='305' scrolling='no' title='border' src='//codepen.io/Hozen/embed/gBymQP/?height=305&theme-id=light&default-tab=result' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>\n</iframe>\n\n  可以看出边框的交接处是斜边，另外当有一边无边框的时候，会呈现右图的样式。可以利用这一点实现一个三角形。\n\n```html\n<style>\n    div {\n       width: 0;\n       height: 0;\n       border-style: solid;\n       border-width: 80px 100px;\n       border-color: transparent;\n       border-left-color: #0aaaa0;\n       border-right: none;\n    }\n</style>\n<div></div>\n```\n\n<iframe height='288' scrolling='no' title='border' src='//codepen.io/Hozen/embed/ReOpvP/?height=288&theme-id=light&default-tab=css,result' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>\n</iframe>\n\n## 组合图形\n\n  可以结合伪类选择器 `before` 和 `after` 以及 `transform` 变化实现一些组合图形的绘制。比如，绘制叉号：\n\n```html\n<style>\ndiv {\n    height: 100px;\n    width: 100px;\n    position: relative;\n}\ndiv::before, div::after{\n    background: #0aaaa0;\n    border-radius: 5px;\n    position: absolute;\n    top: 50%;\n    transform: translateX(-50%);\n    content: '';\n    width: 100px;\n    height: 15px;\n}\ndiv::before {\n    transform: rotate(-45deg);\n}\ndiv::after {\n    transform: rotate(-135deg);\n}\n</style>\n<div></div>\n```\n\n<iframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"Untitled\" src=\"https://codepen.io/Hozen/embed/oaOZVK?default-tab=html%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/Hozen/pen/oaOZVK\">\n  Untitled</a> by Hozen (<a href=\"https://codepen.io/Hozen\">@Hozen</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.\n</iframe>\n","tags":["CSS","CSS 特效"],"categories":["developer"]}]